<!DOCTYPE HTML>
<html lang="en-gb" class="no-js">
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=2.5,user-scalable=yes">
    <meta name="citation_publisher" content="Springer Berlin Heidelberg"/>
    <meta name="citation_title" content="The computability of relaxed data structures: queues and stacks as examples"/>
    <meta name="citation_doi" content="10.1007/s00446-016-0272-0"/>
    <meta name="citation_language" content="en"/>
    <meta name="citation_abstract_html_url" content="https://link.springer.com/article/10.1007/s00446-016-0272-0"/>
    <meta name="citation_fulltext_html_url" content="https://link.springer.com/article/10.1007/s00446-016-0272-0"/>
    <meta name="citation_pdf_url" content="https://link.springer.com/content/pdf/10.1007%2Fs00446-016-0272-0.pdf"/>
    <meta name="citation_springer_api_url" content="http://api.springer.com/metadata/pam?q=doi:10.1007/s00446-016-0272-0&amp;api_key="/>
    <meta name="citation_firstpage" content="395"/>
    <meta name="citation_lastpage" content="407"/>
    <meta name="citation_author" content="Nir Shavit"/>
    <meta name="citation_author_institution" content="MIT"/>
    <meta name="citation_author_institution" content="Tel-Aviv University"/>
    <meta name="citation_author" content="Gadi Taubenfeld"/>
    <meta name="citation_author_institution" content="The Interdisciplinary Center"/>
    <meta name="citation_author_email" content="tgadi@idc.ac.il"/>
    <meta name="dc.identifier" content="10.1007/s00446-016-0272-0"/>
    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" content="Most concurrent data structures being designed today are versions of known sequential data structures. However, in various cases it makes sense to relax the semantics of traditional concurrent data..."/>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="The computability of relaxed data structures: queues and stacks as exa"/>
    <meta name="twitter:image" content="https://static-content.springer.com/cover/journal/446/29/5.jpg"/>
    <meta name="twitter:image:alt" content="Content cover image"/>
    <meta name="twitter:site" content="SpringerLink"/>
    <meta name="twitter:description" content="Most concurrent data structures being designed today are versions of known sequential data structures. However, in various cases it makes sense to relax the semantics of traditional concurrent data..."/>
    <meta name="citation_journal_title" content="Distributed Computing"/>
    <meta name="citation_journal_abbrev" content="Distrib. Comput."/>
    <meta name="citation_volume" content="29"/>
    <meta name="citation_issue" content="5"/>
    <meta name="citation_issn" content="0178-2770"/>
    <meta name="citation_issn" content="1432-0452"/>
    <meta name="citation_online_date" content="2016/04/26"/>
    <meta name="citation_cover_date" content="2016/10/01"/>
    <meta name="citation_article_type" content="Article"/>
    <meta property="og:title" content="The computability of relaxed data structures: queues and stacks as examples"/>
    <meta property="og:type" content="Article"/>
    <meta property="og:url" content="https://link.springer.com/article/10.1007/s00446-016-0272-0"/>
    <meta property="og:image" content="https://static-content.springer.com/cover/journal/446/29/5.jpg"/>
    <meta property="og:site_name" content="SpringerLink"/>
    <meta property="og:description" content="Most concurrent data structures being designed today are versions of known sequential data structures. However, in various cases it makes sense to relax the semantics of traditional concurrent data..."/>

        <title>The computability of relaxed data structures: queues and stacks as examples | SpringerLink</title>
        <link rel="canonical" href="https://link.springer.com/article/10.1007/s00446-016-0272-0"/>
        <link rel="shortcut icon" href="/springerlink-static/632953562/images/favicon/favicon.ico">
<link rel="icon" sizes="16x16 32x32 48x48" href="/springerlink-static/632953562/images/favicon/favicon.ico">
<link rel="icon" sizes="16x16" type="image/png" href="/springerlink-static/632953562/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" type="image/png" href="/springerlink-static/632953562/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" type="image/png" href="/springerlink-static/632953562/images/favicon/favicon-48x48.png">
<link rel="apple-touch-icon" href="/springerlink-static/632953562/images/favicon/app-icon-iphone@3x.png">
<link rel="apple-touch-icon" sizes="72x72" href="/springerlink-static/632953562/images/favicon/ic_launcher_hdpi.png">
<link rel="apple-touch-icon" sizes="76x76" href="/springerlink-static/632953562/images/favicon/app-icon-ipad.png">
<link rel="apple-touch-icon" sizes="114x114" href="/springerlink-static/632953562/images/favicon/app-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/springerlink-static/632953562/images/favicon/app-icon-iphone@2x.png">
<link rel="apple-touch-icon" sizes="144x144" href="/springerlink-static/632953562/images/favicon/ic_launcher_xxhdpi.png">
<link rel="apple-touch-icon" sizes="152x152" href="/springerlink-static/632953562/images/favicon/app-icon-ipad@2x.png">
<link rel="apple-touch-icon" sizes="180x180" href="/springerlink-static/632953562/images/favicon/app-icon-iphone@3x.png">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/springerlink-static/632953562/images/favicon/ic_launcher_xxhdpi.png">
        <link rel="dns-prefetch" href="//fonts.gstatic.com">
<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="dns-prefetch" href="//google-analytics.com">
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="dns-prefetch" href="//www.googletagservices.com">
<link rel="dns-prefetch" href="//www.googletagmanager.com">
<link rel="dns-prefetch" href="//static-content.springer.com">
        <link rel="stylesheet" href="/springerlink-static/632953562/css/basic.css" media="screen">
<link rel="stylesheet" href="/springerlink-static/632953562/css/styles.css" class="js-ctm" media="only screen and (-webkit-min-device-pixel-ratio:0) and (min-color-index:0), (-ms-high-contrast: none), only all and (min--moz-device-pixel-ratio:0) and (min-resolution: 3e1dpcm)">
<link rel="stylesheet" href="/springerlink-static/632953562/css/print.css" media="print">


            <script type="text/javascript">
        window.Krux||((Krux=function(){Krux.q.push(arguments);}).q=[]);
        var dataLayer = [{
                'GA Key':"UA-26408784-1",
                'Features':["leaderboardadverts","eventtracker"],
                'Event Category':"Article",
                'Open Access':"N",
                'Labs':"Y",
                'DOI':"10.1007/s00446-016-0272-0",
                'VG Wort Identifier':"pw-vgzm.415900-10.1007-s00446-016-0272-0",
                'hasAccess':"Y",
                'Full HTML':"Y",
                'Has Body':"Y",
                'Static Hash':"632953562",
                'Has Preview':"N",
                'user':{"license":{"businessPartnerID":["2000328745","3000155420","3000180852","3003532199"],"businessPartnerIDString":"2000328745|3000155420|3000180852|3003532199"}},
                'content':{"serial":{"eissn":"1432-0452","pissn":"0178-2770"},"type":"Article","category":{"pmc":{"primarySubject":"Computer Science","primarySubjectCode":"I","secondarySubjects":{"4":"Software Engineering/Programming and Operating Systems","5":"Theory of Computation","1":"Computer Communication Networks","2":"Computer Hardware","3":"Computer Systems Organization and Communication Networks"},"secondarySubjectCodes":{"4":"I14002","5":"I16005","1":"I13022","2":"I1200X","3":"I13006"}},"sucode":"SC6"}},
                'Access Type':"subscription",
                'Page':"article",
                'Bpids':"2000328745, 3000155420, 3000180852, 3003532199",
                'Bpnames':"Universit√† degli Studi di Roma La Sapienza, CRUI-CARE Italy, CARE 2009 & 2010, Care Nature",
                'SubjectCodes':"SCI, SCI13022, SCI1200X, SCI13006, SCI14002, SCI16005",
                'session':{"authentication":{"loginStatus":"N"},"attributes":{"edition":"academic"}},
                'eventTrackerBaseUrl':"https://event-tracker.springernature.com",
                'Keywords':"Relaxed data structure, Consensus number, Synchronization, Wait-freedom, Queue, Stack, Multiset, k-register",
                'Country':"IT",
                'Journal Id':"446",
                'Journal Title':"Distributed Computing",

                    'doi': "10.1007-s00446-016-0272-0",
                    'kwrd': ["Relaxed_data_structure","Consensus_number","Synchronization","Wait-freedom","Queue","Stack","Multiset","k-register"],
                    'pmc': ["I","I13022","I1200X","I13006","I14002","I16005"],
                    'BPID': ["2000328745","3000155420","3000180852","3003532199"],
                    'ksg': Krux.segments,
                    'kuid': Krux.uid,

        }];
    </script>

<script type="text/javascript" src="/springerlink-static/632953562/js/jquery-3.3.1.min.js"></script>

        <script type="text/javascript" src="https://cdn.cookielaw.org/consent/6b2ec9cd-5ace-4387-96d2-963e596401c6.js" charset="UTF-8"></script>

<script type="text/javascript">
    function OptanonWrapper() {
        dataLayer.push({
            'event' : 'onetrustActive'
        });
    }
</script>

    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WCF9Z9');</script>

    </head>
    <body>
        <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-WCF9Z9"
                      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <div class="skip-to">
    <a class="skip-to__link pseudo-focus" href="#main-content">Skip to main content</a>
        <a class="skip-to__link skip-to__link--contents pseudo-focus" href="#article-contents">Skip to sections</a>
</div>
        <div class="page-wrapper">
            <noscript>
    <div class="nojs-banner u-interface">
        <p>This service is more advanced with JavaScript available, learn more at <a
                href="http://activatejavascript.org" target="_blank" rel="noopener">http://activatejavascript.org</a>
        </p>
    </div>
</noscript>
                        <div id="leaderboard" class="leaderboard u-hide" data-component="SpringerLink.GoogleAds" data-namespace="leaderboard">
            <div class="leaderboard__wrapper">
                <p class="leaderboard__label">Advertisement</p>
                <button class="leaderboard__hide" title="Hide this advertisement"  data-track="click" data-track-action="Hide advertisement" data-track-label="">Hide</button>
                <div id="doubleclick-leaderboard-ad" class="leaderboard__ad u-pt-24"></div>
            </div>
        </div>


                <header id="header" class="header u-interface">
        <div class="header__content">
            <div class="header__menu-container">
                    <a id="logo" class="site-logo" href="/" title="Go to homepage">
                <div class="u-screenreader-only">SpringerLink</div>
    <svg class="site-logo__springer" width="148" height="30" role="img" focusable="false" aria-hidden="true">
        <image width="148" height="30" alt="" src="/springerlink-static/632953562/images/png/springerlink.png" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/springerlink-static/632953562/images/svg/springerlink.svg"></image>
    </svg>

    </a>


                    <nav id="search-container" class="u-inline-block">
                        <div class="search">
                            <div class="search__content">
                                <form class="u-form-single-input" action="/search" method="get" role="search">
    <label for="search-springerlink">Search SpringerLink</label>
    <div class="u-relative">
        <input id="search-springerlink" name="query" type="text" autocomplete="off" value="">
        <input class="u-hide-text" type="submit" value="Submit" title="Submit">
        <svg class="u-vertical-align-absolute" width="13" height="13" viewBox="222 151 13 13" version="1.1" xmlns="http://www.w3.org/2000/svg" focusable="false" aria-hidden="true" role="presentation">
            <path d="M227 159C228.7 159 230 157.7 230 156 230 154.3 228.7 153 227 153 225.3 153 224 154.3 224 156 224 157.7 225.3 159 227 159L227 159 227 159 227 159ZM230 160.1L231.1 159 233.9 161.7C234.2 162.1 234.2 162.6 233.9 162.9 233.6 163.2 233.1 163.2 232.7 162.9L230 160.1 230 160.1 230 160.1 230 160.1ZM227 161L227 161C224.2 161 222 158.8 222 156 222 153.2 224.2 151 227 151 229.8 151 232 153.2 232 156 232 158.8 229.8 161 227 161L227 161 227 161 227 161 227 161Z" stroke="none" fill-rule="evenodd"/>
        </svg>
    </div>
</form>
                            </div>
                        </div>
                    </nav>

                    <nav class="nav-container u-interface">
    <div class="global-nav__wrapper">
        <div class="search-button">
            <a class="search-button__label" href="#search-container">
                <span class="search-button__title">Search</span><svg width="12" height="12" viewBox="222 151 12 12" version="1.1" xmlns="http://www.w3.org/2000/svg" focusable="false" aria-hidden="true" role="presentation">
                    <path d="M227 159C228.7 159 230 157.7 230 156 230 154.3 228.7 153 227 153 225.3 153 224 154.3 224 156 224 157.7 225.3 159 227 159L227 159 227 159 227 159ZM230 160.1L231.1 159 233.9 161.7C234.2 162.1 234.2 162.6 233.9 162.9 233.6 163.2 233.1 163.2 232.7 162.9L230 160.1 230 160.1 230 160.1 230 160.1ZM227 161L227 161C224.2 161 222 158.8 222 156 222 153.2 224.2 151 227 151 229.8 151 232 153.2 232 156 232 158.8 229.8 161 227 161L227 161 227 161 227 161 227 161Z" stroke="none" fill-rule="evenodd"></path>
                </svg>
            </a>
        </div>

        <ul class="global-nav" data-component="SV.Menu" data-title="Navigation menu" data-text="Menu">
            <li>
                <a href="/">
                    <span class="u-overflow-ellipsis">Home</span>
                </a>
            </li>

                <li class="global-nav__logged-out">
                    <a class="test-login-link" href="//link.springer.com/signup-login?previousUrl=https%3A%2F%2Flink.springer.com%2Farticle%2F10.1007%2Fs00446-016-0272-0">
                        <span class="u-overflow-ellipsis">Log in</span>
                    </a>
                </li>

        </ul>
    </div> 
</nav> 
            </div>

        </div>
    </header>

            
            <main id="main-content" class="main-wrapper" tabindex="-1">
                <div class="main-container uptodate-recommendations-off">
                    <aside class="main-sidebar-left">
                        <div class="main-sidebar-left__content">
                            <div class="cover-image test-cover" itemscope>
                                    <a class="test-cover-link" href="/journal/446">
        <span class="u-screenreader-only">Distributed Computing</span>
        <img class="test-cover-image" src="https://media.springernature.com/w306/springer-static/cover/journal/446/29/5.jpg" itemprop="image" alt=""/>
    </a>


                            </div>
                        </div>
                    </aside>
                    <div class="main-body" data-role="NavigationContainer">
                                <div class="cta-button-container cta-button-container--top cta-button-container--stacked u-mb-16 u-hide-two-col">
                    <div>
            <a href="/content/pdf/10.1007%2Fs00446-016-0272-0.pdf" target="_blank" class="c-button c-button--blue c-button__icon-right" title="Download this article in PDF format" rel="noopener" data-track="click" data-track-action="Pdf download" data-track-label="">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" version="1.1"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill="#fff"><g transform="translate(12.000000, 5.000000)"><path d="M7 7.3L7 1C7 0.4 6.6 0 6 0 5.4 0 5 0.4 5 1L5 7.3 3.5 5.7C3.1 5.3 2.5 5.3 2.1 5.7L2.1 5.7C1.7 6.1 1.7 6.7 2.1 7.1L5.3 10.3C5.7 10.7 6.3 10.7 6.7 10.3L9.9 7.1C10.3 6.7 10.3 6.1 9.9 5.7L9.9 5.7C9.5 5.3 8.9 5.3 8.5 5.7L7 7.3 7 7.3ZM0 13C0 12.4 0.5 12 1 12L11 12C11.6 12 12 12.4 12 13 12 13.6 11.5 14 11 14L1 14C0.4 14 0 13.6 0 13L0 13Z"/></g></g></g></svg>
                <span class="hide-text-small">Download</span>
                <span>PDF</span>
            </a>
        </div>

        </div>



                        <article class="main-body__content">
                            <div xmlns="http://www.w3.org/1999/xhtml" class="FulltextWrapper"><div class="ArticleHeader main-context"><div id="enumeration" class="enumeration"><p><a href="/journal/446" title="Distributed Computing" data-track="click" data-track-action="Journal title" data-track-label=""><span class="JournalTitle">Distributed Computing</span></a></p><p class="icon--meta-keyline"><span class="ArticleCitation_Year"><time datetime="2016-10">October 2016</time>, </span><span class="ArticleCitation_Volume">Volume 29, </span><a class="ArticleCitation_Issue" href="/journal/446/29/5/page/1" data-track="click" data-track-action="Article issue" data-track-label="">Issue¬†5</a>,
                       <span class="ArticleCitation_Pages"> pp 395‚Äì407</span><span class="u-inline-block u-ml-4"> | <a href="#citeas" data-track="click" data-track-action="Cite as link" data-track-label="Enumeration section">Cite as</a></span></p></div><div class="MainTitleSection"><h1 class="ArticleTitle" lang="en">The computability of relaxed data structures: queues and stacks as examples</h1></div><div class="authors u-clearfix" data-component="SpringerLink.Authors"><ul class="u-interface u-inline-list authors__title" data-role="AuthorsNavigation"><li><span>Authors</span></li><li><a href="#authorsandaffiliations" data-track="click" data-track-action="Authors and affiliations tab" data-track-label="">Authors and affiliations</a></li></ul><div class="authors__list" data-role="AuthorsList"><ul class="test-contributor-names"><li itemscope="" itemtype="http://schema.org/Person" class="u-mb-2 u-pt-4 u-pb-4"><span itemprop="name" class="authors__name">Nir¬†Shavit</span></li><li itemscope="" itemtype="http://schema.org/Person" class="u-mb-2 u-pt-4 u-pb-4"><span itemprop="name" class="authors__name">Gadi¬†Taubenfeld</span><span class="author-information"><span class="authors__contact"><a href="mailto:tgadi@idc.ac.il" title="tgadi@idc.ac.il" itemprop="email" data-track="click" data-track-action="Email author" data-track-label=""><img src="/springerlink-static/images/svg/email.svg" height="24" width="24" alt="Email author" /></a></span></span></li></ul></div></div><div class="main-context__container" data-component="SpringerLink.ArticleMetrics"><div class="main-context__column"><span><span class="test-render-category">Article</span></span><div class="article-dates"><span class="article-dates__label">First Online: </span><span class="article-dates__first-online"><time datetime="2016-04-26">26 April 2016</time></span></div></div><div class="main-context__column">    <ul id="book-metrics" class="article-metrics u-sansSerif">
            <li class="article-metrics__item">
                    <a class="article-metrics__link gtm-socialmediamentions-count" href="http://www.altmetric.com/details.php?citation_id&#x3D;55612079&amp;domain&#x3D;link.springer.com" target="_blank" rel="noopener"
                       title="Visit Altmetric for full social mention details" id="socialmediamentions-link">
                            <span id="socialmediamentions-count-number" class="test-metric-count c-button-circle gtm-socialmediamentions-count">1</span>
                       <span class="test-metric-name article-metrics__label gtm-socialmediamentions-count">Shares</span>
                    </a>
            </li>
            <li class="article-metrics__item">
                     <span class="article-metrics__views">362</span>
                     <span class="article-metrics__label">Downloads</span>
            </li>
            <li class="article-metrics__item">
                    <a class="article-metrics__link gtm-citations-count" href="https://citations.springer.com/item?doi&#x3D;10.1007/s00446-016-0272-0" target="_blank" rel="noopener"
                       title="Visit Springer Citations for full citation details" id="citations-link">
                            <span id="citations-count-number" class="test-metric-count c-button-circle gtm-citations-count">5</span>
                       <span class="test-metric-name article-metrics__label gtm-citations-count">Citations</span>
                    </a>
            </li>
    </ul>
</div></div></div><section class="Abstract" id="Abs1" tabindex="-1" lang="en"><h2 class="Heading">Abstract</h2><p id="Par1" class="Para">Most concurrent data structures being designed today are versions of known sequential data structures. However, in various cases it makes sense to relax the semantics of traditional concurrent data structures in order to get simpler and possibly more efficient and scalable implementations. For example, when solving the classical producer-consumer problem by implementing a concurrent queue, it might be enough to allow the <em class="EmphasisTypeItalic ">dequeue</em> operation (by a consumer) to return and remove one of the two oldest values in the queue, and not necessarily the oldest one. We define infinitely many possible relaxations of several traditional data structures and objects: queues, stacks, multisets and registers, and examine their relative computational power.</p></section><div class="KeywordGroup" lang="en"><h2 class="Heading">Keywords</h2><span class="Keyword">Relaxed data structure¬†</span><span class="Keyword">Consensus number¬†</span><span class="Keyword">Synchronization¬†</span><span class="Keyword">Wait-freedom¬†</span><span class="Keyword">Queue¬†</span><span class="Keyword">Stack¬†</span><span class="Keyword">Multiset¬†</span><span class="Keyword"><em class="EmphasisTypeItalic ">k</em>-register¬†</span></div><div class="HeaderArticleNotes"><aside class="ArticleNote ArticleNoteMisc"><p class="SimplePara">A preliminary version of the results presented in this paper appeared in: (1) the Proceedings of the 22nd International Colloquium on Structural Information and Communication Complexity (SIROCCO 2015) [<span class="CitationRef"><a href="#CR28">28</a></span>], and (2) the Proceedings of the 14th International Conference on Distributed Computing and Networking (ICDCN 2013) [<span class="CitationRef"><a href="#CR31">31</a></span>].</p></aside></div><div class="note test-pdf-link" id="cobranding-and-download-availability-text"><div>Access to this content is enabled by <strong>Sapienza Universit√† di Roma</strong></div></div><div class="article-actions--inline" id="article-actions--inline" data-component="article-actions--inline"></div><div id="body"><section id="Sec1" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">1 </span>Introduction</h2><div class="content"><section id="Sec2" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">1.1 </span>Motivation</h3><p id="Par2" class="Para">Early in our computer science education, we learn how to implement sequential data structures. In the context of sequential data structures, implementing a queue in which it is fine for a dequeue operation to return one of the two oldest items in the queue, instead of always returning the oldest item, does not help in making the problem of efficiently implementing a queue easier to solve. Maybe for that reason, we sometimes tend to overlook the fact that in the context of concurrent programming, such relaxations might help a lot.</p><p id="Par3" class="Para">Assume that you need to solve the classical producer-consumer synchronization problem by implementing a concurrent queue. In some cases, it might be fine to allow the consumer to return and remove one of the two oldest items in the queue, and not necessarily the oldest one as is usually required. More generally, in some cases it makes senses to relax the semantics of traditional concurrent data structures in order to get more efficient and scalable concurrent implementations.</p><p id="Par4" class="Para">There is a trade-off between synchronization and the ability of an implementation to scale performance with the number of processors. Amdahl‚Äôs law, implies that even a small fraction of inherently sequential code limits scaling. Using semantically weaker data structures may help in reducing the synchronization requirements and hence improves scalability for many-core systems. As a result, there is a recent trend towards implementing semantically weaker data structures for achieving better performance and scalability [<span class="CitationRef"><a href="#CR27">27</a></span>].</p><p id="Par5" class="Para">Important research has already been done on implementing semantically weaker data structure (see for example, [<span class="CitationRef"><a href="#CR2">2</a></span>, <span class="CitationRef"><a href="#CR3">3</a></span>, <span class="CitationRef"><a href="#CR8">8</a></span>, <span class="CitationRef"><a href="#CR16">16</a></span>, <span class="CitationRef"><a href="#CR27">27</a></span>, <span class="CitationRef"><a href="#CR29">29</a></span>]). While these implementations address complexity issues, less research has been done on the computability of relaxed data structures. In this paper we investigate the computability of (wait-free) relaxed data structures, by considering infinitely many possible relaxations of several traditional data structures and objects: queues, stacks, multisets (i.e., bags) and registers, and examine their relative computational power. Our results demonstrate, for example, that for a concurrent queue small changes in its semantics dramatically effects its computational power, and that similar results do not apply for a concurrent stack.</p></section><section id="Sec3" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">1.2 </span>Data structures with relaxed specifications</h3><p id="Par6" class="Para">We will assume that processes can try to access a shared object at the same time, however, although operations of concurrent processes may overlap, each operation should appear to take effect instantaneously. In particular, operations that do not overlap should take effect in their ‚Äúreal-time‚Äù order. This type of correctness requirement for shared objects is called <em class="EmphasisTypeItalic ">linearizability</em>¬†[<span class="CitationRef"><a href="#CR14">14</a></span>].</p><p id="Par7" class="Para">A concurrent queue is a linearizable data structure that supports <em class="EmphasisTypeItalic ">enqueue</em>, <em class="EmphasisTypeItalic ">dequeue</em> and <em class="EmphasisTypeItalic ">peek</em> operations, by several processes, with the usual queue semantics.<sup><a href="#Fn1" id="Fn1_source">1</a></sup> Below we generalize this traditional notion of a concurrent queue.</p><p id="Par9" class="Para">A concurrent queue w.r.t. the numbers <em class="EmphasisTypeItalic ">a</em>, <em class="EmphasisTypeItalic ">b</em> and <em class="EmphasisTypeItalic ">c</em>, denoted <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†<em class="EmphasisTypeItalic ">b</em>,¬†<em class="EmphasisTypeItalic ">c</em>], is a linearizable data structure that supports the <em class="EmphasisTypeItalic ">enq</em>.<em class="EmphasisTypeItalic ">a</em>(<em class="EmphasisTypeItalic ">v</em>), <em class="EmphasisTypeItalic ">deq</em>.<em class="EmphasisTypeItalic ">b</em>() and <em class="EmphasisTypeItalic ">peek</em>.<em class="EmphasisTypeItalic ">c</em>() operations, by several processes, with the following semantics: The <em class="EmphasisTypeItalic ">enq</em>.<em class="EmphasisTypeItalic ">a</em>(<em class="EmphasisTypeItalic ">v</em>) operation inserts the value <em class="EmphasisTypeItalic ">v</em> at one of the <em class="EmphasisTypeItalic ">a</em> positions at the end of the queue;<sup><a href="#Fn2" id="Fn2_source">2</a></sup> the <em class="EmphasisTypeItalic ">deq</em>.<em class="EmphasisTypeItalic ">b</em>() operation returns and removes one of the values at the <em class="EmphasisTypeItalic ">b</em> positions at the front of the queue; the <em class="EmphasisTypeItalic ">peek</em>.<em class="EmphasisTypeItalic ">c</em>() operation returns one of the values at the <em class="EmphasisTypeItalic ">c</em> positions at the front of the queue without removing it. If the queue is empty the <em class="EmphasisTypeItalic ">deq</em>.<em class="EmphasisTypeItalic ">b</em>() and the <em class="EmphasisTypeItalic ">peek</em>.<em class="EmphasisTypeItalic ">c</em>() operations return a special symbol. We emphasize that the queue <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†<em class="EmphasisTypeItalic ">b</em>,¬†<em class="EmphasisTypeItalic ">c</em>], is implemented w.r.t. some fixed numbers <em class="EmphasisTypeItalic ">a</em>, <em class="EmphasisTypeItalic ">b</em> and <em class="EmphasisTypeItalic ">c</em>; these number are defined a priori and are <em class="EmphasisTypeItalic ">not</em> parameters that are passed at run time.</p><p id="Par11" class="Para">When defining the queue <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†<em class="EmphasisTypeItalic ">b</em>,¬†<em class="EmphasisTypeItalic ">c</em>], the numbers <em class="EmphasisTypeItalic ">a</em>, <em class="EmphasisTypeItalic ">b</em> and <em class="EmphasisTypeItalic ">c</em> can take the values of any positive integer, and the two special values 0 and <span class="InlineEquation" id="IEq1">\(*\)</span>. When <em class="EmphasisTypeItalic ">a</em>, <em class="EmphasisTypeItalic ">b</em> or <em class="EmphasisTypeItalic ">c</em> equals 0, it means that the corresponding operation is not supported; when it equals <span class="InlineEquation" id="IEq2">\(*\)</span>, it means that the corresponding operation can insert, remove or return (depending on the type of operation) a value at an arbitrary position (i.e., a position chosen by an adversary).</p><p id="Par12" class="Para">Thus, <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†1] is the traditional FIFO queue (which is sometimes called augmented queue), where the values are dequeued in the order in which they were enqueued, and where the <em class="EmphasisTypeItalic ">peek</em> operation reads the oldest value in the queue without removing it; <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†0] is a queue which supports the standard <em class="EmphasisTypeItalic ">enqueue</em> and <em class="EmphasisTypeItalic ">dequeue</em> operations but does not support a <em class="EmphasisTypeItalic ">peek</em> operation; <span class="InlineEquation" id="IEq3">\(queue[1,1,*]\)</span> is a queue where the <em class="EmphasisTypeItalic ">peek</em> operation returns an arbitrary value that is currently in the queue; finally <span class="InlineEquation" id="IEq4">\(queue[*,*,0]\)</span> is exactly a linearizable <em class="EmphasisTypeItalic ">multiset</em> object that supports <em class="EmphasisTypeItalic ">insert</em> and <em class="EmphasisTypeItalic ">remove</em> operations, by several processes, with the usual multiset semantics.</p><p id="Par13" class="Para">Relaxed versions of other data structures are defined similarly. A relaxed concurrent stack, denoted <em class="EmphasisTypeItalic ">stack</em>[<em class="EmphasisTypeItalic ">a</em>,¬†<em class="EmphasisTypeItalic ">b</em>,¬†<em class="EmphasisTypeItalic ">c</em>], is a linearizable data structure that supports the <em class="EmphasisTypeItalic ">push</em>.<em class="EmphasisTypeItalic ">a</em>(<em class="EmphasisTypeItalic ">v</em>), <em class="EmphasisTypeItalic ">pop</em>.<em class="EmphasisTypeItalic ">b</em>() and <em class="EmphasisTypeItalic ">top</em>.<em class="EmphasisTypeItalic ">c</em>() operations, by several processes, with the obvious semantics. The object <span class="InlineEquation" id="IEq5">\(stack[*,*,0]\)</span> is equivalent to the object <span class="InlineEquation" id="IEq6">\(queue[*,*,0]\)</span> and corresponds to a <em class="EmphasisTypeItalic ">multiset</em> object. The object <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†1] is exactly an <em class="EmphasisTypeItalic ">atomic read/write register</em>, where the push and top operations correspond to the write and read operations, respectively. For <span class="InlineEquation" id="IEq7">\(k\ge 1\)</span>, the object <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†<em class="EmphasisTypeItalic ">k</em>] is exactly a <em class="EmphasisTypeItalic ">k</em>-atomic register as defined in Sect. <span class="InternalRef"><a href="#Sec15">8</a></span>.</p></section><section id="Sec4" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">1.3 </span>Consensus numbers</h3><p id="Par14" class="Para">A process executes correctly its algorithm until it possibly crashes. After it has crashed it executes no more steps. A process that crashes is said to be <em class="EmphasisTypeItalic ">faulty</em>, otherwise it is <em class="EmphasisTypeItalic ">non-faulty</em> (i.e., <em class="EmphasisTypeItalic ">correct</em>).</p><p id="Par15" class="Para">The (binary) consensus problem is to design an algorithm in which all non-faulty processes reach a common decision based on their initial opinions. The problem is defined as follows: There are <em class="EmphasisTypeItalic ">n</em> processes <span class="InlineEquation" id="IEq8">\(p_1,p_2,\ldots ,p_n\)</span>. Each process <span class="InlineEquation" id="IEq9">\(p_i\)</span> has an input value <span class="InlineEquation" id="IEq10">\(x_i \in \{0,1\}\)</span>. The requirements of the consensus problem are that there exists a <em class="EmphasisTypeItalic ">decision value</em> <em class="EmphasisTypeItalic ">v</em> such that: (1) each non-faulty process eventually decides on <em class="EmphasisTypeItalic ">v</em>, and (2) <span class="InlineEquation" id="IEq11">\(v \in \{ x_1, x_2, \ldots , x_n \}\)</span>. In particular, if all input values are the same, then that value must be the decision value.</p><p id="Par16" class="Para">The notion of a consensus number is central to our investigation and is formally defined below. A <em class="EmphasisTypeItalic ">wait-free</em> implementation of an object guarantees that any process can complete any operation in a finite number of steps, regardless of the speed of the other processes. A <em class="EmphasisTypeItalic ">register</em> is an object that supports read and write operations. A register can be atomic or non-atomic. With an <em class="EmphasisTypeItalic ">atomic</em> register, it is assumed that operations on the register (i.e, on the same memory location) occur in some definite order. That is, reading or writing an atomic register is an indivisible action. When reading or writing a non-atomic register (also called <em class="EmphasisTypeItalic ">safe</em> register), a process may be reading a register while another is writing into it, and in that event, the value returned to the reader is arbitrary.</p><p id="Par17" class="Para">The <em class="EmphasisTypeItalic ">consensus number</em> of an object of type <em class="EmphasisTypeItalic ">o</em>, denoted <em class="EmphasisTypeItalic ">CN</em>(<em class="EmphasisTypeItalic ">o</em>), is the largest <em class="EmphasisTypeItalic ">n</em> for which it is possible to solve consensus for <em class="EmphasisTypeItalic ">n</em> processes in a wait-free manner using any number of objects of type <em class="EmphasisTypeItalic ">o</em> and any number of atomic registers. If no largest <em class="EmphasisTypeItalic ">n</em> exists, the consensus number of <em class="EmphasisTypeItalic ">o</em> is infinite (denoted <span class="InlineEquation" id="IEq12">\(\infty \)</span>) [<span class="CitationRef"><a href="#CR11">11</a></span>]. Classifying objects by their consensus numbers is a powerful technique for understanding the relative computational power of shared objects.</p><p id="Par18" class="Para">The <em class="EmphasisTypeItalic ">consensus hierarchy</em> is an infinite hierarchy of objects such that the objects at level <em class="EmphasisTypeItalic ">i</em> of the hierarchy are exactly those objects with consensus number <em class="EmphasisTypeItalic ">i</em>. It is known that, in the consensus hierarchy, for every positive <em class="EmphasisTypeItalic ">i</em>, in a system with <em class="EmphasisTypeItalic ">i</em> processes: (1) no object at level less than <em class="EmphasisTypeItalic ">i</em> together with atomic registers can implement any object at level <em class="EmphasisTypeItalic ">i</em>; and (2) each object at level <em class="EmphasisTypeItalic ">i</em> together with atomic registers can implement any object at level <em class="EmphasisTypeItalic ">i</em> or at a lower level [<span class="CitationRef"><a href="#CR11">11</a></span>].</p></section><section id="Sec5" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">1.4 </span>Contributions</h3><p id="Par19" class="Para"> <em class="EmphasisTypeItalic ">New definitions</em> The definitions of concurrent queues and stacks with relaxed specifications together with the following technical results provide a deeper understanding of the computability issues which are involved in the development of relaxed data structures.</p><div id="Par20" class="Para"> <em class="EmphasisTypeItalic ">Relaxing the enqueue operation</em> First we show that, while <span class="InlineEquation" id="IEq13">\(CN(queue[1,1,1]) = \infty \)</span>, the consensus number drops to <em class="EmphasisTypeItalic ">two</em> when the <em class="EmphasisTypeItalic ">enqueue</em> operation is allowed to insert an item at any position at random, regardless whether the <em class="EmphasisTypeItalic ">peek</em> and <em class="EmphasisTypeItalic ">dequeue</em> operations are relaxed or not. That is,<div id="Equ1" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned} CN(queue[*,1,1]) = 2. \end{aligned}$$</div> <div class="EquationNumber">(R1)</div></div>It follows from R1 and the known result that <span class="InlineEquation" id="IEq14">\(CN(queue[*,*,0]) = 2\)</span> (i.e., that the consensus number of a <em class="EmphasisTypeItalic ">multiset</em> object is 2), that: for every <span class="InlineEquation" id="IEq15">\(b\in Z^+\cup \{*\}, c\in Z^+\cup \{0,*\}\)</span> <span class="InlineEquation" id="IEq16">\(: CN(queue[*,b,c]) = 2\)</span>. (<span class="InlineEquation" id="IEq17">\(Z^+\)</span> is the set of all positive integers.) Next, we show that the consensus number of all the queues in which the <em class="EmphasisTypeItalic ">peek</em> operation is not relaxed (i.e., peek always returns the element at the front of the queue) is <em class="EmphasisTypeItalic ">infinity</em>, even when the <em class="EmphasisTypeItalic ">enqueue</em> operation is allowed to insert an item at any one of the last <em class="EmphasisTypeItalic ">k</em> positions for any fixed <em class="EmphasisTypeItalic ">k</em>. That is,<div id="Equ2" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned} \hbox {For every }a\in Z^+\;:\;CN(queue[a,0,1]) = \infty \end{aligned}$$</div> <div class="EquationNumber">(R2)</div></div>In contrast with R2, the consensus numbers of <em class="EmphasisTypeItalic ">all</em> possible relaxations of a concurrent <em class="EmphasisTypeItalic ">stack</em> are at most 2. In particular, <span class="InlineEquation" id="IEq18">\(CN(stack[1,1,1])=2\)</span> and <span class="InlineEquation" id="IEq19">\(CN(stack[1,0,1]) = 1\)</span> [<span class="CitationRef"><a href="#CR7">7</a></span>, <span class="CitationRef"><a href="#CR11">11</a></span>, <span class="CitationRef"><a href="#CR21">21</a></span>] (as already mentioned, the object <em class="EmphasisTypeItalic ">stack</em> [1,¬†0,¬†1] is exactly an atomic read/write register).</div><div id="Par21" class="Para"> <em class="EmphasisTypeItalic ">Relaxing the peek operation</em> Next, we show that the consensus number of all the queues in which the <em class="EmphasisTypeItalic ">peek</em> operation is relaxed (i.e., peek is not required to always return the oldest value in the queue), is exactly two, regardless of how far the <em class="EmphasisTypeItalic ">enqueue</em> and <em class="EmphasisTypeItalic ">dequeue</em> operations are relaxed, as long as these operations are supported. That is,<div id="Equ3" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned} CN(queue[1,1,2]) = 2. \end{aligned}$$</div> <div class="EquationNumber">(R3)</div></div>It follows from R3 and the known result that the consensus number of a <em class="EmphasisTypeItalic ">multiset</em> object is 2 [<span class="CitationRef"><a href="#CR15">15</a></span>], that: for every <span class="InlineEquation" id="IEq20">\(a\in Z^+\cup \{*\}\)</span>, <span class="InlineEquation" id="IEq21">\(b\in Z^+\cup \{*\}\)</span>, <span class="InlineEquation" id="IEq22">\(c\ne 1\,: \;CN(queue[a,b,c]) = 2\)</span>.</div><div id="Par22" class="Para"> <em class="EmphasisTypeItalic ">Not supporting the dequeue operation</em> The situation changes dramatically when dequeue is not supported. The consensus number of all the queues where the dequeue operation is not supported <em class="EmphasisTypeItalic ">and</em> the peek operation is slightly relaxed, is just 1. That is,<div id="Equ4" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned} CN(queue[1,0,2]) = 1. \end{aligned}$$</div> <div class="EquationNumber">(R4)</div></div>Thus, while <span class="InlineEquation" id="IEq23">\(CN(queue[1,0,1]) = \infty \)</span> and <span class="InlineEquation" id="IEq24">\(CN(queue[1,1,2]) = 2\)</span>, by removing the dequeue operation from the object <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2], we get an object with consensus number one. It follows from R4 that: for every <span class="InlineEquation" id="IEq25">\(a\in Z^+\cup \{0, *\}: CN(queue[a,0,2]) = 1\)</span>.</div><div id="Par23" class="Para"> <em class="EmphasisTypeItalic ">Atomic registers versus relaxed queues</em> It is known that <span class="InlineEquation" id="IEq26">\(CN( atomic~register ) = 1\)</span> [<span class="CitationRef"><a href="#CR21">21</a></span>]. It is easy to see that a <span class="InlineEquation" id="IEq27">\(queue[*,0,2]\)</span> has a trivial wait-free implementation from a single atomic register. While, for every <span class="InlineEquation" id="IEq28">\(a\in Z^+\)</span>, atomic registers and <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†0,¬†2] both have consensus number 1, we observe that,<div id="Equ5" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned}&amp;\hbox {A}\; queue[a,0,c]\; \hbox {has no wait-free}\\&amp;\hbox {implementation from atomic registers,}\\&amp;\hbox {for every two positive integers}\; a\; \hbox {and}\; c. \end{aligned}$$</div> <div class="EquationNumber">(R5)</div></div>All the above results hold for both an initialized queue and an uninitialized queue. These cases differ, for example, when the enqueue operation is not supported. For an initialized queue, <span class="InlineEquation" id="IEq29">\(CN(queue[0,1,0]) = 2\)</span> [<span class="CitationRef"><a href="#CR11">11</a></span>], while for an uninitialized queue, it is obvious that <span class="InlineEquation" id="IEq30">\(CN(queue[0,1,1]) = 1\)</span>.</div><div id="Par24" class="Para"> <em class="EmphasisTypeItalic ">Relaxed registers</em> It is common to assume that operations on the same memory location are atomic ‚Äì they occur in some definite order. However, this assumption can be relaxed allowing the possibility of concurrent operation on the same memory location. In [<span class="CitationRef"><a href="#CR20">20</a></span>], three classes of shared registers are defined, which support read and write operations, called‚Äîsafe, regular and atomic‚Äîdepending on their properties when several reads and/or writes are executed concurrently. We consider relaxations of these notions, called <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular and <em class="EmphasisTypeItalic ">k</em>-atomic, and prove that,<div id="Equ6" class="Equation EquationMathjax"><div class="EquationContent">$$\begin{aligned}&amp;\hbox {It is possible to wait-free implement}\\&amp;\hbox {multi-writer multi-reader multi-valued}\\&amp;\hbox {1-atomic registers (the strongest type) using single-}\\&amp;\hbox {writer single-reader}\,k\hbox {-safe bits (the weakest type)},\\&amp;\hbox {for every}\,k\ge 1. \end{aligned}$$</div> <div class="EquationNumber">(R6)</div></div>Thus, for every <span class="InlineEquation" id="IEq31">\(k\ge 1\)</span>, <em class="EmphasisTypeItalic ">k</em>-safe registers and 1-atomic registers have the same computational power.</div></section></div></section><section id="Sec6" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">2 </span>Preliminaries</h2><div class="content"><section id="Sec7" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.1 </span>Model of computation</h3><p id="Par25" class="Para">Our model of computation consists of an asynchronous collection of <span class="InlineEquation" id="IEq32">\(n\ge 2\)</span> processes that communicate via shared objects. We use <em class="EmphasisTypeItalic ">P</em> to denote the set of all processes. Asynchrony means that there is no assumption on the relative speeds of the processes. Processes may fail by crashing, which means that a failed process stops taking steps forever. In an asynchronous system there is no way to distinguish between a faulty and a very slow process.</p><p id="Par26" class="Para">An <em class="EmphasisTypeItalic ">event</em> corresponds to an atomic step performed by a process. For example, the events which correspond to accessing registers are classified into two types: read events which may not change the state of the register, and write events which update the state of a register but do not return a value. We use the notation <span class="InlineEquation" id="IEq33">\(e_p\)</span> to denote an instance of an arbitrary event at a process¬†<em class="EmphasisTypeItalic ">p</em>.</p><p id="Par27" class="Para">A <em class="EmphasisTypeItalic ">run</em> is a pair <span class="InlineEquation" id="IEq34">\((f,\,R)\)</span> where <em class="EmphasisTypeItalic ">f</em> is a function that assigns initial states (values) to the objects and <em class="EmphasisTypeItalic ">R</em> is a finite or infinite sequence of events. An implementation of an object from a set of other objects, consists of a non-empty set <em class="EmphasisTypeItalic ">C</em> of runs, a set <em class="EmphasisTypeItalic ">P</em> of processes, and a set of shared objects <em class="EmphasisTypeItalic ">O</em>. For any event <span class="InlineEquation" id="IEq35">\(e_p\)</span> at a process <em class="EmphasisTypeItalic ">p</em> in any run in <em class="EmphasisTypeItalic ">C</em>, the object accessed in <span class="InlineEquation" id="IEq36">\(e_p\)</span> must be in <em class="EmphasisTypeItalic ">O</em>. Let <span class="InlineEquation" id="IEq37">\(x=(f,\,R)\)</span> and <span class="InlineEquation" id="IEq38">\(x' =(f',\,R')\)</span> be runs. Run <span class="InlineEquation" id="IEq39">\(x'\)</span> is a <em class="EmphasisTypeItalic ">prefix</em> of <em class="EmphasisTypeItalic ">x</em> (and <em class="EmphasisTypeItalic ">x</em> is an <em class="EmphasisTypeItalic ">extension</em> of <span class="InlineEquation" id="IEq40">\(x'\)</span>), denoted <span class="InlineEquation" id="IEq41">\(x' \le x\)</span>, if <span class="InlineEquation" id="IEq42">\(R'\)</span> is a prefix of <em class="EmphasisTypeItalic ">R</em> and <span class="InlineEquation" id="IEq43">\(f=f'\)</span>. When <span class="InlineEquation" id="IEq44">\({x'} \le x\)</span>, <span class="InlineEquation" id="IEq45">\((x-{x'})\)</span> denotes the suffix of <em class="EmphasisTypeItalic ">R</em> obtained by removing <span class="InlineEquation" id="IEq46">\(R'\)</span> from <em class="EmphasisTypeItalic ">R</em>. Let <em class="EmphasisTypeItalic ">R</em>;¬†<em class="EmphasisTypeItalic ">T</em> be the sequence obtained by concatenating the finite sequence <em class="EmphasisTypeItalic ">R</em> and the sequence <em class="EmphasisTypeItalic ">T</em>. Then <em class="EmphasisTypeItalic ">x</em> ;¬†<em class="EmphasisTypeItalic ">T</em> is an abbreviation for ( <em class="EmphasisTypeItalic ">f</em>,¬†¬† <em class="EmphasisTypeItalic ">R</em>;¬†<em class="EmphasisTypeItalic ">T</em> ).</p><p id="Par28" class="Para">Process <em class="EmphasisTypeItalic ">p</em> is <em class="EmphasisTypeItalic ">enabled</em> at the end of run <em class="EmphasisTypeItalic ">x</em> if there exists an event <span class="InlineEquation" id="IEq47">\(e_p\)</span> such that <span class="InlineEquation" id="IEq48">\(x; e_p\)</span> is a run. For simplicity, whenever we say that <em class="EmphasisTypeItalic ">p</em> is enabled at <em class="EmphasisTypeItalic ">x</em> we mean that <em class="EmphasisTypeItalic ">p</em> is enabled at <em class="EmphasisTypeItalic ">the end</em> of <em class="EmphasisTypeItalic ">x</em>. Also, we write <em class="EmphasisTypeItalic ">xp</em> to denote either <span class="InlineEquation" id="IEq49">\(x;e_p\)</span> when <em class="EmphasisTypeItalic ">p</em> is enabled in <em class="EmphasisTypeItalic ">x</em>, or <em class="EmphasisTypeItalic ">x</em> when <em class="EmphasisTypeItalic ">p</em> is not enabled in¬†<em class="EmphasisTypeItalic ">x</em>. Register <em class="EmphasisTypeItalic ">r</em> is a <em class="EmphasisTypeItalic ">local</em> register of <em class="EmphasisTypeItalic ">p</em> if only <em class="EmphasisTypeItalic ">p</em> can access <em class="EmphasisTypeItalic ">r</em>. For any sequence <em class="EmphasisTypeItalic ">R</em>, let <span class="InlineEquation" id="IEq50">\(R_p\)</span> be the subsequence of <em class="EmphasisTypeItalic ">R</em> containing all events in <em class="EmphasisTypeItalic ">R</em> which involve <em class="EmphasisTypeItalic ">p</em>. Runs <span class="InlineEquation" id="IEq51">\((f,\,R)\)</span> and <span class="InlineEquation" id="IEq52">\((f',\,R')\)</span> are <em class="EmphasisTypeItalic ">indistinguishable</em> for <em class="EmphasisTypeItalic ">p</em>, denoted by <span class="InlineEquation" id="IEq53">\((f,\,R)[p](f',\,R')\)</span>, iff <span class="InlineEquation" id="IEq54">\(R_{p} = R'_{p}\)</span> and <span class="InlineEquation" id="IEq55">\(f(r)=f'(r)\)</span> for every local register <em class="EmphasisTypeItalic ">r</em> of <em class="EmphasisTypeItalic ">p</em>.</p><p id="Par29" class="Para">The runs of an asynchronous implementation of an object must satisfy several properties. For example, if a <em class="EmphasisTypeItalic ">write</em> event which involves <em class="EmphasisTypeItalic ">p</em> is enabled at run <em class="EmphasisTypeItalic ">x</em>, then the same event is enabled at any finite run that is indistinguishable to <em class="EmphasisTypeItalic ">p</em> from <em class="EmphasisTypeItalic ">x</em>. In the following proofs, we will implicitly make use of few such straightforward properties.</p></section><section id="Sec8" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.2 </span>Three simple observations</h3><p id="Par30" class="Para">The following lemmas are easy consequences of the above properties and definitions.</p><div id="FPar1" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 1</strong> </span></h3><p id="Par31" class="Para">Let <em class="EmphasisTypeItalic ">w</em>, <em class="EmphasisTypeItalic ">x</em> and <em class="EmphasisTypeItalic ">y</em> be runs of an algorithm and <em class="EmphasisTypeItalic ">p</em> be a process such that (1) <span class="InlineEquation" id="IEq56">\(w\le x\)</span> and <em class="EmphasisTypeItalic ">w</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">y</em>, and (2) the states of all the objects (local and shared) that <em class="EmphasisTypeItalic ">p</em> can access are the same in <em class="EmphasisTypeItalic ">w</em> and <em class="EmphasisTypeItalic ">y</em>, and <span class="InlineEquation" id="IEq57">\((x-w)\)</span> contains only events of <em class="EmphasisTypeItalic ">p</em>. Then, <span class="InlineEquation" id="IEq58">\(z = y;(x-w)\)</span> is a run of the algorithm and <em class="EmphasisTypeItalic ">x</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">z</em>.</p></div><div id="FPar2" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par32" class="Para">By induction on the length of <span class="InlineEquation" id="IEq59">\((x-w)\)</span>. <span class="InlineEquation" id="IEq60">\(\square \)</span> </p></div><p id="Par33" class="Para">Next, we state two simple lemmas regarding relaxed queues. The first states that in any component, going from <span class="InlineEquation" id="IEq61">\(a\in Z^+\)</span> to <span class="InlineEquation" id="IEq62">\(a+1\)</span> or to <span class="InlineEquation" id="IEq63">\(*\)</span> does not increase the power of the object since it just gives the adversary more choices of what to return. The second lemma states that going from <span class="InlineEquation" id="IEq64">\(a \in Z^+\cup \{0,*\}\)</span> to 0 in any component does not increase the power of the object, since it just eliminates a possible operation.</p><div id="FPar3" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 2</strong> </span></h3><p id="Par34" class="Para">For every <span class="InlineEquation" id="IEq65">\(a_1,b_1,c_1,a_2,b_2,c_2\)</span> in <span class="InlineEquation" id="IEq66">\(Z^+\cup \{0,*\}\)</span>, if <span class="InlineEquation" id="IEq67">\(((a_2=*\wedge a_1\ne 0) \vee 0&lt;a_1\le a_2 \vee a_2=0) \wedge ((b_2=*\wedge b_1\ne 0)\)</span> <span class="InlineEquation" id="IEq68">\(\vee 0&lt;b_1\le b_2 \vee b_2=0) \wedge ((c_2=*\wedge c_1\ne 0) \vee 0&lt;c_1\le c_2 \vee c_2=0)\)</span> </p><p id="Par35" class="Para">then <span class="InlineEquation" id="IEq69">\(CN(queue[a_1,b_1,c_1]) \ge CN(queue[a_2,b_2,c_2])\)</span>.</p></div><div id="FPar4" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par36" class="Para">The proof of the lemma follows immediately from the definitions. <span class="InlineEquation" id="IEq70">\(\square \)</span> </p></div><div id="FPar5" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 3</strong> </span></h3><div id="Par37" class="Para">For every <em class="EmphasisTypeItalic ">a</em>,¬†<em class="EmphasisTypeItalic ">b</em>,¬†<em class="EmphasisTypeItalic ">c</em> in <span class="InlineEquation" id="IEq71">\(Z^+\cup \{0,*\}\)</span>,<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"> <p id="Par38" class="Para"> <span class="InlineEquation" id="IEq72">\(CN(queue[0,b,c]) \le CN(queue[a,b,c])\)</span>, and</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"> <p id="Par39" class="Para"> <span class="InlineEquation" id="IEq73">\(CN(queue[a,0,c]) \le CN(queue[a,b,c])\)</span>, and</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"> <p id="Par40" class="Para"> <span class="InlineEquation" id="IEq74">\(CN(queue[a,b,0]) \le CN(queue[a,b,c])\)</span>.</p> </div><div class="ClearBoth">¬†</div></li></ol></div> </div></div><div id="FPar6" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par41" class="Para">The proof of the lemma follows immediately from the definitions. <span class="InlineEquation" id="IEq75">\(\square \)</span> </p></div><p id="Par42" class="Para">We notice that the statement of Lemma <span class="InternalRef"><a href="#FPar3">2</a></span> subsumes that of Lemma <span class="InternalRef"><a href="#FPar5">3</a></span>, since it covers the case of <span class="InlineEquation" id="IEq76">\(a_2\)</span>, <span class="InlineEquation" id="IEq77">\(b_2\)</span> or <span class="InlineEquation" id="IEq78">\(c_2\)</span> being 0.</p></section><section id="Sec9" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">2.3 </span>Known results</h3><div id="FPar7" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 4</strong> </span></h3><div id="Par43" class="Para"> <div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">(a)</span><div class="ItemContent"> <p id="Par44" class="Para"> <span class="InlineEquation" id="IEq79">\(CN(queue[*,*,0]) = 2\)</span>,</p> </div><div class="ClearBoth">¬†</div></li></ol></div> <div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">(b)</span><div class="ItemContent"> <p id="Par45" class="Para"> <span class="InlineEquation" id="IEq80">\(CN(queue[1,1,0]) = 2\)</span>, and</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">(c)</span><div class="ItemContent"> <p id="Par46" class="Para"> <span class="InlineEquation" id="IEq81">\(CN(stack[1,1,1]) = 2\)</span>.</p> </div><div class="ClearBoth">¬†</div></li></ol></div> </div></div><p id="Par47" class="Para">The proofs that <span class="InlineEquation" id="IEq82">\(CN(queue[*,*,0]) = 2\)</span>, <span class="InlineEquation" id="IEq83">\(CN(queue[1,1,0]) = 2\)</span>, and <span class="InlineEquation" id="IEq84">\(CN(stack[1,1,0]) = 2\)</span> (with and without initialization) are from [<span class="CitationRef"><a href="#CR11">11</a></span>, <span class="CitationRef"><a href="#CR15">15</a></span>]. The wait-free consensus algorithm which uses a single queue and registers from [<span class="CitationRef"><a href="#CR15">15</a></span>], is also correct when the queue is replaced with a stack or with a multiset. Proving that <span class="InlineEquation" id="IEq85">\(CN(stack[1,1,1]) = 2\)</span>, can be establish by modifying the existing proof from [<span class="CitationRef"><a href="#CR11">11</a></span>], that <span class="InlineEquation" id="IEq86">\(CN(queue[1,1,0]) = 2\)</span>.<sup><a href="#Fn3" id="Fn3_source">3</a></sup> </p></section></div></section><section id="Sec10" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">3 </span>Basic properties of wait-free consensus algorithms</h2><div class="content"><p id="Par49" class="Para">The first four lemmas below are known and have appeared (using different notations) or follow from known impossibility proofs for wait-free consensus. The definitions below refer to runs of a given consensus algorithm. A (finite) run <em class="EmphasisTypeItalic ">x</em> is <em class="EmphasisTypeItalic ">v</em>-<em class="EmphasisTypeItalic ">valent</em> if in all extensions of <em class="EmphasisTypeItalic ">x</em> where a decision is made, the decision value is <em class="EmphasisTypeItalic ">v</em> (<span class="InlineEquation" id="IEq88">\(v\in \{ 0,1 \}\)</span>). A run is <em class="EmphasisTypeItalic ">univalent</em> if it is either 0-valent or 1-valent, otherwise it is <em class="EmphasisTypeItalic ">bivalent</em>. We say that two univalent runs are <em class="EmphasisTypeItalic ">compatible</em> if they have the same valency, that is, either both runs are 0-valent or both are 1-valent. A run is <em class="EmphasisTypeItalic ">critical</em> if: (1) it is bivalent, and (2) any extension of the run is univalent. A run <span class="InlineEquation" id="IEq89">\((f,\,R)\)</span> is an <em class="EmphasisTypeItalic ">empty</em> run if the length of <em class="EmphasisTypeItalic ">R</em> is 0 (that is, no process has taken a step yet). Recall that <span class="InlineEquation" id="IEq90">\(n\ge 2\)</span>.</p><div id="FPar8" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 5</strong> </span></h3><p id="Par50" class="Para">In every wait-free consensus algorithm, if two univalent runs are indistinguishable for some process <em class="EmphasisTypeItalic ">p</em>, and the states of all the objects that <em class="EmphasisTypeItalic ">p</em> can access are the same at these runs, then these (univalent) runs must be compatible.</p></div><div id="FPar9" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par51" class="Para">Let <em class="EmphasisTypeItalic ">w</em> and <em class="EmphasisTypeItalic ">y</em> be univalent runs, such that <em class="EmphasisTypeItalic ">w</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">y</em> and the states of all the objects (local and shared) that <em class="EmphasisTypeItalic ">p</em> can access are the same at <em class="EmphasisTypeItalic ">w</em> and <em class="EmphasisTypeItalic ">y</em>. By the wait-free property, <em class="EmphasisTypeItalic ">w</em> has an extension <em class="EmphasisTypeItalic ">x</em> such <span class="InlineEquation" id="IEq91">\(x-w\)</span> contains only events of process <em class="EmphasisTypeItalic ">p</em>, and <em class="EmphasisTypeItalic ">p</em> has decided in <em class="EmphasisTypeItalic ">x</em>. Let <em class="EmphasisTypeItalic ">w</em> be <em class="EmphasisTypeItalic ">v</em>-valent, for <span class="InlineEquation" id="IEq92">\(v \in \{0,1\}\)</span>. Then <em class="EmphasisTypeItalic ">p</em> decide <em class="EmphasisTypeItalic ">v</em> in <em class="EmphasisTypeItalic ">x</em>. (The event in which <em class="EmphasisTypeItalic ">p</em> decides on <em class="EmphasisTypeItalic ">v</em>, may be implemented by <em class="EmphasisTypeItalic ">p</em> writing <em class="EmphasisTypeItalic ">v</em> into a special single-writer output register.) By Lemma¬†<span class="InternalRef"><a href="#FPar1">1</a></span>, <span class="InlineEquation" id="IEq93">\(z = y;(x-w)\)</span> is a run of the algorithm such that <em class="EmphasisTypeItalic ">z</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">x</em>. Since <em class="EmphasisTypeItalic ">p</em> decides on <em class="EmphasisTypeItalic ">v</em> (i.e., <em class="EmphasisTypeItalic ">p</em> writes <em class="EmphasisTypeItalic ">v</em> to its output register) in <em class="EmphasisTypeItalic ">z</em>, <em class="EmphasisTypeItalic ">z</em> is <em class="EmphasisTypeItalic ">v</em>-valent. Hence, since <span class="InlineEquation" id="IEq94">\(y\le z\)</span>, <em class="EmphasisTypeItalic ">y</em> must also be <em class="EmphasisTypeItalic ">v</em>-valent. <span class="InlineEquation" id="IEq95">\(\square \)</span> </p></div><div id="FPar10" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 6</strong> </span></h3><p id="Par52" class="Para">Every wait-free consensus algorithm has a bivalent empty run.</p></div><div id="FPar11" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par53" class="Para">We show that a bivalent empty run must exist. Assume to the contrary that every empty run is univalent. The empty run with all 0 inputs must be 0-valent, and similarly the empty run with all 1 inputs must be 1-valent. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, all the empty runs with all but one 0 inputs are 0-valent, and similarly all the empty runs with all but one 1 inputs are 1-valent. By repeatedly applying this argument <em class="EmphasisTypeItalic ">i</em> times we get that, all the empty runs with all but <em class="EmphasisTypeItalic ">i</em> 0 inputs are 0-valent, and similarly all the empty runs with all but <em class="EmphasisTypeItalic ">i</em> 1 inputs are 1-valent. Thus, when <em class="EmphasisTypeItalic ">i</em> is half the number of processes, we get that there are two empty runs <span class="InlineEquation" id="IEq96">\(x_0\)</span> and <span class="InlineEquation" id="IEq97">\(x_1\)</span> that differ only at the value of a single input, for process <em class="EmphasisTypeItalic ">p</em>, such that <span class="InlineEquation" id="IEq98">\(x_0\)</span> is 0-valent and <span class="InlineEquation" id="IEq99">\(x_1\)</span> is 1-valent. However, this contradicts Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>. Hence, an empty bivalent run exists. <span class="InlineEquation" id="IEq100">\(\square \)</span> </p></div><div id="FPar12" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 7</strong> </span></h3><p id="Par54" class="Para">Every wait-free consensus algorithm has a critical run.</p></div><div id="FPar13" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><div id="Par55" class="Para">Let <em class="EmphasisTypeItalic ">Cons</em> be an arbitrary wait-free consensus algorithm. By Lemma <span class="InternalRef"><a href="#FPar10">6</a></span>, <em class="EmphasisTypeItalic ">Cons</em> has an empty bivalent run <span class="InlineEquation" id="IEq101">\(x_0\)</span>. We begin with <span class="InlineEquation" id="IEq102">\(x_0\)</span> and pursue the following round-robin <em class="EmphasisTypeItalic ">bivalence-preserving scheduling</em> discipline (Recall that <em class="EmphasisTypeItalic ">P</em> denotes a set of processes, <em class="EmphasisTypeItalic ">x</em> and <em class="EmphasisTypeItalic ">y</em> denote runs and <em class="EmphasisTypeItalic ">yp</em> is an extension of the run <em class="EmphasisTypeItalic ">y</em> by one event of process <em class="EmphasisTypeItalic ">p</em>): <figure class="Figure" id="Figa"><div class="MediaObject" id="MO7"> <a href="https://media.springernature.com/original/springer-static/image/art%3A10.1007%2Fs00446-016-0272-0/MediaObjects/446_2016_272_Figa_HTML.gif" target="_blank" rel="noopener"><span class="u-screenreader-only">Open image in new window</span><img src="https://media.springernature.com/lw785/springer-static/image/art%3A10.1007%2Fs00446-016-0272-0/MediaObjects/446_2016_272_Figa_HTML.gif" alt="" /></a> </div></figure> </div><p id="Par56" class="Para">If the above procedure does not terminate, then there is an infinite run with only bivalent finite prefixes. However, the existence of such a run contradicts the definition of a wait-free consensus algorithm. Hence, the procedure will terminate with some critical run <em class="EmphasisTypeItalic ">x</em>. <span class="InlineEquation" id="IEq112">\(\square \)</span> </p></div><div id="FPar14" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 8</strong> </span></h3><p id="Par57" class="Para">Let <em class="EmphasisTypeItalic ">x</em> be a critical run of a wait-free consensus algorithm and let <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> be two different processes such that the runs <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xq</em> are not compatible. Then, in their next events from <em class="EmphasisTypeItalic ">x</em>, <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> are accessing the same object, and this object is not a register.</p></div><div id="FPar15" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><div id="Par58" class="Para">We consider the following three possible cases, and show that each one of them leads to a contradiction. We will assume that in the last event in <em class="EmphasisTypeItalic ">xp</em> process <em class="EmphasisTypeItalic ">p</em> is accessing some object, say <em class="EmphasisTypeItalic ">o</em>, and in the last event in <em class="EmphasisTypeItalic ">xq</em> process <em class="EmphasisTypeItalic ">q</em> is accessing some object, say <span class="InlineEquation" id="IEq113">\(o'\)</span>.<div class="UnorderedList"><ul class="UnorderedListMarkNone"><li> <p id="Par59" class="Para"> <em class="EmphasisTypeItalic ">Case 1.</em> <span class="InlineEquation" id="IEq114">\(o\ne o'\)</span> Since the next events from <em class="EmphasisTypeItalic ">x</em> of <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> are independent, <em class="EmphasisTypeItalic ">xpq</em> [<em class="EmphasisTypeItalic ">p</em>] <em class="EmphasisTypeItalic ">xqp</em>, and the values of all objects are the same in both <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em>. Hence, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> are compatible; since <em class="EmphasisTypeItalic ">xpq</em> is an extension of <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em> is an extension of <em class="EmphasisTypeItalic ">xq</em>, it must be that<em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xq</em> are also compatible. A contradiction.</p> </li><li> <p id="Par60" class="Para"> <em class="EmphasisTypeItalic ">Case 2.</em> <span class="InlineEquation" id="IEq115">\(o = o'\)</span> is a register and in <em class="EmphasisTypeItalic ">xp</em> the last event is a <em class="EmphasisTypeItalic ">write</em> event by <em class="EmphasisTypeItalic ">p</em> to <em class="EmphasisTypeItalic ">o</em>. Since <em class="EmphasisTypeItalic ">p</em> <em class="EmphasisTypeItalic ">writes</em> to <em class="EmphasisTypeItalic ">o</em> in its next operation from <em class="EmphasisTypeItalic ">x</em>, the value of <em class="EmphasisTypeItalic ">o</em> must be the same in <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em>. (Here we use the fact that the write by <em class="EmphasisTypeItalic ">p</em> overwrites the possible changes of <em class="EmphasisTypeItalic ">o</em> made by <em class="EmphasisTypeItalic ">q</em>.) Hence, <em class="EmphasisTypeItalic ">xp</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">xqp</em> and the values of all the objects, which are not local to <em class="EmphasisTypeItalic ">q</em>, are the same in <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em>. By Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em> are compatible. Since <em class="EmphasisTypeItalic ">xqp</em> is an extension of <em class="EmphasisTypeItalic ">xq</em>, it must be that <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xq</em> are also compatible. A contradiction.</p> </li><li> <p id="Par61" class="Para"> <em class="EmphasisTypeItalic ">Case 3.</em> <span class="InlineEquation" id="IEq116">\(o = o'\)</span> is a register and in <em class="EmphasisTypeItalic ">xp</em> the last event is a <em class="EmphasisTypeItalic ">read</em> event by <em class="EmphasisTypeItalic ">p</em>. Thus, <em class="EmphasisTypeItalic ">xpq</em> [<em class="EmphasisTypeItalic ">q</em>] <em class="EmphasisTypeItalic ">xq</em>, and the values of all the objects, which are not local to <em class="EmphasisTypeItalic ">p</em>, are the same in both <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xq</em>. Hence by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xq</em> are compatible. Since <em class="EmphasisTypeItalic ">xpq</em> is an extension of <em class="EmphasisTypeItalic ">xp</em>, it must be that <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xq</em> are also compatible. A contradiction.</p> </li></ul></div>Thus, it must be the case that <span class="InlineEquation" id="IEq117">\(o = o'\)</span> and <em class="EmphasisTypeItalic ">o</em> is not a register.</div></div><div id="FPar16" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Lemma 9</strong> </span></h3><p id="Par62" class="Para">Let <em class="EmphasisTypeItalic ">x</em> be a critical run of a wait-free consensus algorithm, and assume that the next event of <em class="EmphasisTypeItalic ">p</em> from <em class="EmphasisTypeItalic ">x</em> is a relaxed peek event which may return one of the two oldest items in a queue. Let <span class="InlineEquation" id="IEq118">\(xp^1\)</span> (resp. <span class="InlineEquation" id="IEq119">\(xp^2\)</span>) denotes an extension of <em class="EmphasisTypeItalic ">x</em> by a peek event by <em class="EmphasisTypeItalic ">p</em> that has returned the oldest (resp. second oldest) item in a queue. Then, <span class="InlineEquation" id="IEq120">\(xp^1\)</span> and <span class="InlineEquation" id="IEq121">\(xp^2\)</span> are compatible.</p></div><div id="FPar17" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par63" class="Para">Let <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> be two different processes. Because the value the peek operation by <em class="EmphasisTypeItalic ">p</em> returns (i.e., the first or second) does not affect the state of the queue object visible to <em class="EmphasisTypeItalic ">q</em>, it follows that <span class="InlineEquation" id="IEq122">\(xp^1[q]xp^2\)</span> and the states of all the objects that <em class="EmphasisTypeItalic ">q</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <span class="InlineEquation" id="IEq123">\(xp^1\)</span> and <span class="InlineEquation" id="IEq124">\(xp^2\)</span> are compatible. <span class="InlineEquation" id="IEq125">\(\square \)</span> </p></div></div></section><section id="Sec11" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">4 </span>Relaxing the enqueue operation</h2><div class="content"><p id="Par64" class="Para">It is obvious that <span class="InlineEquation" id="IEq126">\(CN(queue[1,0,1]) = \infty \)</span>. Each process inserts its input value into the queue using an enqueue operation, and then uses a peek operation to find out what is the value at the front of the queue and decides on it. Also, it is obvious that, for an uninitialized queue, <span class="InlineEquation" id="IEq127">\(CN(queue[0,1,1]) = 1\)</span>.<sup><a href="#Fn4" id="Fn4_source">4</a></sup> That is, a relaxed uninitialized queue where the enqueue operation is not supported is useless. Assume a queue object where only the enqueue operation may be relaxed. We show that only when the enqueue operation can insert a value at an arbitrary position, the consensus number drops to two; otherwise, in all other possible relaxations in which the enqueue operation is supported, the consensus number is not effected (i.e., it is <span class="InlineEquation" id="IEq128">\(\infty \)</span>).</p><div id="FPar18" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 1</strong> </span></h3><p id="Par66" class="Para"> <span class="InlineEquation" id="IEq129">\(CN(queue[*,1,1]) = 2\)</span>.</p></div><div id="FPar19" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par67" class="Para">It follows immediately from Lemmas <span class="InternalRef"><a href="#FPar3">2</a></span>, <span class="InternalRef"><a href="#FPar5">3</a></span>, and <span class="InternalRef"><a href="#FPar7">4</a></span>(a) that <span class="InlineEquation" id="IEq130">\(CN(queue[*,1,1]) \ge 2\)</span>. We prove that <span class="InlineEquation" id="IEq131">\(CN(queue[*,1,1]) \le 2\)</span>. A possible correct behavior of a <span class="InlineEquation" id="IEq132">\(queue[*,1,1]\)</span> object, is that every enqueue operation always inserts a data item at the head of the queue. In such a case, the <span class="InlineEquation" id="IEq133">\(queue[*,1,1]\)</span> object, behaves like a <em class="EmphasisTypeItalic ">stack</em>[1,¬†1,¬†1] object. This implies that <span class="InlineEquation" id="IEq134">\(CN(queue[*,1,1])\le CN(stack[1,1,1])\)</span>. Thus, by Lemma¬†<span class="InternalRef"><a href="#FPar7">4</a></span>(c), <span class="InlineEquation" id="IEq135">\(CN(queue[*,1,1]) \le 2\)</span>.</p></div><div id="FPar20" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Corollary 1</strong> </span></h3><p id="Par68" class="Para">For every <span class="InlineEquation" id="IEq136">\(b\in Z^+\cup \{*\}\)</span>, <span class="InlineEquation" id="IEq137">\(c\in Z^+\cup \{0,*\} : CN(queue[*,b,c]) = 2\)</span>.</p></div><div id="FPar21" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par69" class="Para">The corollary follows from Lemmas¬†<span class="InternalRef"><a href="#FPar3">2</a></span>, <span class="InternalRef"><a href="#FPar5">3</a></span>, <span class="InternalRef"><a href="#FPar7">4</a></span>(a) and Theorem¬†<span class="InternalRef"><a href="#FPar18">1</a></span>. <span class="InlineEquation" id="IEq138">\(\square \)</span> </p></div><p id="Par70" class="Para">Next we show that when the enqueue operation is relaxed but <em class="EmphasisTypeItalic ">can not</em> insert a value at an arbitrary position, the consensus number is infinity.</p><div id="FPar22" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 2</strong> </span></h3><p id="Par71" class="Para">For every <span class="InlineEquation" id="IEq139">\(a\in Z^+: CN(queue[a,0,1]) = \infty \)</span>.</p></div><div id="FPar23" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par72" class="Para">For any given number <span class="InlineEquation" id="IEq140">\(a\in Z^+\)</span>, we present a simple consensus algorithm for any number of processes using a singe <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†0,¬†1] object. Each process first enqueues its input value <span class="InlineEquation" id="IEq141">\(a+1\)</span> times. Then, the process uses a peek operation to find out the value of the first item in the queue, and decides on that value. Clearly, once some process finishes to enqueue its input value <span class="InlineEquation" id="IEq142">\(a+1\)</span> times, the value of the item at the head of the queue never changes. The result follows. <span class="InlineEquation" id="IEq143">\(\square \)</span> </p></div><div id="FPar24" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Corollary 2</strong> </span></h3><p id="Par73" class="Para">For every <span class="InlineEquation" id="IEq144">\(a\in Z^+\)</span>, <span class="InlineEquation" id="IEq145">\(b\in Z^+\cup \{0,*\} : CN(queue[a,b,1]) = \infty \)</span>.</p></div><div id="FPar25" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par74" class="Para">The corollary follows immediately from Lemmas¬†<span class="InternalRef"><a href="#FPar3">2</a></span>, <span class="InternalRef"><a href="#FPar5">3</a></span> and Theorem¬†<span class="InternalRef"><a href="#FPar22">2</a></span>. <span class="InlineEquation" id="IEq146">\(\square \)</span> </p></div></div></section><section id="Sec12" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">5 </span>Relaxing the peek operation</h2><div class="content"><p id="Par75" class="Para">Assume a queue object where only the <em class="EmphasisTypeItalic ">peek</em> operation may be relaxed. We show that in <em class="EmphasisTypeItalic ">all</em> possible relaxations of the peek operation the consensus number drops (from infinity) to two.</p><div id="FPar26" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 3</strong> </span></h3><p id="Par76" class="Para"> <span class="InlineEquation" id="IEq147">\(CN(queue[1,1,2]) = 2\)</span>.</p></div><div id="FPar27" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par77" class="Para">It follows from Lemmas <span class="InternalRef"><a href="#FPar5">3</a></span> and <span class="InternalRef"><a href="#FPar7">4</a></span>(b) that <span class="InlineEquation" id="IEq148">\(CN(queue[1,1,2]) \ge 2\)</span>. Below we prove that <span class="InlineEquation" id="IEq149">\(CN(queue[1,1,2]) \le 2\)</span>. By contradiction, assume that we have a wait-free consensus algorithm for <em class="EmphasisTypeItalic ">three</em> processes <em class="EmphasisTypeItalic ">p</em>, <em class="EmphasisTypeItalic ">q</em> and <em class="EmphasisTypeItalic ">g</em> using only <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2] objects and registers. By Lemma <span class="InternalRef"><a href="#FPar12">7</a></span>, the algorithm has a critical run <em class="EmphasisTypeItalic ">x</em>. By definition of a critical run, for two of the processes, say <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em>, a run resulting by an extension of <em class="EmphasisTypeItalic ">x</em> by a single event of <em class="EmphasisTypeItalic ">p</em> and a run resulting by an extension of <em class="EmphasisTypeItalic ">x</em> by a single event of <em class="EmphasisTypeItalic ">q</em> are not compatible. Thus, by Lemma <span class="InternalRef"><a href="#FPar14">8</a></span>, in their next events from <em class="EmphasisTypeItalic ">x</em>, <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> are accessing the same object, which must be a <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2] object. By Lemma¬†<span class="InternalRef"><a href="#FPar16">9</a></span>, if the next event of <em class="EmphasisTypeItalic ">p</em> (resp. <em class="EmphasisTypeItalic ">q</em>) from <em class="EmphasisTypeItalic ">x</em> is a relaxed peek event which may return one of the two oldest items in a queue, <span class="InlineEquation" id="IEq150">\(xp^1\)</span> and <span class="InlineEquation" id="IEq151">\(xp^2\)</span> (resp. <span class="InlineEquation" id="IEq152">\(xq^1\)</span> and <span class="InlineEquation" id="IEq153">\(xq^2\)</span>) are compatible. Below, when the next event of <em class="EmphasisTypeItalic ">p</em> from <em class="EmphasisTypeItalic ">x</em> is a peek event, <em class="EmphasisTypeItalic ">xp</em> refers to <span class="InlineEquation" id="IEq154">\(xp^1\)</span> and <span class="InlineEquation" id="IEq155">\(xp^2\)</span>.</p><p id="Par78" class="Para">Without loss of generality, we can assume the <em class="EmphasisTypeItalic ">xp</em> is 0-valent and <em class="EmphasisTypeItalic ">xq</em> is 1-valent. Since <em class="EmphasisTypeItalic ">xp</em> is 0-valent also <em class="EmphasisTypeItalic ">xpq</em> is 0-valent. Since <em class="EmphasisTypeItalic ">xq</em> is 1-valent also <em class="EmphasisTypeItalic ">xqp</em> is 1-valent. Thus, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> are not compatible. Next, we consider all the possible cases, regarding the next two events of <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> from <em class="EmphasisTypeItalic ">x</em> and show that each one of these cases leads to a contradiction.</p><p id="Par79" class="Para"> <em class="EmphasisTypeItalic ">Case 1</em> Both events are <em class="EmphasisTypeItalic ">peek</em> events. Because a peek operation does not have any effect on the state of a <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2] object, it follows that <em class="EmphasisTypeItalic ">xpq</em>[<em class="EmphasisTypeItalic ">g</em>]<em class="EmphasisTypeItalic ">xqp</em> and the states of all the objects that <em class="EmphasisTypeItalic ">g</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> must be compatible, a contradiction. Notice that we do not really care what value a peek operation returns (i.e., the oldest or second oldest), since this will not affect the state of the object visible to <em class="EmphasisTypeItalic ">g</em>.</p><p id="Par80" class="Para"> <em class="EmphasisTypeItalic ">Case 2</em> Exactly one of the two events is a <em class="EmphasisTypeItalic ">peek</em> event. Because the peek operation does not have any effect on the state of a <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2] object and the other operation has the same effect in both <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em>, it follows that <em class="EmphasisTypeItalic ">xpq</em>[<em class="EmphasisTypeItalic ">g</em>]<em class="EmphasisTypeItalic ">xqp</em> and the states of all the objects that <em class="EmphasisTypeItalic ">g</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> must be compatible, a contradiction. Notice that again we do not really care what value the peek operation returns.</p><p id="Par81" class="Para"> <em class="EmphasisTypeItalic ">Case 3</em> Both events are <em class="EmphasisTypeItalic ">dequeue</em> events. In the last two events in <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> the same two items were removed from the queue, thus, <em class="EmphasisTypeItalic ">xpq</em>[<em class="EmphasisTypeItalic ">g</em>]<em class="EmphasisTypeItalic ">xqp</em> and the states of all the objects that <em class="EmphasisTypeItalic ">g</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> must be compatible, a contradiction.</p><p id="Par82" class="Para"> <em class="EmphasisTypeItalic ">Case 4</em> One event is a <em class="EmphasisTypeItalic ">enqueue</em> and the other is a <em class="EmphasisTypeItalic ">dequeue</em>. Assume w.l.o.g. that the enqueue event is by <em class="EmphasisTypeItalic ">p</em> and the dequeue event is be <em class="EmphasisTypeItalic ">q</em>. If the queue is nonempty, the two events commute since each operates on a different end of the queue. Thus, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> are indistinguishable for all the processes and the states of all the objects is the same in <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em>, and thus by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span> the contradiction is immediate. If the queue is empty, <em class="EmphasisTypeItalic ">xp</em>[<em class="EmphasisTypeItalic ">g</em>]<em class="EmphasisTypeItalic ">xqp</em> and the states of all the objects that <em class="EmphasisTypeItalic ">g</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em> must be compatible, a contradiction.</p><div id="Par83" class="Para"> <em class="EmphasisTypeItalic ">Case 5</em> Both events are <em class="EmphasisTypeItalic ">enqueue</em> events. Assume that <em class="EmphasisTypeItalic ">p</em> enqueues the value <span class="InlineEquation" id="IEq156">\(v_p\)</span> and <em class="EmphasisTypeItalic ">q</em> enqueues the value <span class="InlineEquation" id="IEq157">\(v_q\)</span>. Consider the runs <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em>. The valency of each one of these two runs is determined by the process that has taken the first step from <em class="EmphasisTypeItalic ">x</em>. If <em class="EmphasisTypeItalic ">p</em> or <em class="EmphasisTypeItalic ">q</em> runs uninterrupted starting from either <em class="EmphasisTypeItalic ">xpq</em> or <em class="EmphasisTypeItalic ">xqp</em>, the only way for each one of them to observe the queue‚Äôs state is via a <em class="EmphasisTypeItalic ">dequeue</em> or a <em class="EmphasisTypeItalic ">peek</em> operation. However, since the peek operation can return one of the first two items at the head of the queue, a <em class="EmphasisTypeItalic ">peek</em> can not be used to determine which process enqueue operation was first. More precisely, after the two enqueue events by <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em>, in all extension of <em class="EmphasisTypeItalic ">x</em>,<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"> <p id="Par84" class="Para">As long as the values <span class="InlineEquation" id="IEq158">\(v_p\)</span> and <span class="InlineEquation" id="IEq159">\(v_q\)</span> are not at the head of queue, the adversary can force every peek event to always return the item at the head of the queue, and thus it is not possible to decide which process enqueue event was first;</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"> <p id="Par85" class="Para">If the values <span class="InlineEquation" id="IEq160">\(v_p\)</span> and <span class="InlineEquation" id="IEq161">\(v_q\)</span> are at the head of queue (in some order), the adversary can force every peek operation to always return the <em class="EmphasisTypeItalic ">same</em> value, say <span class="InlineEquation" id="IEq162">\(v_p\)</span>, regardless whether <span class="InlineEquation" id="IEq163">\(v_p\)</span> is the first or second element. Thus, again, it is not possible to decide which process enqueue event was first.</p> </div><div class="ClearBoth">¬†</div></li></ol></div>Thus, the only way for a process to determine which process went first is via dequeue operations. Next we consider the following two extensions of <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em>.<div class="UnorderedList"><ul class="UnorderedListMarkDash"><li> <p id="Par86" class="Para">Let <em class="EmphasisTypeItalic ">y</em> be an extension of <em class="EmphasisTypeItalic ">xpq</em> that results from the following execution: Starting from <em class="EmphasisTypeItalic ">x</em> let <em class="EmphasisTypeItalic ">p</em> enqueue <span class="InlineEquation" id="IEq164">\(v_p\)</span> and then let <em class="EmphasisTypeItalic ">q</em> enqueue <span class="InlineEquation" id="IEq165">\(v_q\)</span>. Run <em class="EmphasisTypeItalic ">p</em> uninterrupted until it dequeues <span class="InlineEquation" id="IEq166">\(v_p\)</span> (as explained above this is the only way for <em class="EmphasisTypeItalic ">p</em> to observe which process went first). Then, run <em class="EmphasisTypeItalic ">q</em> uninterrupted until it dequeues <span class="InlineEquation" id="IEq167">\(v_q\)</span>.</p> </li><li> <p id="Par87" class="Para">Let <span class="InlineEquation" id="IEq168">\(y'\)</span> be an extension of <em class="EmphasisTypeItalic ">xqp</em> that results from the following execution: Starting from <em class="EmphasisTypeItalic ">x</em> let <em class="EmphasisTypeItalic ">q</em> enqueue <span class="InlineEquation" id="IEq169">\(v_q\)</span> and then let <em class="EmphasisTypeItalic ">p</em> enqueue <span class="InlineEquation" id="IEq170">\(v_p\)</span>. Run <em class="EmphasisTypeItalic ">p</em> uninterrupted until it dequeues <span class="InlineEquation" id="IEq171">\(v_q\)</span> Then, run <em class="EmphasisTypeItalic ">q</em> uninterrupted until it dequeues <span class="InlineEquation" id="IEq172">\(v_p\)</span>.</p> </li></ul></div>Since <em class="EmphasisTypeItalic ">y</em> is and extension of <em class="EmphasisTypeItalic ">xpq</em>, <em class="EmphasisTypeItalic ">y</em> is 0-valent, and since <span class="InlineEquation" id="IEq173">\(y'\)</span> is and extension of <em class="EmphasisTypeItalic ">xqp</em>, <span class="InlineEquation" id="IEq174">\(y'\)</span> is 1-valent. Clearly, <span class="InlineEquation" id="IEq175">\(y[g]y'\)</span> and the states of all the objects that <em class="EmphasisTypeItalic ">g</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">y</em> and <span class="InlineEquation" id="IEq176">\(y'\)</span> must be compatible, a contradiction. <span class="InlineEquation" id="IEq177">\(\square \)</span> </div></div><div id="FPar28" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Corollary 3</strong> </span></h3><p id="Par88" class="Para">For every <span class="InlineEquation" id="IEq178">\(a\in Z^+\cup \{*\}\)</span>, <span class="InlineEquation" id="IEq179">\(b\in Z^+\cup \{*\}\)</span>, <span class="InlineEquation" id="IEq180">\(c\ne 1 : CN(queue[a,b,c]) = 2\)</span>.</p></div><div id="FPar29" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par89" class="Para">The corollary follows from Lemma¬†<span class="InternalRef"><a href="#FPar3">2</a></span>, <span class="InternalRef"><a href="#FPar7">4</a></span>(a) and Theorem¬†<span class="InternalRef"><a href="#FPar26">3</a></span>.</p></div></div></section><section id="Sec13" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">6 </span>Not supporting the dequeue operation</h2><div class="content"><p id="Par90" class="Para">The consensus number of all the queues where the dequeue operation is not supported <em class="EmphasisTypeItalic ">and</em> the peek operation is relaxed, is just 1. Put another way, while <span class="InlineEquation" id="IEq181">\(CN(queue[1,0,1]) = \infty \)</span> and <span class="InlineEquation" id="IEq182">\(CN(queue[1,1,2]) = 2\)</span>, by removing the dequeue operation from the object <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2], we get an object with consensus number one. That is,</p><div id="FPar30" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 4</strong> </span></h3><p id="Par91" class="Para"> <span class="InlineEquation" id="IEq183">\(CN(queue[1,0,2]) = 1\)</span>.</p></div><div id="FPar31" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par92" class="Para">By contradiction, assume that we have a wait-free consensus algorithm for <em class="EmphasisTypeItalic ">two</em> processes <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> using only <em class="EmphasisTypeItalic ">queue</em>[1,¬†0,¬†2] objects and registers. By Lemma <span class="InternalRef"><a href="#FPar12">7</a></span>, the algorithm has a critical run <em class="EmphasisTypeItalic ">x</em>. By definition of a critical run, a run resulting by an extension of <em class="EmphasisTypeItalic ">x</em> by a single event of <em class="EmphasisTypeItalic ">p</em> and a run resulting by an extension of <em class="EmphasisTypeItalic ">x</em> by a single event of <em class="EmphasisTypeItalic ">q</em> are not compatible. By Lemma <span class="InternalRef"><a href="#FPar14">8</a></span>, in their next events from <em class="EmphasisTypeItalic ">x</em>, <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> are accessing the same object, which must be a <em class="EmphasisTypeItalic ">queue</em>[1,¬†0,¬†2] object. By Lemma¬†<span class="InternalRef"><a href="#FPar16">9</a></span>, if the next event of <em class="EmphasisTypeItalic ">p</em> (resp. <em class="EmphasisTypeItalic ">q</em>) from <em class="EmphasisTypeItalic ">x</em> is a relaxed peek event which may return one of the two oldest items in a queue, <span class="InlineEquation" id="IEq184">\(xp^1\)</span> and <span class="InlineEquation" id="IEq185">\(xp^2\)</span> (resp. <span class="InlineEquation" id="IEq186">\(xq^1\)</span> and <span class="InlineEquation" id="IEq187">\(xq^2\)</span>) are compatible. Below, when the next event of <em class="EmphasisTypeItalic ">p</em> from <em class="EmphasisTypeItalic ">x</em> is a peek event, <em class="EmphasisTypeItalic ">xp</em> refers to <span class="InlineEquation" id="IEq188">\(xp^1\)</span> and <span class="InlineEquation" id="IEq189">\(xp^2\)</span>.</p><p id="Par93" class="Para">Without loss of generality, we assume the <em class="EmphasisTypeItalic ">xp</em> is 0-valent and <em class="EmphasisTypeItalic ">xq</em> is 1-valent. Since <em class="EmphasisTypeItalic ">xp</em> is 0-valent also <em class="EmphasisTypeItalic ">xpq</em> is 0-valent. Since <em class="EmphasisTypeItalic ">xq</em> is 1-valent also <em class="EmphasisTypeItalic ">xqp</em> is 1-valent. Thus, <em class="EmphasisTypeItalic ">xpq</em> and <em class="EmphasisTypeItalic ">xqp</em> are not compatible. Next, we consider all the possible cases, regarding the next events of <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> from <em class="EmphasisTypeItalic ">x</em> and show that each one of these cases leads to a contradiction.</p><p id="Par94" class="Para"> <em class="EmphasisTypeItalic ">Case 1</em> Both events are <em class="EmphasisTypeItalic ">peek</em> events. Because a peek operation does not have any effect on the states of the <em class="EmphasisTypeItalic ">queue</em>[1,¬†0,¬†2] object, it follows that <span class="InlineEquation" id="IEq190">\(xp^1[p]xqp^1\)</span> and the states of all the objects that <em class="EmphasisTypeItalic ">p</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <span class="InlineEquation" id="IEq191">\(xp^1\)</span> and <span class="InlineEquation" id="IEq192">\(xqp^1\)</span> must be compatible, a contradiction. We do not really care what value a peek operation by <em class="EmphasisTypeItalic ">q</em> returns since this will not affect the state of the object visible to <em class="EmphasisTypeItalic ">p</em>.<sup><a href="#Fn5" id="Fn5_source">5</a></sup> </p><p id="Par96" class="Para"> <em class="EmphasisTypeItalic ">Case 2</em> Exactly one of the two events is a <em class="EmphasisTypeItalic ">peek</em> event. Assume w.l.o.g. that the peek event is by process <em class="EmphasisTypeItalic ">q</em>. Because the peek operation does not have any effect on the states of the <em class="EmphasisTypeItalic ">queue</em>[1,¬†0,¬†2] object and the operation by <em class="EmphasisTypeItalic ">p</em> has the same effect in both <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em>, it follows that <em class="EmphasisTypeItalic ">xp</em>[<em class="EmphasisTypeItalic ">p</em>]<em class="EmphasisTypeItalic ">xqp</em> and the states of all the objects that <em class="EmphasisTypeItalic ">p</em> can access are the same at these runs. Thus, by Lemma <span class="InternalRef"><a href="#FPar8">5</a></span>, <em class="EmphasisTypeItalic ">xp</em> and <em class="EmphasisTypeItalic ">xqp</em> must be compatible, a contradiction. Notice that again we do not really care what value the peek operation returns.</p><div id="Par97" class="Para"> <em class="EmphasisTypeItalic ">Case 3</em> Both events are <em class="EmphasisTypeItalic ">enqueue</em> events. Assume that <em class="EmphasisTypeItalic ">p</em> enqueues the value <span class="InlineEquation" id="IEq193">\(v_p\)</span> and <em class="EmphasisTypeItalic ">q</em> enqueues the value <span class="InlineEquation" id="IEq194">\(v_q\)</span>. Consider the 0-valent run <em class="EmphasisTypeItalic ">xpq</em> and the 1-valent run <em class="EmphasisTypeItalic ">xqp</em>. The valency of each one of these two runs is determined by the process that has taken the first step from <em class="EmphasisTypeItalic ">x</em>. If <em class="EmphasisTypeItalic ">p</em> or <em class="EmphasisTypeItalic ">q</em> runs uninterrupted starting from either <em class="EmphasisTypeItalic ">xpq</em> or <em class="EmphasisTypeItalic ">xqp</em>, the only way for each one of them to observe the queue‚Äôs state is via a <em class="EmphasisTypeItalic ">peek</em> operation. Since the peek operation can return one of the first two items at the head of the queue, a <em class="EmphasisTypeItalic ">peek</em> can not be used to determine which process enqueue operation was first. More precisely:<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"> <p id="Par98" class="Para">If the queue is <em class="EmphasisTypeItalic ">not</em> empty at <em class="EmphasisTypeItalic ">x</em> then after the two enqueue events by <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em>, the adversary can force every peek event to always return the item at the head of the queue, and thus it is not possible for <em class="EmphasisTypeItalic ">p</em> or <em class="EmphasisTypeItalic ">q</em> to decide which process enqueue event was first.</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"> <p id="Par99" class="Para">If the queue is empty at <em class="EmphasisTypeItalic ">x</em> then after the two enqueue events by <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em>, the values <span class="InlineEquation" id="IEq195">\(v_p\)</span> and <span class="InlineEquation" id="IEq196">\(v_q\)</span> are at the head of queue (in some order). Now the adversary can force every peek operation by <em class="EmphasisTypeItalic ">p</em> to always return <span class="InlineEquation" id="IEq197">\(v_p\)</span>, and every peek operation by <em class="EmphasisTypeItalic ">q</em> can always return <span class="InlineEquation" id="IEq198">\(v_q\)</span>. Thus, again, it is not possible to decide which process enqueue event was first.</p> </div><div class="ClearBoth">¬†</div></li></ol></div>Thus, it can not be that both events are enqueue events, a contradiction. <span class="InlineEquation" id="IEq199">\(\square \)</span> </div></div><div id="FPar32" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Corollary 4</strong> </span></h3><p id="Par100" class="Para">For every <span class="InlineEquation" id="IEq200">\(a\in Z^+\cup \{0, *\}\)</span>, <span class="InlineEquation" id="IEq201">\(c\ge 2 : CN(queue[a,0,c]) = 1\)</span>.</p></div><div id="FPar33" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par101" class="Para">The corollary follows from Lemmas¬†<span class="InternalRef"><a href="#FPar3">2</a></span>, <span class="InternalRef"><a href="#FPar5">3</a></span> and Theorem¬†<span class="InternalRef"><a href="#FPar30">4</a></span>.</p></div></div></section><section id="Sec14" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">7 </span>Atomic registers versus relaxed queues</h2><div class="content"><p id="Par102" class="Para">It is known that <span class="InlineEquation" id="IEq202">\(CN( atomic~register ) = 1\)</span> [<span class="CitationRef"><a href="#CR21">21</a></span>]. It is easy to see that a <span class="InlineEquation" id="IEq203">\(queue[*,0,1]\)</span> has a trivial wait-free implementation from a single atomic register, which raises the question whether also <em class="EmphasisTypeItalic ">queue</em>[1,¬†0,¬†2] has a wait-free implementation from atomic registers. The answer to this question is negative. We prove the following general result:</p><div id="FPar34" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 5</strong> </span></h3><p id="Par103" class="Para">A <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†0,¬†<em class="EmphasisTypeItalic ">c</em>] has no wait-free implementation from atomic registers, for every two integers <span class="InlineEquation" id="IEq204">\(a\ge 1\)</span> and <span class="InlineEquation" id="IEq205">\(c\ge 1\)</span>.</p></div><div id="FPar35" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par104" class="Para">The (<em class="EmphasisTypeItalic ">n</em>,¬†<em class="EmphasisTypeItalic ">k</em>)<em class="EmphasisTypeItalic ">-set consensus problem</em> is to design an algorithm for <em class="EmphasisTypeItalic ">n</em> processes, where each process starts with an input value from some domain, and must choose some participating process‚Äô input as its output. All <em class="EmphasisTypeItalic ">n</em> processes together may choose no more than <em class="EmphasisTypeItalic ">k</em> distinct output values. An (<em class="EmphasisTypeItalic ">n</em>,¬†<em class="EmphasisTypeItalic ">k</em>)-set consensus object (or algorithm) is an object which solves the (<em class="EmphasisTypeItalic ">n</em>,¬†<em class="EmphasisTypeItalic ">k</em>)-set consensus problem. One of the most celebrated impossibility results in distributed computing is that, for any <span class="InlineEquation" id="IEq206">\(1\le k&lt; n\)</span>, a wait-free (<em class="EmphasisTypeItalic ">n</em>,¬†<em class="EmphasisTypeItalic ">k</em>)-set consensus object can not be implemented using any number of wait-free <span class="InlineEquation" id="IEq207">\((n,k+1)\)</span>-set consensus objects and atomic registers [<span class="CitationRef"><a href="#CR5">5</a></span>, <span class="CitationRef"><a href="#CR13">13</a></span>, <span class="CitationRef"><a href="#CR26">26</a></span>].</p><p id="Par105" class="Para">We show that, for any for every two positive integers <em class="EmphasisTypeItalic ">a</em> and <em class="EmphasisTypeItalic ">c</em>, a wait-free <span class="InlineEquation" id="IEq208">\((a+c, a+c-1)\)</span>-set consensus object has a simple wait-free implementation using a single (initially empty) <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†0,¬†<em class="EmphasisTypeItalic ">c</em>] object, as follows. Each process <span class="InlineEquation" id="IEq209">\(p_i\)</span> inserts its input value <span class="InlineEquation" id="IEq210">\(v_i\)</span> into the queue using an <span class="InlineEquation" id="IEq211">\(enq.a(v_i)\)</span> operation, and then uses a <em class="EmphasisTypeItalic ">peek</em>.<em class="EmphasisTypeItalic ">c</em>() operation to find a value in one of the <em class="EmphasisTypeItalic ">c</em> positions at the front of the queue, and decides on it. During the execution any one of the <span class="InlineEquation" id="IEq212">\(a+c-1\)</span> values that are inserted first into the queue can occupy (at some point in time) one of the <em class="EmphasisTypeItalic ">c</em> positions at the front of the queue. Any value that is inserted later will never occupy one of the <em class="EmphasisTypeItalic ">c</em> positions at the front of the queue. Thus, processes together will never choose more than <span class="InlineEquation" id="IEq213">\(a+c-1\)</span> distinct output values. Since, for every two positive integers <em class="EmphasisTypeItalic ">a</em> and <em class="EmphasisTypeItalic ">c</em>, it is possible to solve in a wait-free manner the <span class="InlineEquation" id="IEq214">\((a+c, a+c-1)\)</span>-set consensus problem using a <em class="EmphasisTypeItalic ">queue</em>[<em class="EmphasisTypeItalic ">a</em>,¬†0,¬†<em class="EmphasisTypeItalic ">c</em>] object, but it is not possible to solve <span class="InlineEquation" id="IEq215">\((a+c, a+c-1)\)</span>-set consensus in a wait-free manner using atomic registers, the result follows. <span class="InlineEquation" id="IEq216">\(\square \)</span> </p></div></div></section><section id="Sec15" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">8 </span>Relaxed registers</h2><div class="content"><p id="Par106" class="Para">It is common to assume that operations on the same memory location are atomic ‚Äì they occur in some definite order. However, this assumption can be relaxed allowing the possibility of concurrent operation on the same memory location. In [<span class="CitationRef"><a href="#CR20">20</a></span>], Lamport has defined three classes of shared registers which support read and write operations, called‚Äîsafe, regular and atomic‚Äîdepending on their properties when several reads and/or writes are executed concurrently. Below we consider natural generalizations of Lamport‚Äôs notions.</p><section id="Sec16" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">8.1 </span> <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular and <em class="EmphasisTypeItalic ">k</em>-atomic registers</h3><div id="Par107" class="Para">Unless otherwise stated, for the rest of this section. it is assumed that each register is a single-writer multi-reader register. Such a register can be written by one predefined process and can be read by all the processes. Let <em class="EmphasisTypeItalic ">k</em> be a positive integer.<div class="UnorderedList"><ul class="UnorderedListMarkDash"><li> <p id="Par108" class="Para">The weakest possibility is a <em class="EmphasisTypeItalic ">k</em>-<em class="EmphasisTypeItalic ">safe</em> register, in which it is assumed that a read not concurrent with any write obtains one of the <em class="EmphasisTypeItalic ">k</em> most recently written values. No assumption is made about the value obtained by a read that overlaps a write, except that it must obtain one of the possible values of the register. We consider the initial value as the first written value.</p> </li><li> <p id="Par109" class="Para">The next stronger possibility is a <em class="EmphasisTypeItalic ">k</em>-<em class="EmphasisTypeItalic ">regular</em> register, in which it is assumed that a read not concurrent with any write obtains one of the <em class="EmphasisTypeItalic ">k</em> most recently written values. A read that overlaps a write obtains either the new value or one of the <em class="EmphasisTypeItalic ">k</em> most recently written values. That is, a read that overlaps any series of writes obtains either one of the values being written or one of the <em class="EmphasisTypeItalic ">k</em> most recently written values before the first of the writes.</p> </li><li> <p id="Par110" class="Para">The final possibility is a <em class="EmphasisTypeItalic ">k</em>-<em class="EmphasisTypeItalic ">atomic</em> register, in which the reads and writes behave as if they occur in some definite order, and a read obtains one of the <em class="EmphasisTypeItalic ">k</em> most recently written values. In other words, for any execution, there is some way of totally ordering the overlapping reads and writes so that the value returned by the each read is one of the <em class="EmphasisTypeItalic ">k</em> most recently written values in the execution which has no overlapping (operations that do not overlap should take effect in their ‚Äúreal-time‚Äù order.)</p> </li></ul></div>We observe that Lamport‚Äôs familiar notions of safe, regular and atomic registers are equivalent to the notions of 1-safe, 1-regular and 1-atomic registers, respectively. We will use the notion <em class="EmphasisTypeItalic ">k</em>-register as an abbreviation for <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular and <em class="EmphasisTypeItalic ">k</em>-atomic registers, when the exact type of a register is not important. We notice that, for <span class="InlineEquation" id="IEq217">\(k\ge 1\)</span>, a <em class="EmphasisTypeItalic ">k</em>-atomic register is exactly the object <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†<em class="EmphasisTypeItalic ">k</em>], as defined in the Introduction.</div></section><section id="Sec17" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">8.2 </span>Two constructions</h3><p id="Par111" class="Para">We present two constructions of registers, by indicating how write operations and read operations are performed. A register can be either a single-writer single-reader (SWSR) register, a single-writer multi-reader (SWMR) register or a multi-writer multi-reader (MWMR) register. Unless explicitly stated, we assume that a register is a SWMR register. We require that the constructions satisfy the wait-freedom progress condition.</p><p id="Par112" class="Para">The first construction implements a single-writer <em class="EmphasisTypeItalic ">multi-reader</em> multi-valued <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular or <span class="InlineEquation" id="IEq218">\((k+1)\)</span>-atomic register, denoted <em class="EmphasisTypeItalic ">r</em>, from single-writer <em class="EmphasisTypeItalic ">single-reader</em> multi-valued <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular or <em class="EmphasisTypeItalic ">k</em>-atomic registers, respectively.</p><div id="FPar36" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Construction 8.1</strong> </span></h3><div id="Par113" class="Para">Let <em class="EmphasisTypeItalic ">k</em> be an arbitrary natural number, and let <span class="InlineEquation" id="IEq219">\(r_1,...,r_n\)</span> be SWSR multi-valued <em class="EmphasisTypeItalic ">k</em>-registers, where each <span class="InlineEquation" id="IEq220">\(r_i\,(i\in \{1,...,n\})\)</span> can be written by the same single process and read by process <span class="InlineEquation" id="IEq221">\(p_i\)</span>. We construct a SWMR multi-valued <em class="EmphasisTypeItalic ">k</em>-register <em class="EmphasisTypeItalic ">r</em> as follows:<div class="UnorderedList"><ul class="UnorderedListMarkDash"><li> <p id="Par114" class="Para">The write operation <span class="InlineEquation" id="IEq222">\(r:= value\)</span> is performed as follows: <strong class="EmphasisTypeBold ">for</strong> <span class="InlineEquation" id="IEq223">\(i=1\)</span> <strong class="EmphasisTypeBold ">to</strong> <em class="EmphasisTypeItalic ">n</em> <strong class="EmphasisTypeBold ">do</strong> <span class="InlineEquation" id="IEq224">\(r_i := value\)</span>;</p> </li><li> <p id="Par115" class="Para">The read operation of <em class="EmphasisTypeItalic ">r</em> by process <span class="InlineEquation" id="IEq225">\(p_i\)</span> is performed by letting <span class="InlineEquation" id="IEq226">\(p_i\)</span> read the value of <span class="InlineEquation" id="IEq227">\(r_i\)</span>.</p> </li></ul></div> </div></div><p id="Par116" class="Para">The above construction is similar to Construction¬†<span class="InternalRef"><a href="#FPar36">8.1</a></span> from [<span class="CitationRef"><a href="#CR20">20</a></span>] which was designed for 1-registers. We prove the following theorem for the general case of <em class="EmphasisTypeItalic ">k</em>-registers.</p><div id="FPar37" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 6</strong> </span></h3><div id="Par117" class="Para">The following claims are correct w.r.t. Construction¬†<span class="InternalRef"><a href="#FPar36">8.1</a></span>, for any <span class="InlineEquation" id="IEq228">\(k\ge 1\)</span>,<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"> <p id="Par118" class="Para">If <span class="InlineEquation" id="IEq229">\(r_1,...,r_n\)</span> are SWSR <em class="EmphasisTypeItalic ">k</em>-safe registers or <span class="InlineEquation" id="IEq230">\(r_1,...,r_n\)</span> are SWSR <em class="EmphasisTypeItalic ">k</em>-regular registers then <em class="EmphasisTypeItalic ">r</em> is a SWMR <em class="EmphasisTypeItalic ">k</em>-safe register or a SWMR <em class="EmphasisTypeItalic ">k</em>-regular register, respectively.</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"> <p id="Par119" class="Para">If <span class="InlineEquation" id="IEq231">\(r_1,...,r_n\)</span> are SWSR <em class="EmphasisTypeItalic ">k</em>-atomic registers then <em class="EmphasisTypeItalic ">r</em> is a SWMR <span class="InlineEquation" id="IEq232">\((k+1)\)</span>-atomic register.</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"> <p id="Par120" class="Para">If <span class="InlineEquation" id="IEq233">\(r_1,...,r_n\)</span> are SWSR <em class="EmphasisTypeItalic ">k</em>-atomic registers then <em class="EmphasisTypeItalic ">r</em> is not a SWMR <em class="EmphasisTypeItalic ">k</em>-atomic register.</p> </div><div class="ClearBoth">¬†</div></li></ol></div> </div></div><div id="FPar38" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par121" class="Para">A read of <em class="EmphasisTypeItalic ">r</em> by process <span class="InlineEquation" id="IEq234">\(p_i\)</span> that does not overlap a write of <em class="EmphasisTypeItalic ">r</em>, also does not overlap a write of <span class="InlineEquation" id="IEq235">\(r_i\)</span>. If <span class="InlineEquation" id="IEq236">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-register (i.e., if <span class="InlineEquation" id="IEq237">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular or <em class="EmphasisTypeItalic ">k</em>-atomic), then this read must obtain one of the <em class="EmphasisTypeItalic ">k</em> most recently written values into <em class="EmphasisTypeItalic ">r</em>. This is enough to show that if <span class="InlineEquation" id="IEq238">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-safe then <em class="EmphasisTypeItalic ">r</em> is <em class="EmphasisTypeItalic ">k</em>-safe. If a read of <span class="InlineEquation" id="IEq239">\(r_i\)</span> by process <span class="InlineEquation" id="IEq240">\(p_i\)</span> overlaps a write of <span class="InlineEquation" id="IEq241">\(r_i\)</span>, then it overlaps a write of the same value to <em class="EmphasisTypeItalic ">r</em>. In such a case, if <span class="InlineEquation" id="IEq242">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-regular then this read must obtain either the last value written or one of the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq243">\(r_i\)</span> (and hence into <em class="EmphasisTypeItalic ">r</em>). This implies that if <span class="InlineEquation" id="IEq244">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-regular then <em class="EmphasisTypeItalic ">r</em> is <em class="EmphasisTypeItalic ">k</em>-regular.</p><p id="Par122" class="Para">Now, assume that <span class="InlineEquation" id="IEq245">\(r_i\)</span> is <em class="EmphasisTypeItalic ">k</em>-atomic, and that a read of <span class="InlineEquation" id="IEq246">\(r_i\)</span> by process <span class="InlineEquation" id="IEq247">\(p_i\)</span> overlaps a write of the value <em class="EmphasisTypeItalic ">v</em> into <em class="EmphasisTypeItalic ">r</em>. Then (1) if <em class="EmphasisTypeItalic ">v</em> was already written into <span class="InlineEquation" id="IEq248">\(r_i\)</span>, this read must obtain either the value <em class="EmphasisTypeItalic ">v</em> or one of the <span class="InlineEquation" id="IEq249">\(k-1\)</span> most recently written values into <span class="InlineEquation" id="IEq250">\(r_i\)</span> before <em class="EmphasisTypeItalic ">v</em>; or (2) if <em class="EmphasisTypeItalic ">v</em> was not written into <span class="InlineEquation" id="IEq251">\(r_i\)</span> yet, this read must one of the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq252">\(r_i\)</span>. Since the linearization point of write of <em class="EmphasisTypeItalic ">v</em> into <em class="EmphasisTypeItalic ">r</em> might be before the linearization point of the read of <em class="EmphasisTypeItalic ">v</em>, in both cases above, the returned value is one of the <span class="InlineEquation" id="IEq253">\(k+1\)</span> most recently written values into <em class="EmphasisTypeItalic ">r</em>. This implies that if <span class="InlineEquation" id="IEq254">\(r_i\)</span> is a SWSR <em class="EmphasisTypeItalic ">k</em>-atomic register then <em class="EmphasisTypeItalic ">r</em> is a SWMR <span class="InlineEquation" id="IEq255">\(k+1\)</span>-atomic register.</p><p id="Par123" class="Para">Assume that <span class="InlineEquation" id="IEq256">\(r_1,...,r_n\)</span> are <em class="EmphasisTypeItalic ">k</em>-registers. If a read of <em class="EmphasisTypeItalic ">r</em> by two different processes <span class="InlineEquation" id="IEq257">\(p_i\)</span> and <span class="InlineEquation" id="IEq258">\(p_j\)</span> both overlap the same write of value <em class="EmphasisTypeItalic ">v</em> into <em class="EmphasisTypeItalic ">r</em>, it is possible for <span class="InlineEquation" id="IEq259">\(p_i\)</span> to get the new value <em class="EmphasisTypeItalic ">v</em> and for <span class="InlineEquation" id="IEq260">\(p_j\)</span> to get the <em class="EmphasisTypeItalic ">k</em>th written value into <em class="EmphasisTypeItalic ">r</em> before the value <em class="EmphasisTypeItalic ">v</em> was written. This is possible even in the case where the read by <span class="InlineEquation" id="IEq261">\(p_i\)</span> precedes the read by <span class="InlineEquation" id="IEq262">\(p_j\)</span>. This possibility is not allowed by a <em class="EmphasisTypeItalic ">k</em>-atomic register. Thus, <em class="EmphasisTypeItalic ">r</em> is not a <em class="EmphasisTypeItalic ">k</em>-atomic register. <span class="InlineEquation" id="IEq263">\(\square \)</span> </p></div><p id="Par124" class="Para">The second construction implements a SWMR multi-valued 1-safe or 1-regular register from SWMR multi-valued <em class="EmphasisTypeItalic ">k</em>-safe or <em class="EmphasisTypeItalic ">k</em>-regular registers, respectively.</p><div id="FPar39" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Construction 8.2</strong> </span></h3><div id="Par125" class="Para">Let <em class="EmphasisTypeItalic ">k</em> be an arbitrary natural number, and let <span class="InlineEquation" id="IEq264">\(r^\prime \)</span> be a SWMR multi-valued <em class="EmphasisTypeItalic ">k</em>-registers. We construct a SWMR multi-valued 1-register <em class="EmphasisTypeItalic ">r</em> as follows:<div class="UnorderedList"><ul class="UnorderedListMarkDash"><li> <p id="Par126" class="Para">The write operation <span class="InlineEquation" id="IEq265">\(r:= value\)</span> is performed as follows: <strong class="EmphasisTypeBold ">for</strong> <span class="InlineEquation" id="IEq266">\(i=1\)</span> <strong class="EmphasisTypeBold ">to</strong> <em class="EmphasisTypeItalic ">k</em> <strong class="EmphasisTypeBold ">do</strong> <span class="InlineEquation" id="IEq267">\(r^\prime := value\)</span>;</p> </li><li> <p id="Par127" class="Para">The read operation of <em class="EmphasisTypeItalic ">r</em> by process <em class="EmphasisTypeItalic ">p</em> is performed by letting <em class="EmphasisTypeItalic ">p</em> read the value of <span class="InlineEquation" id="IEq268">\(r^\prime \)</span>.</p> </li></ul></div> </div></div><div id="FPar40" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 7</strong> </span></h3><div id="Par128" class="Para">The following claims are correct w.r.t. Construction¬†<span class="InternalRef"><a href="#FPar39">8.2</a></span>, for any <span class="InlineEquation" id="IEq269">\(k\ge 1\)</span>,<div class="OrderedList"><ol><li class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"> <p id="Par129" class="Para">If <span class="InlineEquation" id="IEq270">\(r^\prime \)</span> is a SWMR <em class="EmphasisTypeItalic ">k</em>-safe register or a SWMR <em class="EmphasisTypeItalic ">k</em>-regular register then <em class="EmphasisTypeItalic ">r</em> is a SWMR 1-safe register or a SWMR 1-regular register, respectively.</p> </div><div class="ClearBoth">¬†</div></li><li class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"> <p id="Par130" class="Para">If <span class="InlineEquation" id="IEq271">\(r^\prime \)</span> is a SWMR <em class="EmphasisTypeItalic ">k</em>-atomic register then <em class="EmphasisTypeItalic ">r</em> is not a SWMR 1-atomic register.</p> </div><div class="ClearBoth">¬†</div></li></ol></div> </div></div><div id="FPar41" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par131" class="Para">A read of <em class="EmphasisTypeItalic ">r</em> by process <em class="EmphasisTypeItalic ">p</em> that does not overlap a write of <em class="EmphasisTypeItalic ">r</em>, also does not overlap any of the latest <em class="EmphasisTypeItalic ">k</em> writes of <span class="InlineEquation" id="IEq272">\(r^\prime \)</span>. Thus, all the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq273">\(r^\prime \)</span> are identical and equal the most recent value written into <span class="InlineEquation" id="IEq274">\(r^\prime \)</span>. Since <span class="InlineEquation" id="IEq275">\(r^\prime \)</span> is <em class="EmphasisTypeItalic ">k</em>-register, in the case of no overlap, a read of <em class="EmphasisTypeItalic ">r</em> must obtain one of the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq276">\(r^\prime \)</span>, and thus it must obtain the most recent value written into <span class="InlineEquation" id="IEq277">\(r^\prime \)</span>. This is enough to show that if <span class="InlineEquation" id="IEq278">\(r^\prime \)</span> is <em class="EmphasisTypeItalic ">k</em>-safe then <em class="EmphasisTypeItalic ">r</em> is 1-safe.</p><p id="Par132" class="Para">If a read of <span class="InlineEquation" id="IEq279">\(r^\prime \)</span> by process <em class="EmphasisTypeItalic ">p</em> overlaps a write of <span class="InlineEquation" id="IEq280">\(r^\prime \)</span>, then it overlaps a write of the same value to <em class="EmphasisTypeItalic ">r</em>. In such a case, if <span class="InlineEquation" id="IEq281">\(r^\prime \)</span> is <em class="EmphasisTypeItalic ">k</em>-regular then this read must obtain either the new value or one of the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq282">\(r^\prime \)</span> (and hence into <em class="EmphasisTypeItalic ">r</em>). However, since each value is written <em class="EmphasisTypeItalic ">k</em> times, each of the <em class="EmphasisTypeItalic ">k</em> most recently written values equals either the new value or the most recent value written before the new value. This implies that if <span class="InlineEquation" id="IEq283">\(r^\prime \)</span> is <em class="EmphasisTypeItalic ">k</em>-regular then <em class="EmphasisTypeItalic ">r</em> is 1-regular.</p><p id="Par133" class="Para">We have assumed that <span class="InlineEquation" id="IEq284">\(r^\prime \)</span> is a <em class="EmphasisTypeItalic ">k</em>-register. Thus, during a write of <em class="EmphasisTypeItalic ">r</em>, the <em class="EmphasisTypeItalic ">k</em> most recently written values into <span class="InlineEquation" id="IEq285">\(r^\prime \)</span> equals either the new value or the most recent value written before the new value. If a read of <em class="EmphasisTypeItalic ">r</em> by two different processes <span class="InlineEquation" id="IEq286">\(p_i\)</span> and <span class="InlineEquation" id="IEq287">\(p_j\)</span> both overlap the same write of value <em class="EmphasisTypeItalic ">v</em> into <em class="EmphasisTypeItalic ">r</em>, it is possible for <span class="InlineEquation" id="IEq288">\(p_i\)</span> to get the new value <em class="EmphasisTypeItalic ">v</em> and <span class="InlineEquation" id="IEq289">\(p_j\)</span> the old value. This is possible even in the case where the read by <span class="InlineEquation" id="IEq290">\(p_i\)</span> precedes the read by <span class="InlineEquation" id="IEq291">\(p_j\)</span>. This possibility is not allowed by a 1-atomic register. Thus, <em class="EmphasisTypeItalic ">r</em> is not a 1-atomic register. <span class="InlineEquation" id="IEq292">\(\square \)</span> </p></div><p id="Par134" class="Para">We notice that Construction¬†<span class="InternalRef"><a href="#FPar39">8.2</a></span> can be used for implementing a 2-atomic register from <em class="EmphasisTypeItalic ">k</em>-atomic registers. It would be interesting to find a similar simple and efficient construction also for implementing 1-atomic register from <em class="EmphasisTypeItalic ">k</em>-atomic registers.</p></section><section id="Sec18" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">8.3 </span>Main result regarding relaxed registers</h3><p id="Par135" class="Para">Our result is about computability of using <em class="EmphasisTypeItalic ">k</em>-registers. We show that for every <span class="InlineEquation" id="IEq293">\(k\ge 1\)</span>, <em class="EmphasisTypeItalic ">k</em>-safe registers and 1-atomic registers have the same computational power. More precisely, it is possible to wait-free implement multi-writer multi-reader multi-valued 1-atomic registers using single-writer single-reader <em class="EmphasisTypeItalic ">k</em>-safe bits, for every <span class="InlineEquation" id="IEq294">\(k\ge 1\)</span>.</p><div id="FPar42" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Theorem 8</strong> </span></h3><p id="Par136" class="Para">For every <span class="InlineEquation" id="IEq295">\(k\ge 1\)</span>, it is possible to construct a MWMR 1-atomic register using SWSR <em class="EmphasisTypeItalic ">k</em>-safe bits.</p></div><div id="FPar43" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <em class="EmphasisTypeItalic ">Proof</em> </span></h3><p id="Par137" class="Para">It follows from Constructions¬†<span class="InternalRef"><a href="#FPar36">8.1</a></span> and <span class="InternalRef"><a href="#FPar39">8.2</a></span> that it is possible to implement a SWMR 1-safe bit using SWSR <em class="EmphasisTypeItalic ">k</em>-safe bits. A well known result is that it is possible to implement a MWMR multi-valued 1-atomic register from SWMR 1-safe bits (see Chapter 4 of [<span class="CitationRef"><a href="#CR10">10</a></span>]). The result follows.<sup><a href="#Fn6" id="Fn6_source">6</a></sup> <span class="InlineEquation" id="IEq296">\(\square \)</span> </p></div><p id="Par139" class="Para">For <span class="InlineEquation" id="IEq297">\(k\ge 1\)</span>, the object <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†<em class="EmphasisTypeItalic ">k</em>] is exactly a <em class="EmphasisTypeItalic ">k</em>-atomic register. Thus, the following corollary follows immediately from Theorem <span class="InternalRef"><a href="#FPar42">8</a></span>:</p><div id="FPar44" class="FormalPara FormalParaRenderingStyle1"><h3 class="u-regular"><span class="Heading"> <strong class="EmphasisTypeBold ">Corollary 5</strong> </span></h3><p id="Par140" class="Para">For every <span class="InlineEquation" id="IEq298">\(k\ge 1\)</span>, a <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†1] object can be implemented from <em class="EmphasisTypeItalic ">stack</em>[1,¬†0,¬†<em class="EmphasisTypeItalic ">k</em>] objects.</p></div><p id="Par141" class="Para">There are several classical synchronization algorithms, such as a mutual exclusion algorithm and a <span class="InlineEquation" id="IEq299">\(\ell \)</span>-exclusion algorithm, that only use SWMR 1-safe registers, for interprocess communication [<span class="CitationRef"><a href="#CR30">30</a></span>]. Using Construction¬†<span class="InternalRef"><a href="#FPar39">8.2</a></span>, such algorithms can be very easily and efficiently modified to use only <em class="EmphasisTypeItalic ">k</em>-safe registers, for every <span class="InlineEquation" id="IEq300">\(k\ge 1\)</span>. Examples of such modifications can be found in [<span class="CitationRef"><a href="#CR31">31</a></span>].</p></section><section id="Sec19" tabindex="-1" class="Section2 RenderAsSection2"><h3 class="Heading"><span class="HeadingNumber">8.4 </span>Practical implications</h3><p id="Par142" class="Para">Various optimizations enable reordering memory references as it allows much better performance. When a correct operation depends on ordered memory references, memory barriers are used to prevent reordering [<span class="CitationRef"><a href="#CR22">22</a></span>, <span class="CitationRef"><a href="#CR23">23</a></span>]. Memory barriers are required to enable good performance and scalability. The reason for that is the fact that CPUs are orders of magnitude faster than are both the interconnects between them and the memory they are attempting to access [<span class="CitationRef"><a href="#CR24">24</a></span>].</p><p id="Par143" class="Para">Without using memory barriers, as a result of reordering, a read from an atomic register may obtain some older value when compared to the value this read would return in the in order execution of the original program code. Suppose that in some setting where reordering is possible, a read may obtain, in the worst case, one of the 5 most recently written values when compared to the value it would return in the in order execution. In such a case, no harm done, if the program which uses 1-atomic registers, was designed in the first place to work correctly assuming that communication is done via 5-atomic registers.</p><p id="Par144" class="Para">Consider the following design strategy: Design your algorithms to be correct when <em class="EmphasisTypeItalic ">k</em>-atomic registers are used for some <span class="InlineEquation" id="IEq301">\(k&gt;1\)</span>. Now replace the <em class="EmphasisTypeItalic ">k</em>-atomic registers with the stronger 1-atomic registers. In such algorithms the use of memory barriers may not be necessary in some cases, even when reordering is possible. Thus, there is a tradeoff between the number of memory barriers needed to ensure correctness and the type of <em class="EmphasisTypeItalic ">k</em>-registers used. Put another way, proving correctness w.r.t. <em class="EmphasisTypeItalic ">k</em>-registers while actually using 1-registers provides some level of resiliency against memory reordering. Finding the exact level of resiliency provided using such a design strategy, as a function of <em class="EmphasisTypeItalic ">k</em>, is an interesting research topic which is not covered in this paper.</p></section></div></section><section id="Sec20" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">9 </span>Related work</h2><div class="content"><p id="Par145" class="Para">The design of concurrent data structures has been extensively studied¬†[<span class="CitationRef"><a href="#CR10">10</a></span>, <span class="CitationRef"><a href="#CR30">30</a></span>]. However, there are limitations in achieving high scalability in their design [<span class="CitationRef"><a href="#CR4">4</a></span>, <span class="CitationRef"><a href="#CR6">6</a></span>]. Two progress conditions that have been proposed for data structures which avoid locking are wait-freedom [<span class="CitationRef"><a href="#CR11">11</a></span>] (defined earlier), and obstruction-freedom [<span class="CitationRef"><a href="#CR12">12</a></span>]. Obstruction-freedom, a weak form of implementations that do not use locks, guarantees that an active process will be able to complete its pending operations in a finite number of its own steps, if all the other processes ‚Äúhold still‚Äù long enough.</p><p id="Par146" class="Para">It is shown in [<span class="CitationRef"><a href="#CR4">4</a></span>] that the worst-case operation time complexity of obstruction-free implementations is high, even in the absence of step contention. In [<span class="CitationRef"><a href="#CR6">6</a></span>], an <span class="InlineEquation" id="IEq302">\(\Omega (n)\)</span> lower bound is proven on the time to perform a single instance of an operation in any implementation of a large class of data structures shared by <em class="EmphasisTypeItalic ">n</em> processes, such as counters, stacks, and queues. It is suggested in [<span class="CitationRef"><a href="#CR6">6</a></span>] that ‚Äúit might be beneficial to replace linearizable implementations of strongly ordered data structures, such as stacks and queues, with more relaxed data structures, such as pools and bags‚Äù.</p><p id="Par147" class="Para">In [<span class="CitationRef"><a href="#CR27">27</a></span>], it is pointed out that concurrent data structures will have to go through a substantial ‚Äúrelaxation process‚Äù in order to support scalability: ‚ÄúThe data structures of our childhood‚Äîstacks, queues, and heaps‚Äîwill soon disappear, replaced by looser <em class="EmphasisTypeItalic ">unordered</em> concurrent constructs based on distribution and randomization‚Äù. A few examples are given in [<span class="CitationRef"><a href="#CR27">27</a></span>] showing how relaxing a stack‚Äôs LIFO ordering guarantees can result in higher performance and greater scalability.</p><p id="Par148" class="Para">Another approach to weaken the requirement of traditional data structures is not to change at all the definition of the data structures, but rather to relax the traditional correctness requirements (i.e., linearizability¬†[<span class="CitationRef"><a href="#CR14">14</a></span>] and sequential consistency [<span class="CitationRef"><a href="#CR17">17</a></span>]). A tutorial which describes many issues related to memory consistency models can be found in [<span class="CitationRef"><a href="#CR1">1</a></span>]. In the context of relaxing the consistency condition linearizability [<span class="CitationRef"><a href="#CR14">14</a></span>], two relaxations of a queue were presented in [<span class="CitationRef"><a href="#CR3">3</a></span>]. In [<span class="CitationRef"><a href="#CR16">16</a></span>], a <em class="EmphasisTypeItalic ">k</em>-FIFO queue was implemented, which may dequeue elements out of FIFO order up to a constant <span class="InlineEquation" id="IEq303">\(k\ge 0\)</span>. There are various implementations of relaxed data structures where insertion-order is of no importance, such as pools and bags, see for example [<span class="CitationRef"><a href="#CR2">2</a></span>, <span class="CitationRef"><a href="#CR29">29</a></span>]. In [<span class="CitationRef"><a href="#CR9">9</a></span>], a systematic and formal framework is presented for obtaining new data structures by quantitatively relaxing existing ones.</p><p id="Par149" class="Para">The relative power of various shared objects has been studied extensively in shared memory environments where processes may fail benignly, and where every operation is wait-free. In [<span class="CitationRef"><a href="#CR11">11</a></span>], a hierarchy of progressively stronger shared objects, is defined. Objects at each level are able to perform tasks which are impossible for objects at the lower levels.</p><p id="Par150" class="Para">The consensus problem was defined in [<span class="CitationRef"><a href="#CR25">25</a></span>]. The impossibility result that there is no consensus algorithm that can tolerate even a single crash failure was first proved for the asynchronous message-passing model in [<span class="CitationRef"><a href="#CR7">7</a></span>], and later has been extended for the shared memory model with atomic registers in [<span class="CitationRef"><a href="#CR21">21</a></span>]. The impossibility result that, for <span class="InlineEquation" id="IEq304">\(1\le k\le n-1\)</span> there is no <em class="EmphasisTypeItalic ">k</em>-resilient <em class="EmphasisTypeItalic ">k</em>-set-consensus algorithm for <em class="EmphasisTypeItalic ">n</em> processes using atomic registers, is from [<span class="CitationRef"><a href="#CR5">5</a></span>, <span class="CitationRef"><a href="#CR13">13</a></span>, <span class="CitationRef"><a href="#CR26">26</a></span>] (set-consensus is defined in Sect. <span class="InternalRef"><a href="#Sec13">6</a></span>). It is shown in [<span class="CitationRef"><a href="#CR11">11</a></span>] that traditional data types, such as sets which support insert and remove operations, queues which support enqueue and dequeue operations (i.e., <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†0]), stacks which supports push and pop operations (i.e., <em class="EmphasisTypeItalic ">stack</em>[1,¬†1,¬†0]), all have consensus number exactly two. In the proofs of [<span class="CitationRef"><a href="#CR11">11</a></span>], it is assumed that the data structures are initialized. The same results also hold for the case of uninitialized data structures [<span class="CitationRef"><a href="#CR15">15</a></span>, <span class="CitationRef"><a href="#CR30">30</a></span>]. It is trivial to show that <span class="InlineEquation" id="IEq305">\(CN(queue[1,1,1]) = \infty \)</span>.</p><p id="Par151" class="Para">A formalism for reasoning about concurrent systems which does not assume that read and write are atomic operations is developed in [<span class="CitationRef"><a href="#CR18">18</a></span>, <span class="CitationRef"><a href="#CR19">19</a></span>]. This formalism has been further developed in [<span class="CitationRef"><a href="#CR20">20</a></span>], where it is used to specify several classes of interprocess communication mechanism and to prove correctness of algorithms for implementing them. In particular, a very weak form of (non-atomic) shared register, called <em class="EmphasisTypeItalic ">safe</em> register, is defined [<span class="CitationRef"><a href="#CR20">20</a></span>]. A safe register can be written and read concurrently, but read errors may occur during the writing of a shared register. Following the publication of [<span class="CitationRef"><a href="#CR20">20</a></span>], many papers were published about implementing one type of shared register from another. In particular it is now known how to implement a MWMR atomic register from SWSR safe bits. A compilation of some of these results can be found in Chapter 4 of [<span class="CitationRef"><a href="#CR10">10</a></span>]. A discussion on how memory barriers are used to prevent reordering can be found in [<span class="CitationRef"><a href="#CR22">22</a></span>, <span class="CitationRef"><a href="#CR23">23</a></span>, <span class="CitationRef"><a href="#CR24">24</a></span>].</p></div></section><section id="Sec21" tabindex="-1" class="Section1 RenderAsSection1"><h2 class="Heading"><span class="HeadingNumber">10 </span>Discussion</h2><div class="content"><p id="Par152" class="Para">Synchronization inherently limits parallelism. As a result, there is a recent trend towards implementing semantically weaker data structures which reduce the need for synchronization and thus achieve better performance and scalability. We have considered infinitely many possible relaxations of queues and stacks, and examined their relative computational power by determining their consensus numbers. We have also introduced the new notions of <em class="EmphasisTypeItalic ">k</em>-safe, <em class="EmphasisTypeItalic ">k</em>-regular and <em class="EmphasisTypeItalic ">k</em>-atomic registers, and showed how to implement 1-atomic registers (the strongest type) in terms of <em class="EmphasisTypeItalic ">k</em>-safe registers (the weakest type).</p><p id="Par153" class="Para">Our results demonstrate, somewhat surprisingly, that each one of the infinitely many relaxed objects considered has one of the following three consensus numbers: 1, 2 or <span class="InlineEquation" id="IEq306">\(\infty \)</span>. Another conclusion is that a queue is more sensitive than a stack to changes in its semantics. It would be interesting to extend our results to other data structures. Various limitations in achieving high scalability in the design of traditional data structures have been demonstrated in [<span class="CitationRef"><a href="#CR4">4</a></span>, <span class="CitationRef"><a href="#CR6">6</a></span>]. Can these results be extended to cover some of the relaxed data structures presented in this paper?</p><p id="Par154" class="Para">It would be interesting to find out the internal structure among relaxed objects in the same level of the consensus hierarchy. In particular, for <span class="InlineEquation" id="IEq307">\(i\in Z^+\)</span>, is it possible to implement a <span class="InlineEquation" id="IEq308">\(queue[1,1,i+1]\)</span> object using <span class="InlineEquation" id="IEq309">\(queue[1,1,i+2]\)</span> objects and registers? Is it possible to implement a <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†2] object using <em class="EmphasisTypeItalic ">queue</em>[1,¬†1,¬†0] objects and registers?</p></div></section><section id="Footnotes" class="FootnoteSection Section1 RenderAsSection1"><h2 class="Heading">Footnotes</h2><div class="content"><ol><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn1_source">1</a>.</span><div class="FootnoteContent" id="Fn1"><p id="Par8" class="Para">The enqueue operation inserts a value to the queue and the dequeue operation returns and removes the oldest value in the queue. That is, the values are dequeued in the order in which they were enqueued. The <em class="EmphasisTypeItalic ">peek</em> operation reads the oldest value in the queue without removing it. If the queue is empty the dequeue and the peek operations return a special symbol.</p></div></li><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn2_source">2</a>.</span><div class="FootnoteContent" id="Fn2"><p id="Par10" class="Para">A position of an item in a queue or in a stack is simply the number of items which precede it plus one.</p></div></li><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn3_source">3</a>.</span><div class="FootnoteContent" id="Fn3"><p id="Par48" class="Para">To our surprise, we could not find any publication in which it is claimed that <span class="InlineEquation" id="IEq87">\(CN(stack[1,1,1]) = 2\)</span>. Nevertheless, we consider it as a known result.</p></div></li><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn4_source">4</a>.</span><div class="FootnoteContent" id="Fn4"><p id="Par65" class="Para">This is false, if the queue initially contains one element. In such a case, two processes can solve consensus, by deciding on the input of the process that successfully dequeues the element.</p></div></li><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn5_source">5</a>.</span><div class="FootnoteContent" id="Fn5"><p id="Par95" class="Para">Notice that we reach a contradiction, by assuming that <em class="EmphasisTypeItalic ">p</em>‚Äôs peek operation returns the first element in both passes. Since this implies that it cannot be the case that both events by <em class="EmphasisTypeItalic ">p</em> and <em class="EmphasisTypeItalic ">q</em> are <em class="EmphasisTypeItalic ">peek</em> events, there is no need to consider the sub-case where <em class="EmphasisTypeItalic ">p</em>‚Äôs peek operation returns the first element in one path and the second element is the other path.</p></div></li><li class="Footnote"><span class="FootnoteNumber"><a href="#Fn6_source">6</a>.</span><div class="FootnoteContent" id="Fn6"><p id="Par138" class="Para">The known constructions of a MWMR multi-valued 1-atomic register from SWMR 1-safe bits, are complicated and are not practically useful for transforming algorithms that use strong type of registers into algorithms that use weak type of registers.</p></div></li></ol></div></section></div><section id="Notes" class="Section1 RenderAsSection1"><h2 class="Heading">Notes</h2><div class="content"><section><h3 class="Heading">Acknowledgments</h3><p class="SimplePara">We wish to thank the three anonymous referees and the associate editor Eric Ruppert for their constructive suggestions and corrections. Support is gratefully acknowledged from the National Science Foundation under grants CCF-1217921, CCF-1301926, and IIS-1447786, and the Department of Energy under Grant ER26116/DE-SC0008923.</p></section></div></section><section class="Section1 RenderAsSection1" id="Bib1" tabindex="-1"><h2 class="Heading">References</h2><div class="content"><ol class="BibliographyWrapper"><li class="Citation"><div class="CitationNumber">1.</div><div class="CitationContent" id="CR1">Adve, S.V., Gharachorloo, K.: Shared memory consistency models: a tutorial. IEEE Comput. <strong class="EmphasisTypeBold ">29</strong>(12), 66‚Äì76 (1996)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1109/2.546611"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Shared%20memory%20consistency%20models%3A%20a%20tutorial&amp;author=SV.%20Adve&amp;author=K.%20Gharachorloo&amp;journal=IEEE%20Comput.&amp;volume=29&amp;issue=12&amp;pages=66-76&amp;publication_year=1996"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">2.</div><div class="CitationContent" id="CR2">Afek, Y., Korland, G., Natanzon, M., Shavit, N.: Scalable producer-consumer pools based on elimination-diffraction trees. In: Proceedings of the 16th International Euro-Par Conference on Parallel Processing: Part II, Euro-Par‚Äô10, pp. 151‚Äì162, (2010)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Afek%2C%20Y.%2C%20Korland%2C%20G.%2C%20Natanzon%2C%20M.%2C%20Shavit%2C%20N.%3A%20Scalable%20producer-consumer%20pools%20based%20on%20elimination-diffraction%20trees.%20In%3A%20Proceedings%20of%20the%2016th%20International%20Euro-Par%20Conference%20on%20Parallel%20Processing%3A%20Part%20II%2C%20Euro-Par%E2%80%9910%2C%20pp.%20151%E2%80%93162%2C%20%282010%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">3.</div><div class="CitationContent" id="CR3">Afek, Y., Korland, G., Yanovsky, E.: Quasi-linearizability: relaxed consistency for improved concurrency. In: Proceedings of the 14th International Conference on Principles of Distributed Systems, OPODIS‚Äô10, pp. 395‚Äì410 (2010)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Afek%2C%20Y.%2C%20Korland%2C%20G.%2C%20Yanovsky%2C%20E.%3A%20Quasi-linearizability%3A%20relaxed%20consistency%20for%20improved%20concurrency.%20In%3A%20Proceedings%20of%20the%2014th%20International%20Conference%20on%20Principles%20of%20Distributed%20Systems%2C%20OPODIS%E2%80%9910%2C%20pp.%20395%E2%80%93410%20%282010%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">4.</div><div class="CitationContent" id="CR4">Attiya, H., Guerraoui, R., Hendler, D., Kuznetsov, P.: The complexity of obstruction-free implementations. J. ACM <strong class="EmphasisTypeBold ">56</strong>(4), 1‚Äì33 (2009)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=2590826"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/1538902.1538908"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?1325.68033"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=The%20complexity%20of%20obstruction-free%20implementations&amp;author=H.%20Attiya&amp;author=R.%20Guerraoui&amp;author=D.%20Hendler&amp;author=P.%20Kuznetsov&amp;journal=J.%20ACM&amp;volume=56&amp;issue=4&amp;pages=1-33&amp;publication_year=2009"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">5.</div><div class="CitationContent" id="CR5">Borowsky, E., Gafni, E.: Generalizecl FLP impossibility result for <span class="InlineEquation" id="IEq310">\(t\)</span>-resilient asynchronous computations. In: Proceedings of 25th ACM Symposium on Theory of Computing, pp. 91‚Äì100 (1993)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Borowsky%2C%20E.%2C%20Gafni%2C%20E.%3A%20Generalizecl%20FLP%20impossibility%20result%20for%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24%24t%24%24%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-resilient%20asynchronous%20computations.%20In%3A%20Proceedings%20of%2025th%20ACM%20Symposium%20on%20Theory%20of%20Computing%2C%20pp.%2091%E2%80%93100%20%281993%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">6.</div><div class="CitationContent" id="CR6">Ellen, F., Hendler, D., Shavit, N.: On the inherent sequentiality of concurrent objects. SIAM J. Comput. <strong class="EmphasisTypeBold ">41</strong>(3), 519‚Äì536 (2012)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=2967466"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1137/08072646X"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?1283.68162"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=On%20the%20inherent%20sequentiality%20of%20concurrent%20objects&amp;author=F.%20Ellen&amp;author=D.%20Hendler&amp;author=N.%20Shavit&amp;journal=SIAM%20J.%20Comput.&amp;volume=41&amp;issue=3&amp;pages=519-536&amp;publication_year=2012"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">7.</div><div class="CitationContent" id="CR7">Fischer, M.J., Lynch, N.A., Paterson, M.S.: Impossibility of distributed consensus with one faulty process. J. ACM <strong class="EmphasisTypeBold ">32</strong>(2), 374‚Äì382 (1985)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=831865"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/3149.214121"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0629.68027"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Impossibility%20of%20distributed%20consensus%20with%20one%20faulty%20process&amp;author=MJ.%20Fischer&amp;author=NA.%20Lynch&amp;author=MS.%20Paterson&amp;journal=J.%20ACM&amp;volume=32&amp;issue=2&amp;pages=374-382&amp;publication_year=1985"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">8.</div><div class="CitationContent" id="CR8">Gidron, E., Keidar, I., Perelman, D., Perez, Yonathan Y.: Salsa: scalable and low synchronization numa-aware algorithm for producer-consumer pools. In: Proceeding of 24th Annual ACM Symposium on Parallelism in Algorithms and Architectures, SPAA ‚Äô12, pp. 151‚Äì160 (2012)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Gidron%2C%20E.%2C%20Keidar%2C%20I.%2C%20Perelman%2C%20D.%2C%20Perez%2C%20Yonathan%20Y.%3A%20Salsa%3A%20scalable%20and%20low%20synchronization%20numa-aware%20algorithm%20for%20producer-consumer%20pools.%20In%3A%20Proceeding%20of%2024th%20Annual%20ACM%20Symposium%20on%20Parallelism%20in%20Algorithms%20and%20Architectures%2C%20SPAA%20%E2%80%9912%2C%20pp.%20151%E2%80%93160%20%282012%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">9.</div><div class="CitationContent" id="CR9">Henzinger, T., Kirsch, C., Payer, H., Sezgin, A., Sokolova, A.: Quantitative relaxation of concurrent data structures. SIGPLAN Not. <strong class="EmphasisTypeBold ">48</strong>(1), 317‚Äì328 (2013)<span class="Occurrences"><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?1301.68176"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Quantitative%20relaxation%20of%20concurrent%20data%20structures&amp;author=T.%20Henzinger&amp;author=C.%20Kirsch&amp;author=H.%20Payer&amp;author=A.%20Sezgin&amp;author=A.%20Sokolova&amp;journal=SIGPLAN%20Not.&amp;volume=48&amp;issue=1&amp;pages=317-328&amp;publication_year=2013"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">10.</div><div class="CitationContent" id="CR10">Herlihy, M., Shavit, N.: The Art of Multiprocessor Programming. Morgan Kaufmann Publishers, Burlington (2008)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=The%20Art%20of%20Multiprocessor%20Programming&amp;author=M.%20Herlihy&amp;author=N.%20Shavit&amp;publication_year=2008"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">11.</div><div class="CitationContent" id="CR11">Herlihy, M.P.: Wait-free synchronization. ACM Trans. Program. Lang. Syst. <strong class="EmphasisTypeBold ">13</strong>(1), 124‚Äì149 (1991)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/114005.102808"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Wait-free%20synchronization&amp;author=MP.%20Herlihy&amp;journal=ACM%20Trans.%20Program.%20Lang.%20Syst.&amp;volume=13&amp;issue=1&amp;pages=124-149&amp;publication_year=1991"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">12.</div><div class="CitationContent" id="CR12">Herlihy, M.P., Luchangco, V., Moir, M.: Obstruction-free synchronization: double-ended queues as an example. In: Proceedings of the 23rd International Conference on Distributed Computing Systems, p. 522 (2003)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Herlihy%2C%20M.P.%2C%20Luchangco%2C%20V.%2C%20Moir%2C%20M.%3A%20Obstruction-free%20synchronization%3A%20double-ended%20queues%20as%20an%20example.%20In%3A%20Proceedings%20of%20the%2023rd%20International%20Conference%20on%20Distributed%20Computing%20Systems%2C%20p.%20522%20%282003%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">13.</div><div class="CitationContent" id="CR13">Herlihy, M.P., Shavit, N.: The topological structure of asynchronous computability. J. ACM <strong class="EmphasisTypeBold ">46</strong>(6), 858‚Äì923 (1999)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=1753036"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/331524.331529"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?1161.68469"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=The%20topological%20structure%20of%20asynchronous%20computability&amp;author=MP.%20Herlihy&amp;author=N.%20Shavit&amp;journal=J.%20ACM&amp;volume=46&amp;issue=6&amp;pages=858-923&amp;publication_year=1999"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">14.</div><div class="CitationContent" id="CR14">Herlihy, M.P., Wing, J.M.: Linearizability: a correctness condition for concurrent objects. ACM Trans. Program. Lang. Syst. <strong class="EmphasisTypeBold ">12</strong>(3), 463‚Äì492 (1990)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/78969.78972"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Linearizability%3A%20a%20correctness%20condition%20for%20concurrent%20objects&amp;author=MP.%20Herlihy&amp;author=JM.%20Wing&amp;journal=ACM%20Trans.%20Program.%20Lang.%20Syst.&amp;volume=12&amp;issue=3&amp;pages=463-492&amp;publication_year=1990"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">15.</div><div class="CitationContent" id="CR15">Jayanti, P., Toueg, S.: Some results on the impossibility, universality, and decidability of consensus. In: Proceedings of the 6th International Workshop on Distributed Algorithms: LNCS 674, pp. 69‚Äì84 (1992)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Jayanti%2C%20P.%2C%20Toueg%2C%20S.%3A%20Some%20results%20on%20the%20impossibility%2C%20universality%2C%20and%20decidability%20of%20consensus.%20In%3A%20Proceedings%20of%20the%206th%20International%20Workshop%20on%20Distributed%20Algorithms%3A%20LNCS%20674%2C%20pp.%2069%E2%80%9384%20%281992%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">16.</div><div class="CitationContent" id="CR16">Kirsch, C., Payer, H., R√∂ck, H., Sokolova, A.: Performance, scalability, and semantics of concurrent fifo queues. In: Proceedings of the 12th International Conference on Algorithms and Architectures for Parallel Processing‚ÄîVolume Part I, LNCS 7439, pp. 273‚Äì287 (2012)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Kirsch%2C%20C.%2C%20Payer%2C%20H.%2C%20R%C3%B6ck%2C%20H.%2C%20Sokolova%2C%20A.%3A%20Performance%2C%20scalability%2C%20and%20semantics%20of%20concurrent%20fifo%20queues.%20In%3A%20Proceedings%20of%20the%2012th%20International%20Conference%20on%20Algorithms%20and%20Architectures%20for%20Parallel%20Processing%E2%80%94Volume%20Part%20I%2C%20LNCS%207439%2C%20pp.%20273%E2%80%93287%20%282012%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">17.</div><div class="CitationContent" id="CR17">Lamport, L.: How to make a multiprocessor computer that correctly executes multiprocess programs. IEEE Trans. Comput. <strong class="EmphasisTypeBold ">28</strong>(9), 690‚Äì691 (1979)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1109/TC.1979.1675439"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0419.68045"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=How%20to%20make%20a%20multiprocessor%20computer%20that%20correctly%20executes%20multiprocess%20programs&amp;author=L.%20Lamport&amp;journal=IEEE%20Trans.%20Comput.&amp;volume=28&amp;issue=9&amp;pages=690-691&amp;publication_year=1979"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">18.</div><div class="CitationContent" id="CR18">Lamport, L.: The mutual exclusion problem: part I‚Äîa theory of interprocess communication. J. ACM <strong class="EmphasisTypeBold ">33</strong>, 313‚Äì326 (1986)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=835107"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/5383.5384"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0627.68017"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=The%20mutual%20exclusion%20problem%3A%20part%20I%E2%80%94a%20theory%20of%20interprocess%20communication&amp;author=L.%20Lamport&amp;journal=J.%20ACM&amp;volume=33&amp;pages=313-326&amp;publication_year=1986"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">19.</div><div class="CitationContent" id="CR19">Lamport, L.: The mutual exclusion problem: part II‚Äîstatement and solutions. J. ACM <strong class="EmphasisTypeBold ">33</strong>, 327‚Äì348 (1986)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=835108"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/5383.5385"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0627.68018"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=The%20mutual%20exclusion%20problem%3A%20part%20II%E2%80%94statement%20and%20solutions&amp;author=L.%20Lamport&amp;journal=J.%20ACM&amp;volume=33&amp;pages=327-348&amp;publication_year=1986"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">20.</div><div class="CitationContent" id="CR20">Lamport, L.: On interprocess communication, parts I and II. Distrib. Comput. <strong class="EmphasisTypeBold ">1</strong>(2), 77‚Äì101 (1986)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1007/BF01786227"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0598.68022"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=On%20interprocess%20communication%2C%20parts%20I%20and%20II&amp;author=L.%20Lamport&amp;journal=Distrib.%20Comput.&amp;volume=1&amp;issue=2&amp;pages=77-101&amp;publication_year=1986"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">21.</div><div class="CitationContent" id="CR21">Loui, M.C., Abu-Amara, H.: Memory requirements for agreement among unreliable asynchronous processes. Adv. Comput. Res. <strong class="EmphasisTypeBold ">4</strong>, 163‚Äì183 (1987)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=943407"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Memory%20requirements%20for%20agreement%20among%20unreliable%20asynchronous%20processes&amp;author=MC.%20Loui&amp;author=H.%20Abu-Amara&amp;journal=Adv.%20Comput.%20Res.&amp;volume=4&amp;pages=163-183&amp;publication_year=1987"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">22.</div><div class="CitationContent" id="CR22">McKenney, P.E.: Memory ordering in modern microprocessors, part i. Linux J. <strong class="EmphasisTypeBold ">136</strong>, 2 (2005). (Revised April 2009.)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Memory%20ordering%20in%20modern%20microprocessors%2C%20part%20i&amp;author=PE.%20McKenney&amp;journal=Linux%20J.&amp;volume=136&amp;pages=2&amp;publication_year=2005"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">23.</div><div class="CitationContent" id="CR23">McKenney, P.E.: Memory ordering in modern microprocessors, part ii. Linux J. <strong class="EmphasisTypeBold ">137</strong>, 2 (2005). (Revised April 2009.)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Memory%20ordering%20in%20modern%20microprocessors%2C%20part%20ii&amp;author=PE.%20McKenney&amp;journal=Linux%20J.&amp;volume=137&amp;pages=2&amp;publication_year=2005"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">24.</div><div class="CitationContent" id="CR24">Mckenney, P.E.: Memory barriers: a hardware view for software hackers (2009, unpublished)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Mckenney%2C%20P.E.%3A%20Memory%20barriers%3A%20a%20hardware%20view%20for%20software%20hackers%20%282009%2C%20unpublished%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">25.</div><div class="CitationContent" id="CR25">Pease, M., Shostak, R., Lamport, L.: Reaching agreement in the presence of faults. J. ACM <strong class="EmphasisTypeBold ">27</strong>(2), 228‚Äì234 (1980)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Pease%2C%20M.%2C%20Shostak%2C%20R.%2C%20Lamport%2C%20L.%3A%20Reaching%20agreement%20in%20the%20presence%20of%20faults.%20J.%20ACM%2027%282%29%2C%20228%E2%80%93234%20%281980%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">26.</div><div class="CitationContent" id="CR26">Saks, M., Zaharoglou, F.: Wait-free <span class="InlineEquation" id="IEq312">\(k\)</span>-set agreement is impossible: the topology of public knowledge. SIAM J. Comput. <strong class="EmphasisTypeBold ">29</strong>, 1449‚Äì1483 (2000)<span class="Occurrences"><span class="Occurrence OccurrenceAMSID"><a class="gtm-reference" data-reference-type="MathSciNet" target="_blank" rel="noopener" href="http://www.ams.org/mathscinet-getitem?mr=1744832"><span><span>MathSciNet</span></span></a></span><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1137/S0097539796307698"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceZLBID"><a class="gtm-reference" data-reference-type="MATH" target="_blank" rel="noopener" href="http://www.emis.de/MATH-item?0952.68159"><span><span>zbMATH</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Wait-free%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24%24k%24%24%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20k%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-set%20agreement%20is%20impossible%3A%20the%20topology%20of%20public%20knowledge&amp;author=M.%20Saks&amp;author=F.%20Zaharoglou&amp;journal=SIAM%20J.%20Comput.&amp;volume=29&amp;pages=1449-1483&amp;publication_year=2000"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">27.</div><div class="CitationContent" id="CR27">Shavit, N.: Data structures in the multicore age. Commun. ACM <strong class="EmphasisTypeBold ">54</strong>(3), 76‚Äì84 (2011)<span class="Occurrences"><span class="Occurrence OccurrenceDOI"><a class="gtm-reference" data-reference-type="CrossRef" target="_blank" rel="noopener" href="https://doi.org/10.1145/1897852.1897873"><span><span>CrossRef</span></span></a></span><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Data%20structures%20in%20the%20multicore%20age&amp;author=N.%20Shavit&amp;journal=Commun.%20ACM&amp;volume=54&amp;issue=3&amp;pages=76-84&amp;publication_year=2011"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">28.</div><div class="CitationContent" id="CR28">Shavit, N., Taubenfeld, G.: The computability of relaxed data structures: queues and stacks as examples. In: 22nd International Colloquium on Structural Information and Communication Complexity (SIROCCO 2015) (July 2015)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Shavit%2C%20N.%2C%20Taubenfeld%2C%20G.%3A%20The%20computability%20of%20relaxed%20data%20structures%3A%20queues%20and%20stacks%20as%20examples.%20In%3A%2022nd%20International%20Colloquium%20on%20Structural%20Information%20and%20Communication%20Complexity%20%28SIROCCO%202015%29%20%28July%202015%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">29.</div><div class="CitationContent" id="CR29">Sundell, H., Gidenstam, A., Papatriantafilou, M., Tsigas, P.: A lock-free algorithm for concurrent bags. In: Proceedings of the Twenty-third Annual ACM Symposium on Parallelism in Algorithms and Architectures, SPAA ‚Äô11, pp. 335‚Äì344 (2011)<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="https://scholar.google.com/scholar?q=Sundell%2C%20H.%2C%20Gidenstam%2C%20A.%2C%20Papatriantafilou%2C%20M.%2C%20Tsigas%2C%20P.%3A%20A%20lock-free%20algorithm%20for%20concurrent%20bags.%20In%3A%20Proceedings%20of%20the%20Twenty-third%20Annual%20ACM%20Symposium%20on%20Parallelism%20in%20Algorithms%20and%20Architectures%2C%20SPAA%20%E2%80%9911%2C%20pp.%20335%E2%80%93344%20%282011%29"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">30.</div><div class="CitationContent" id="CR30">Taubenfeld, G.: Synchronization Algorithms and Concurrent Programming. Pearson / Prentice-Hall, Upper Saddle River (2006). ISBN 0-131-97259-6<span class="Occurrences"><span class="Occurrence OccurrenceGS"><a target="_blank" rel="noopener" class="google-scholar-link gtm-reference" data-reference-type="Google Scholar" href="http://scholar.google.com/scholar_lookup?title=Synchronization%20Algorithms%20and%20Concurrent%20Programming&amp;author=G.%20Taubenfeld&amp;publication_year=2006"><span><span>Google Scholar</span></span></a></span></span></div></li><li class="Citation"><div class="CitationNumber">31.</div><div class="CitationContent" id="CR31">Taubenfeld, G.: Weak read/write registers. In: 14th International Conference on Distributed Computing and Networking (ICDCN 2013), January 2013. <em class="EmphasisTypeItalic ">LNCS 7730</em> Springer Verlag 2013, 423‚Äì427. Full version is avaliable at: <span class="ExternalRef"><a target="_blank" rel="noopener" href="http://www.faculty.idc.ac.il/gadi/Publications.htm"><span class="RefSource">http://www.faculty.idc.ac.il/gadi/Publications.htm</span></a></span>
                        <span class="Occurrences"></span></div></li></ol></div></section><section class="Section1 RenderAsSection1"><h2 class="Heading" id="copyrightInformation">Copyright information</h2><div class="ArticleCopyright content"><div class="ArticleCopyright">¬©¬†Springer-Verlag Berlin Heidelberg¬†2016</div></div></section><section id="authorsandaffiliations" class="Section1 RenderAsSection1"><h2 class="Heading">Authors and Affiliations</h2><div class="content authors-affiliations u-interface"><ul class="test-contributor-names"><li itemscope="" itemtype="http://schema.org/Person" class="u-mb-2 u-pt-4 u-pb-4"><span itemprop="name" class="authors-affiliations__name">Nir¬†Shavit</span><ul class="authors-affiliations__indexes u-inline-list" data-role="AuthorsIndexes"><li data-affiliation="affiliation-1">1</li><li data-affiliation="affiliation-2">2</li></ul></li><li itemscope="" itemtype="http://schema.org/Person" class="u-mb-2 u-pt-4 u-pb-4"><span itemprop="name" class="authors-affiliations__name">Gadi¬†Taubenfeld</span><ul class="authors-affiliations__indexes u-inline-list" data-role="AuthorsIndexes"><li data-affiliation="affiliation-3">3</li></ul><span class="author-information"><span class="author-information__contact u-icon-before"><a href="mailto:tgadi@idc.ac.il" title="tgadi@idc.ac.il" itemprop="email" data-track="click" data-track-action="Email author" data-track-label="">Email author</a></span></span></li></ul><ol class="test-affiliations"><li class="affiliation" data-test="affiliation-1" data-affiliation-highlight="affiliation-1" itemscope="" itemtype="http://schema.org/Organization"><span class="affiliation__count">1.</span><span class="affiliation__item"><span itemprop="name" class="affiliation__name">MIT</span><span itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress" class="affiliation__address"><span itemprop="addressRegion" class="affiliation__city">Cambridge</span><span itemprop="addressCountry" class="affiliation__country">USA</span></span></span></li><li class="affiliation" data-test="affiliation-2" data-affiliation-highlight="affiliation-2" itemscope="" itemtype="http://schema.org/Organization"><span class="affiliation__count">2.</span><span class="affiliation__item"><span itemprop="name" class="affiliation__name">Tel-Aviv University</span><span itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress" class="affiliation__address"><span itemprop="addressRegion" class="affiliation__city">Tel Aviv</span><span itemprop="addressCountry" class="affiliation__country">Israel</span></span></span></li><li class="affiliation" data-test="affiliation-3" data-affiliation-highlight="affiliation-3" itemscope="" itemtype="http://schema.org/Organization"><span class="affiliation__count">3.</span><span class="affiliation__item"><span itemprop="name" class="affiliation__name">The Interdisciplinary Center</span><span itemprop="address" itemscope="" itemtype="http://schema.org/PostalAddress" class="affiliation__address"><span itemprop="addressRegion" class="affiliation__city">Herzliya</span><span itemprop="addressCountry" class="affiliation__country">Israel</span></span></span></li></ol></div></section></div>
                        </article>
                        <aside class="section section--collapsible" id="AboutThisContent">
    <h2 class="section__heading" id="aboutcontent">About this article</h2>
    <div class="section__content bibliographic-information">
                <div id="crossMark" class="crossmark">
            <a data-crossmark="10.1007%2Fs00446-016-0272-0" target="_blank" rel="noopener" href="https://crossmark.crossref.org/dialog/?doi=10.1007%2Fs00446-016-0272-0" title="Verify currency and authenticity via CrossMark" data-track="click" data-track-action="Crossmark" data-track-label="">
                <span class="u-screenreader-only">CrossMark</span>
                <svg class="CrossMark" id="crossmark-icon" width="57" height="81">
                    <image width="57" height="81" alt="Verify currency and authenticity via CrossMark" src="/springerlink-static/632953562/images/png/crossmark.png" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/springerlink-static/632953562/images/svg/crossmark.svg"></image>
                </svg>
            </a>
        </div>

        <div class="crossmark__adjacent">
            <dl class="citation-info u-highlight-target u-mb-16" id="citeas" tabindex="-1">
    <dt class="test-cite-heading">
        Cite this article as:
    </dt>
    <dd id="citethis-text">Shavit, N. & Taubenfeld, G. Distrib. Comput. (2016) 29: 395. https://doi.org/10.1007/s00446-016-0272-0</dd>
</dl>
                <ul class="bibliographic-information__list bibliographic-information__list--inline">
        <li class="bibliographic-information__item">
            <span class="bibliographic-information__title">Received</span>
            <span class="bibliographic-information__value u-overflow-wrap">19 August 2015</span>
        </li>
        <li class="bibliographic-information__item">
            <span class="bibliographic-information__title">Accepted</span>
            <span class="bibliographic-information__value u-overflow-wrap">04 April 2016</span>
        </li>
        <li class="bibliographic-information__item">
            <span class="bibliographic-information__title">First Online</span>
            <span class="bibliographic-information__value u-overflow-wrap">26 April 2016</span>
        </li>
        <li class="bibliographic-information__item">
            <span class="bibliographic-information__title">DOI</span>
            <span class="bibliographic-information__value u-overflow-wrap" id="doi-url">https://doi.org/10.1007/s00446-016-0272-0</span>
        </li>
            <li class="bibliographic-information__item">
                <span class="bibliographic-information__title">Publisher Name</span>
                <span class="bibliographic-information__value" id="publisher-name">Springer Berlin Heidelberg</span>
            </li>
            <li class="bibliographic-information__item">
                <span class="bibliographic-information__title">Print ISSN</span>
                <span class="bibliographic-information__value" id="print-issn">0178-2770</span>
            </li>
            <li class="bibliographic-information__item">
                <span class="bibliographic-information__title">Online ISSN</span>
                <span class="bibliographic-information__value" id="electronic-issn">1432-0452</span>
            </li>

        
    </ul>

            <ul class="bibliographic-information__list">
        <li class="bibliographic-information__item">
            <a id="about-journal" class="bibliographic-information__misc-links"
               title="Visit Springer.com for information about this article&#39;s journal"
               href="//www.springer.com/journal/446/about">About this journal</a>
        </li>
        <li class="bibliographic-information__item">
            <a id="reprintsandpermissions-link" target="_blank" rel="noopener" href="https://s100.copyright.com/AppDispatchServlet?publisherName&#x3D;SpringerNature&amp;orderBeanReset&#x3D;true&amp;orderSource&#x3D;SpringerLink&amp;copyright&#x3D;Springer-Verlag+Berlin+Heidelberg&amp;author&#x3D;Nir+Shavit%2C+Gadi+Taubenfeld&amp;issueNum&#x3D;5&amp;contentID&#x3D;10.1007%2Fs00446-016-0272-0&amp;endPage&#x3D;407&amp;publicationDate&#x3D;2016&amp;startPage&#x3D;395&amp;volumeNum&#x3D;29&amp;title&#x3D;The+computability+of+relaxed+data+structures%3A+queues+and+stacks+as+examples&amp;imprint&#x3D;Springer-Verlag+Berlin+Heidelberg&amp;publication&#x3D;0178-2770" title="Visit RightsLink for information about reusing this article" data-track="click" data-track-action="Reprints and Permissions" data-track-label="">Reprints and Permissions</a>
        </li>
</ul>



        </div>
      
      
          
    </div>
</aside>

                        <div class="section section--collapsible uptodate-recommendations gtm-recommendations">
    <h2 class="uptodate-recommendations__title section__heading gtm-recommendations__title" id="uptodaterecommendations">Personalised recommendations</h2>
    <div class="section__content">
        <div class="uptodate-recommendations__container">
             <link rel="uptodate-inline" href="/springerlink-static/632953562/css/recommendations.css"/>
        </div>
    </div>
</div>
                                <div id="doubleclick-native-ad" data-component="SpringerLink.GoogleAds" data-namespace="native"></div>

                                    <div class="sticky-banner 
            u-interface u-js-screenreader-only" aria-hidden="true" data-component="SpringerLink.StickyBanner" data-namespace="hasButton">
                <div class="sticky-banner__container">
                        <div class="citations" data-component="SV.Dropdown" data-namespace="citationsSticky">
        <h3 class="u-h4" data-role="button-dropdown__title">
    <span>Cite</span>
    <span class="hide-text-small">article</span>
</h3>
<ul class="citations__content" data-role="button-dropdown__content">
    <li>
        <a href="#citeas" data-track="click" data-track-action="Cite as link" data-track-label="Cite dropdown">How to cite?</a>
    </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;refman&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .RIS file" data-track="click" data-track-action="Export citation" data-track-label="RIS">
                <span class="citations__extension" data-gtmlabel="RIS">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .RIS
                </span>
                <span class="citations__types">
                        <span>
                            Papers
                        </span>
                        <span>
                            Reference Manager
                        </span>
                        <span>
                            RefWorks
                        </span>
                        <span>
                            Zotero
                        </span>
                </span>
            </a>
        </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;endnote&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .ENW file" data-track="click" data-track-action="Export citation" data-track-label="ENW">
                <span class="citations__extension" data-gtmlabel="ENW">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .ENW
                </span>
                <span class="citations__types">
                        <span>
                            EndNote
                        </span>
                </span>
            </a>
        </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;bibtex&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .BIB file" data-track="click" data-track-action="Export citation" data-track-label="BIB">
                <span class="citations__extension" data-gtmlabel="BIB">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .BIB
                </span>
                <span class="citations__types">
                        <span>
                            BibTeX
                        </span>
                        <span>
                            JabRef
                        </span>
                        <span>
                            Mendeley
                        </span>
                </span>
            </a>
        </li>
</ul>
    </div>

                            <div>
        <a class="c-button share-this test-shareby-sharelink-link" data-test="shareable-link" target="_blank" rel="noopener" href="/sharelink/10.1007/s00446-016-0272-0" data-track="click" data-track-action="Share via" data-track-label="ShareLink">
            <span>Share</span>
            <span class="hide-text-small">article</span>
        </a>
    </div>




                                    <div>
            <a href="/content/pdf/10.1007%2Fs00446-016-0272-0.pdf" target="_blank" class="c-button c-button--blue c-button__icon-right" title="Download this article in PDF format" rel="noopener" data-track="click" data-track-action="Pdf download" data-track-label="">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" version="1.1"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill="#fff"><g transform="translate(12.000000, 5.000000)"><path d="M7 7.3L7 1C7 0.4 6.6 0 6 0 5.4 0 5 0.4 5 1L5 7.3 3.5 5.7C3.1 5.3 2.5 5.3 2.1 5.7L2.1 5.7C1.7 6.1 1.7 6.7 2.1 7.1L5.3 10.3C5.7 10.7 6.3 10.7 6.7 10.3L9.9 7.1C10.3 6.7 10.3 6.1 9.9 5.7L9.9 5.7C9.5 5.3 8.9 5.3 8.5 5.7L7 7.3 7 7.3ZM0 13C0 12.4 0.5 12 1 12L11 12C11.6 12 12 12.4 12 13 12 13.6 11.5 14 11 14L1 14C0.4 14 0 13.6 0 13L0 13Z"/></g></g></g></svg>
                <span class="hide-text-small">Download</span>
                <span>PDF</span>
            </a>
        </div>

                </div>
            </div>




                    </div>
                    <aside class="main-sidebar-right u-interface">
                        <div data-role="sticky-wrapper">
                            <div class="main-sidebar-right__content u-composite-layer" data-component="SpringerLink.StickySidebar">
                                <div class="article-actions" id="article-actions">
                                    <h2 class="u-screenreader-only" aria-hidden="true">Actions</h2>


                                    <div class="u-js-hide u-js-show-two-col">
                                        

                                                <div class="download-article test-pdf-link">
                                                            <div>
            <a href="/content/pdf/10.1007%2Fs00446-016-0272-0.pdf" target="_blank" class="c-button c-button--blue c-button__icon-right" title="Download this article in PDF format" rel="noopener" data-track="click" data-track-action="Pdf download" data-track-label="">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" version="1.1"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill="#fff"><g transform="translate(12.000000, 5.000000)"><path d="M7 7.3L7 1C7 0.4 6.6 0 6 0 5.4 0 5 0.4 5 1L5 7.3 3.5 5.7C3.1 5.3 2.5 5.3 2.1 5.7L2.1 5.7C1.7 6.1 1.7 6.7 2.1 7.1L5.3 10.3C5.7 10.7 6.3 10.7 6.7 10.3L9.9 7.1C10.3 6.7 10.3 6.1 9.9 5.7L9.9 5.7C9.5 5.3 8.9 5.3 8.5 5.7L7 7.3 7 7.3ZM0 13C0 12.4 0.5 12 1 12L11 12C11.6 12 12 12.4 12 13 12 13.6 11.5 14 11 14L1 14C0.4 14 0 13.6 0 13L0 13Z"/></g></g></g></svg>
                <span class="hide-text-small">Download</span>
                <span>PDF</span>
            </a>
        </div>

                                                </div>


                                            <div class="citations" data-component="SV.Dropdown" data-namespace="citations">
        <h3 class="u-h4" data-role="button-dropdown__title">
    <span>Cite</span>
    <span class="hide-text-small">article</span>
</h3>
<ul class="citations__content" data-role="button-dropdown__content">
    <li>
        <a href="#citeas" data-track="click" data-track-action="Cite as link" data-track-label="Cite dropdown">How to cite?</a>
    </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;refman&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .RIS file" data-track="click" data-track-action="Export citation" data-track-label="RIS">
                <span class="citations__extension" data-gtmlabel="RIS">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .RIS
                </span>
                <span class="citations__types">
                        <span>
                            Papers
                        </span>
                        <span>
                            Reference Manager
                        </span>
                        <span>
                            RefWorks
                        </span>
                        <span>
                            Zotero
                        </span>
                </span>
            </a>
        </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;endnote&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .ENW file" data-track="click" data-track-action="Export citation" data-track-label="ENW">
                <span class="citations__extension" data-gtmlabel="ENW">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .ENW
                </span>
                <span class="citations__types">
                        <span>
                            EndNote
                        </span>
                </span>
            </a>
        </li>
        <li>
            <a href="//citation-needed.springer.com/v2/references/10.1007/s00446-016-0272-0?format&#x3D;bibtex&amp;flavour&#x3D;citation"
               title="Download this article&#39;s citation as a .BIB file" data-track="click" data-track-action="Export citation" data-track-label="BIB">
                <span class="citations__extension" data-gtmlabel="BIB">
                    <svg class="u-vertical-align-absolute" width="12" height="14" viewBox="0 0 12 14" xmlns="http://www.w3.org/2000/svg"><path d="M7 7.269v-6.271c0-.551-.448-.998-1-.998-.556 0-1 .447-1 .998v6.271l-1.5-1.547c-.375-.387-1.01-.397-1.401-.006l.016-.016c-.397.397-.391 1.025-.001 1.416l3.178 3.178c.392.392 1.024.391 1.415 0l3.178-3.178c.392-.392.391-1.025-.001-1.416l.016.016c-.397-.397-1.018-.388-1.401.006l-1.5 1.547zm-7 5.731c0-.552.456-1 1.002-1h9.995c.554 0 1.002.444 1.002 1 0 .552-.456 1-1.002 1h-9.995c-.554 0-1.002-.444-1.002-1z" fill="#004aa7"/></svg>
                    .BIB
                </span>
                <span class="citations__types">
                        <span>
                            BibTeX
                        </span>
                        <span>
                            JabRef
                        </span>
                        <span>
                            Mendeley
                        </span>
                </span>
            </a>
        </li>
</ul>
    </div>

                                                <div>
        <a class="c-button share-this test-shareby-sharelink-link" data-test="shareable-link" target="_blank" rel="noopener" href="/sharelink/10.1007/s00446-016-0272-0" data-track="click" data-track-action="Share via" data-track-label="ShareLink">
            <span>Share</span>
            <span class="hide-text-small">article</span>
        </a>
    </div>




                                    </div>
                                </div>
                                <nav class="toc" aria-label="article contents">
    <h2 class="u-screenreader-only" aria-hidden="true">Table of contents</h2>
    <ul id="article-contents" class="article-contents" tabindex="-1">
            <li>
                <a title="Article" href="#enumeration"><span class="u-overflow-ellipsis">Article</span></a>
            </li>
            <li>
                <a title="Abstract" href="#Abs1"><span class="u-overflow-ellipsis">Abstract</span></a>
            </li>
            <li>
                <a title="1 Introduction" href="#Sec1"><span class="u-overflow-ellipsis">1 Introduction</span></a>
            </li>
            <li>
                <a title="2 Preliminaries" href="#Sec6"><span class="u-overflow-ellipsis">2 Preliminaries</span></a>
            </li>
            <li>
                <a title="3 Basic properties of wait-free consensus algorithms" href="#Sec10"><span class="u-overflow-ellipsis">3 Basic properties of wait-free consensus algorithms</span></a>
            </li>
            <li>
                <a title="4 Relaxing the enqueue operation" href="#Sec11"><span class="u-overflow-ellipsis">4 Relaxing the enqueue operation</span></a>
            </li>
            <li>
                <a title="5 Relaxing the peek operation" href="#Sec12"><span class="u-overflow-ellipsis">5 Relaxing the peek operation</span></a>
            </li>
            <li>
                <a title="6 Not supporting the dequeue operation" href="#Sec13"><span class="u-overflow-ellipsis">6 Not supporting the dequeue operation</span></a>
            </li>
            <li>
                <a title="7 Atomic registers versus relaxed queues" href="#Sec14"><span class="u-overflow-ellipsis">7 Atomic registers versus relaxed queues</span></a>
            </li>
            <li>
                <a title="8 Relaxed registers" href="#Sec15"><span class="u-overflow-ellipsis">8 Relaxed registers</span></a>
            </li>
            <li>
                <a title="9 Related work" href="#Sec20"><span class="u-overflow-ellipsis">9 Related work</span></a>
            </li>
            <li>
                <a title="10 Discussion" href="#Sec21"><span class="u-overflow-ellipsis">10 Discussion</span></a>
            </li>
            <li>
                <a title="Footnotes" href="#Footnotes"><span class="u-overflow-ellipsis">Footnotes</span></a>
            </li>
            <li>
                <a title="Notes" href="#Notes"><span class="u-overflow-ellipsis">Notes</span></a>
            </li>
            <li>
                <a title="References" href="#Bib1"><span class="u-overflow-ellipsis">References</span></a>
            </li>
            <li>
                <a title="Copyright information" href="#copyrightInformation"><span class="u-overflow-ellipsis">Copyright information</span></a>
            </li>
            <li>
                <a title="Authors and Affiliations" href="#authorsandaffiliations"><span class="u-overflow-ellipsis">Authors and Affiliations</span></a>
            </li>
            <li>
                <a title="About this article" href="#aboutcontent"><span class="u-overflow-ellipsis">About this article</span></a>
            </li>
    </ul>
</nav>

                            </div>
                                <div class="skyscraper-ad u-hide" data-component="SpringerLink.GoogleAds" data-namespace="skyscraper">
        <div class="skyscraper-ad__wrapper">
            <p class="skyscraper-ad__label">Advertisement</p>
            <button class="skyscraper-ad__hide" title="Hide this advertisement" data-track="click" data-track-action="Hide advertisement" data-track-label="">Hide</button>
            <div id="doubleclick-ad" class="skyscraper-ad__ad"></div>
        </div>
    </div>

                        </div>
                    </aside>
                </div>
            </main>
                <footer class="footer u-interface">
        <div class="footer__aside-wrapper">
            <div class="footer__content">
                <div class="footer__aside">
                    <p class="footer__strapline">Over 10 million scientific documents at your fingertips</p>
                                <div class="footer__edition" data-component="SV.EditionSwitcher">
                                    <h3 class="u-hide" data-role="button-dropdown__title" data-btn-text="Switch between Academic &#38; Corporate Edition">Switch Edition</h3>
                                    <ul data-role="button-dropdown__content">
                                        <li  class="selected"><a href="/siteEdition/link?previousUrl=/article/10.1007/s00446-016-0272-0&id=siteedition-academic-link" id="siteedition-academic-link">Academic Edition</a></li>
                                        <li ><a href="/siteEdition/rd?previousUrl=/article/10.1007/s00446-016-0272-0&id=siteedition-corporate-link" id="siteedition-corporate-link">Corporate Edition</a></li>
                                    </ul>
                                </div>
                </div>
            </div>
        </div>
        <div class="footer__content">
            <ul class="footer__nav">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/impressum">Impressum</a>
                </li>
                <li>
                    <a href="/termsandconditions">Legal information</a>
                </li>
                <li>
                    <a href="/privacystatement">Privacy statement</a>
                </li>
                <li>
                    <a href="/cookiepolicy">How we use cookies</a>
                </li>
                <li>
                    <a class="optanon-toggle-display" href="javascript:void(0);">Cookie settings</a>
                </li>
                <li>
                    <a href="/accessibility">Accessibility</a>
                </li>
                <li>
                    <a id="contactus-footer-link" href="/contactus">Contact us</a>
                </li>
            </ul>
            <a class="parent-logo"
               target="_blank" rel="noopener"
               href="//www.springernature.com"
               title="Go to Springer Nature">
                <span class="u-screenreader-only">Springer Nature</span>
                <svg width="125" height="12" focusable="false" aria-hidden="true">
                    <image width="125" height="12"
                           src="/springerlink-static/632953562/images/png/springernature.png"
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           xlink:href="/springerlink-static/632953562/images/svg/springernature.svg">
                    </image>
                </svg>
            </a>

            <p class="footer__copyright">&copy; 2019 Springer Nature Switzerland AG. Part of <a target="_blank" rel="noopener" href="//www.springernature.com">Springer Nature</a>.</p>
                <p class="footer__user-access-info">
                    <span>Not logged in</span>
                    <span>Universit√† degli Studi di Roma La Sapienza (2000328745) - CRUI-CARE Italy (3000155420) - CARE 2009 &amp; 2010 (3000180852) - Care Nature (3003532199)</span>
                    <span>151.100.59.194</span>
                </p>
        </div>
    </footer>

        </div>
        <script type="text/javascript">
    (function() {
        var linkEl = document.querySelector('.js-ctm');
        var scriptsList = [];
        var polyfillFeatures = '';

        window.SpringerLink = window.SpringerLink || {};
        window.SpringerLink.staticLocation = '/springerlink-static/632953562';
        window.eventTrackerInstance = null;

        if (window.matchMedia && window.matchMedia(linkEl.media).matches) {
            (function(h){h.className = h.className.replace('no-js', 'js')})(document.documentElement);

            polyfillFeatures = 'default,fetch,Promise,Object.setPrototypeOf,Object.entries,Number.isInteger,MutationObserver,startsWith,Array.prototype.includes,Array.from,IntersectionObserver';

            scriptsList = [
                'https://cdn.polyfill.io/v2/polyfill.min.js?features=' + polyfillFeatures + '&flags=gated',
                window.SpringerLink.staticLocation + '/js/main.js'
            ];

            scriptsList.forEach(function(script) {
                var tag = document.createElement('script');
                tag.async = false;
                tag.src = script;

                document.body.appendChild(tag);
            });
        }
    })();
</script>

    <script>
    (function() {
        var linkEl = document.querySelector('.js-ctm');
        if (window.matchMedia && window.matchMedia(linkEl.media).matches) {
            var scriptMathJax = document.createElement('script');
            scriptMathJax.async = false;
            scriptMathJax.src = '/springerlink-static/632953562/js/mathJax.js';
            var s0 = document.getElementsByTagName('script')[0];
            s0.parentNode.insertBefore(scriptMathJax, s0);
        }
    })();
</script>


    <script type="text/javascript" id="googletag-push">
        
            var adSlot = '270604982/springerlink/446/article';
        

        var definedSlots = [
                {slot: [728, 90], containerName: 'doubleclick-leaderboard-ad'},
                {slot: [160, 600], containerName: 'doubleclick-ad'},
            {slot: [2, 2], containerName: 'doubleclick-native-ad'}
        ];
    </script>


        
        <span id="chat-widget" class="u-hide"></span>
                    <noscript>
                <img aria-hidden="true" role="presentation" src="https://ssl-springer.met.vgwort.de/na/pw-vgzm.415900-10.1007-s00446-016-0272-0" width='1' height='1' alt='' />
            </noscript>

        
    </body>
</html>
