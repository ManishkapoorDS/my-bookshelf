<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="access" content="Yes">

    

    <meta name="twitter:site" content="@SpringerLink"/>

    <meta name="twitter:card" content="summary"/>

    <meta name="twitter:image:alt" content="Content cover image"/>

    <meta name="journal_id" content="10664"/>

    <meta name="dc.title" content="How bugs are born: a model to identify how bugs are introduced in software components"/>

    <meta name="dc.source" content="Empirical Software Engineering 2020 25:2"/>

    <meta name="dc.format" content="text/html"/>

    <meta name="dc.publisher" content="Springer"/>

    <meta name="dc.date" content="2020-02-04"/>

    <meta name="dc.type" content="OriginalPaper"/>

    <meta name="dc.language" content="En"/>

    <meta name="dc.copyright" content="2020 The Author(s)"/>

    <meta name="dc.rightsAgent" content="journalpermissions@springernature.com"/>

    <meta name="dc.description" content="When identifying the origin of software bugs, many studies assume that &#8220;a bug was introduced by the lines of code that were modified to fix it&#8221;. However, this assumption does not always hold and at least in some cases, these modified lines are not responsible for introducing the bug. For example, when the bug was caused by a change in an external API. The lack of empirical evidence makes it impossible to assess how important these cases are and therefore, to which extent the assumption is valid. To advance in this direction, and better understand how bugs &#8220;are born&#8221;, we propose a model for defining criteria to identify the first snapshot of an evolving software system that exhibits a bug. This model, based on the perfect test idea, decides whether a bug is observed after a change to the software. Furthermore, we studied the model&#8217;s criteria by carefully analyzing how 116 bugs were introduced in two different open source software projects. The manual analysis helped classify the root cause of those bugs and created manually curated datasets with bug-introducing changes and with bugs that were not introduced by any change in the source code. Finally, we used these datasets to evaluate the performance of four existing SZZ-based algorithms for detecting bug-introducing changes. We found that SZZ-based algorithms are not very accurate, especially when multiple commits are found; the F-Score varies from 0.44 to 0.77, while the percentage of true positives does not exceed 63%. Our results show empirical evidence that the prevalent assumption, &#8220;a bug was introduced by the lines of code that were modified to fix it&#8221;, is just one case of how bugs are introduced in a software system. Finding what introduced a bug is not trivial: bugs can be introduced by the developers and be in the code, or be created irrespective of the code. Thus, further research towards a better understanding of the origin of bugs in software projects could help to improve design integration tests and to design other procedures to make software development more robust."/>

    <meta name="prism.issn" content="1573-7616"/>

    <meta name="prism.publicationName" content="Empirical Software Engineering"/>

    <meta name="prism.publicationDate" content="2020-02-04"/>

    <meta name="prism.volume" content="25"/>

    <meta name="prism.number" content="2"/>

    <meta name="prism.section" content="OriginalPaper"/>

    <meta name="prism.startingPage" content="1294"/>

    <meta name="prism.endingPage" content="1340"/>

    <meta name="prism.copyright" content="2020 The Author(s)"/>

    <meta name="prism.rightsAgent" content="journalpermissions@springernature.com"/>

    <meta name="prism.url" content="https://link.springer.com/article/10.1007/s10664-019-09781-y"/>

    <meta name="prism.doi" content="doi:10.1007/s10664-019-09781-y"/>

    <meta name="citation_pdf_url" content="https://link.springer.com/content/pdf/10.1007/s10664-019-09781-y.pdf"/>

    <meta name="citation_fulltext_html_url" content="https://link.springer.com/article/10.1007/s10664-019-09781-y"/>

    <meta name="citation_journal_title" content="Empirical Software Engineering"/>

    <meta name="citation_journal_abbrev" content="Empir Software Eng"/>

    <meta name="citation_publisher" content="Springer US"/>

    <meta name="citation_issn" content="1573-7616"/>

    <meta name="citation_title" content="How bugs are born: a model to identify how bugs are introduced in software components"/>

    <meta name="citation_volume" content="25"/>

    <meta name="citation_issue" content="2"/>

    <meta name="citation_publication_date" content="2020/03"/>

    <meta name="citation_online_date" content="2020/02/04"/>

    <meta name="citation_firstpage" content="1294"/>

    <meta name="citation_lastpage" content="1340"/>

    <meta name="citation_article_type" content="Article"/>

    <meta name="citation_fulltext_world_readable" content=""/>

    <meta name="citation_language" content="en"/>

    <meta name="dc.identifier" content="doi:10.1007/s10664-019-09781-y"/>

    <meta name="DOI" content="10.1007/s10664-019-09781-y"/>

    <meta name="citation_doi" content="10.1007/s10664-019-09781-y"/>

    <meta name="description" content="When identifying the origin of software bugs, many studies assume that &#8220;a bug was introduced by the lines of code that were modified to fix it&#8221;"/>

    <meta name="dc.creator" content="Gema Rodr&#237;guez-P&#233;rez"/>

    <meta name="dc.creator" content="Gregorio Robles"/>

    <meta name="dc.creator" content="Alexander Serebrenik"/>

    <meta name="dc.creator" content="Andy Zaidman"/>

    <meta name="dc.creator" content="Daniel M. Germ&#225;n"/>

    <meta name="dc.creator" content="Jesus M. Gonzalez-Barahona"/>

    <meta name="dc.subject" content="Software Engineering/Programming and Operating Systems"/>

    <meta name="dc.subject" content="Programming Languages, Compilers, Interpreters"/>

    <meta name="citation_reference" content="Abreu R, Premraj R (2009) How developer communication frequency relates to bug introducing changes. In: Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops. ACM, pp 153&#8211;158."/>

    <meta name="citation_reference" content="Alexandru CV, Gall H (2015) Rapid multi-purpose, multi-commit code analysis. In: 2015 IEEE/ACM 37th IEEE International Conference on Software Engineering (ICSE), vol 2. IEEE, pp 635&#8211;638"/>

    <meta name="citation_reference" content="Aranda J, Venolia G (2009) The secret life of bugs: Going past the errors and omissions in software repositories. In: Proceedings of the 31st international conference on software engineering. IEEE Computer Society, pp 298&#8211;308"/>

    <meta name="citation_reference" content="citation_journal_title=Commun ACM; citation_title=Software errors and complexity: an empirical investigation; citation_author=VR Basili, BT Perricone; citation_volume=27; citation_issue=1; citation_publication_date=1984; citation_pages=42-52; citation_doi=10.1145/69605.2085; citation_id=CR4"/>

    <meta name="citation_reference" content="Bavota G, Russo B. (2015) Four eyes are better than two: on the impact of code reviews on software quality. In: 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME). IEEE, pp 81&#8211;90"/>

    <meta name="citation_reference" content="Beller M, Gousios G, Zaidman A (2015) How (much) do developers test?. In: Proceedings of the International Conference on Software Engineering (ICSE), vol 2. IEEE Computer Society, pp 559&#8211;562"/>

    <meta name="citation_reference" content="Beller M, Gousios G, Zaidman A (2017) Oops, my tests broke the build: an explorative analysis of Travis CI with GitHub. In: Proceedings of the International Conference on Mining Software Repositories (MSR). IEEE, pp 356&#8211;367"/>

    <meta name="citation_reference" content="Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In: Proceedings of the International Conference on Software Engineering (ICSE). ACM, pp 572&#8211;583"/>

    <meta name="citation_reference" content="Berger ED, Hollenbeck C, Maj P, Vitek O, Vitek J (2019) On the impact of programming languages on code quality. arXiv:
1901.10220


"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Studying the impact of social interactions on software quality; citation_author=N Bettenburg, AE Hassan; citation_volume=18; citation_issue=2; citation_publication_date=2013; citation_pages=375-431; citation_doi=10.1007/s10664-012-9205-0; citation_id=CR10"/>

    <meta name="citation_reference" content="Bird C, Bachmann A, Aune E, Duffy J, Bernstein A, Filkov V, Devanbu P (2009) Fair and balanced?: bias in bug-fix datasets. In: Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering. ACM, pp 121&#8211;130"/>

    <meta name="citation_reference" content="Bird C, Rigby PC, Barr E, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: 6th IEEE international working conference on mining software repositories, 2009. MSR&#8217;09. IEEE, pp 1&#8211;10"/>

    <meta name="citation_reference" content="Bissyande TF, Thung F, Wang S, Lo D, Jiang L, Reveillere L (2013) Empirical evaluation of bug linking. In: 2013 17th european conference on software maintenance and reengineering (CSMR). IEEE, pp 89&#8211;98"/>

    <meta name="citation_reference" content="citation_journal_title=Foundations of empirical software engineering: the legacy of Victor R Basili; citation_title=Software defect reduction top 10 list; citation_author=B Boehm, VR Basili; citation_volume=426; citation_issue=37; citation_publication_date=2005; citation_pages=426-431; citation_doi=10.1007/3-540-27662-9_26; citation_id=CR14"/>

    <meta name="citation_reference" content="Brooks FP Jr (1995) The mythical man-month: essays on software engineering, anniversary edition, 2/E. Pearson Education India"/>

    <meta name="citation_reference" content="Canfora G, Cerulo L, Cimitile M, Di Penta M (2011) Social interactions around cross-system bug fixings: the case of freebsd and openbsd. In: Proceedings of the 8th working conference on mining software repositories. ACM, pp 143&#8211;152"/>

    <meta name="citation_reference" content="citation_journal_title=J Syst Softw; citation_title=Not all bugs are the same Understanding, characterizing, and classifying bug types; citation_author=G Catolino, F Palomba, A Zaidman, F Ferrucci; citation_volume=152; citation_publication_date=2019; citation_pages=165-181; citation_doi=10.1016/j.jss.2019.03.002; citation_id=CR17"/>

    <meta name="citation_reference" content="citation_journal_title=ACM Transactions on Computer Systems (TOCS); citation_title=Distributed snapshots: Determining global states of distributed systems; citation_author=KM Chandy, L Lamport; citation_volume=3; citation_issue=1; citation_publication_date=1985; citation_pages=63-75; citation_doi=10.1145/214451.214456; citation_id=CR18"/>

    <meta name="citation_reference" content="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82&#8211;91"/>

    <meta name="citation_reference" content="&#268;ubranic D, Murphy GC (2003) Hipikat: Recommending pertinent software development artifacts. In: 25th international conference on software engineering, 2003. Proceedings. IEEE, pp 408&#8211;418"/>

    <meta name="citation_reference" content="da Costa DA, Kulesza U, Aranha E, Coelho R (2014) Unveiling developers contributions behind code commits: an exploratory study. In: Proceedings of the 29th annual ACM symposium on applied computing. ACM, pp 1152&#8211;1157"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes; citation_author=DA da Costa, S McIntosh, W Shang, U Kulesza, R Coelho, AE Hassan; citation_volume=43; citation_issue=7; citation_publication_date=2017; citation_pages=641-657; citation_doi=10.1109/TSE.2016.2616306; citation_id=CR22"/>

    <meta name="citation_reference" content="citation_journal_title=Journal of Software: Evolution and Process; citation_title=Comparing text-based and dependence-based approaches for determining the origins of bugs; citation_author=S Davies, M Roper, M Wood; citation_volume=26; citation_issue=1; citation_publication_date=2014; citation_pages=107-139; citation_id=CR23"/>

    <meta name="citation_reference" content="Demeyer S, Ducasse S, Nierstrasz O (2002) Object-oriented reengineering patterns. Elsevier"/>

    <meta name="citation_reference" content="Dias M, Bacchelli A, Gousios G, Cassou D, Ducasse S (2015) Untangling fine-grained code changes. In: 2015 IEEE 22nd international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 341&#8211;350"/>

    <meta name="citation_reference" content="Easterbrook S, Singer J, Storey M. -A., Damian D (2008) Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering. Springer, pp 285&#8211;311"/>

    <meta name="citation_reference" content="citation_journal_title=J Syst Softw; citation_title=An exploratory study on exception handling bugs in Java programs; citation_author=F Ebert, F Castor, A Serebrenik; citation_volume=106; citation_publication_date=2015; citation_pages=82-101; citation_doi=10.1016/j.jss.2015.04.066; citation_id=CR27"/>

    <meta name="citation_reference" content="Ell J (2013) Identifying failure inducing developer pairs within developer networks. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 1471&#8211;1473"/>

    <meta name="citation_reference" content="Fischer M, Pinzger M, Gall H (2003) Analyzing and relating bug report data for feature tracking. In: Proceedings of the 10th working conference on reverse engineering (WCRE). IEEE, pp 90&#8211;100"/>

    <meta name="citation_reference" content="Fischer M, Pinzger M, Gall H (2003) Populating a release history database from version control and bug tracking systems. In: International conference on software maintenance, 2003. ICSM 2003. Proceedings. IEEE, pp 23&#8211;32"/>

    <meta name="citation_reference" content="Fowler M, Beck K, Brant J, Opdyke W, Roberts D (1999) Refactoring: improving the design of existing code. Addison-Wesley Professional"/>

    <meta name="citation_reference" content="Fraser G, Arcuri A (2013a) Evosuite: On the challenges of test case generation in the real world. In: 2013 IEEE sixth international conference on software testing, verification and validation (ICST). IEEE, pp 362&#8211;369"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=Whole test suite generation; citation_author=G Fraser, A Arcuri; citation_volume=39; citation_issue=2; citation_publication_date=2013; citation_pages=276-291; citation_doi=10.1109/TSE.2012.14; citation_id=CR33"/>

    <meta name="citation_reference" content="citation_journal_title=Inf Softw Technol; citation_title=Change impact graphs: Determining the impact of prior codechanges; citation_author=DM German, AE Hassan, G Robles; citation_volume=51; citation_issue=10; citation_publication_date=2009; citation_pages=1394-1408; citation_doi=10.1016/j.infsof.2009.04.018; citation_id=CR34"/>

    <meta name="citation_reference" content="citation_journal_title=J Softw Evol Process; citation_title=Studying the laws of software evolution in a long-lived floss project; citation_author=JM Gonzalez-Barahona, G Robles, I Herraiz, F Ortega; citation_volume=26; citation_issue=7; citation_publication_date=2014; citation_pages=589-612; citation_doi=10.1002/smr.1615; citation_id=CR35"/>

    <meta name="citation_reference" content="Gousios G, Zaidman A, Storey MD, van Deursen A (2015) Work practices and challenges in pull-based development: the integrator&#8217;s perspective. In: Bertolino A., Canfora G., Elbaum S.G. (eds) 37th IEEE/ACM international conference on software engineering, ICSE 2015, Florence, Italy, May 16-24, 2015, vol 1. IEEE Computer Society, pp 358&#8211;368"/>

    <meta name="citation_reference" content="citation_journal_title=MIS Quarterly; citation_title=The Nature of Theory in Information Systems; citation_author=null Gregor; citation_volume=30; citation_issue=3; citation_publication_date=2006; citation_pages=611; citation_doi=10.2307/25148742; citation_id=CR37"/>

    <meta name="citation_reference" content="Guerrouj L, Kermansaravi Z, Arnaoudova V, Fung BC, Khomh F, Antoniol G, Gu&#233;h&#233;neuc Y-G (2015) Investigating the relation between lexical smells and change-and fault-proneness: an empirical study. Softw Qual J:1&#8211;30"/>

    <meta name="citation_reference" content="Hassan AE (2009) Predicting faults using the complexity of code changes. In: IEEE 31st international conference on software engineering, 2009. ICSE 2009. IEEE, pp 78&#8211;88"/>

    <meta name="citation_reference" content="Hassan AE, Holt R (2005) The top ten list: Dynamic fault prediction. In: Proceedings of the 21st IEEE international conference on software maintenance, 2005. ICSM&#8217;05. IEEE, pp 263&#8211;272"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Fault-prone module detection using large-scale text features based on spam filtering; citation_author=H Hata, O Mizuno, T Kikuno; citation_volume=15; citation_issue=2; citation_publication_date=2010; citation_pages=147-165; citation_doi=10.1007/s10664-009-9117-9; citation_id=CR41"/>

    <meta name="citation_reference" content="Herzig K, Just S, Zeller A (2013) It&#8217;s not a bug, it&#8217;s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392&#8211;401"/>

    <meta name="citation_reference" content="Hilton M, Bell J, Marinov D (2018) A large-scale study of test coverage evolution. In: Proceedings of the 33rd ACM/IEEE international conference on automated software engineering (ASE). ACM, pp 53&#8211;63"/>

    <meta name="citation_reference" content="Hindle A, German DM, Holt R (2008) What do large commits tell us?: a taxonomical study of large commits. In: Proceedings of the 2008 international working conference on mining software repositories. ACM, pp 99&#8211;108"/>

    <meta name="citation_reference" content="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE"/>

    <meta name="citation_reference" content="ISO/IEC (2001) ISO/IEC 9126. Software engineering &#8211; Product quality ISO/IEC"/>

    <meta name="citation_reference" content="Itkonen J, Mantyla MV, Lassenius C (2007) Defect detection efficiency: Test case based vs. exploratory testing. In: First international symposium on empirical software engineering and measurement, 2007. ESEM 2007. IEEE, pp 61&#8211;70"/>

    <meta name="citation_reference" content="citation_journal_title=International Journal of Open Source Software and Processes (IJOSSP); citation_title=Are developers fixing their own bugs?: Tracing bug-fixing and bug-seeding committers; citation_author=D Izquierdo-Cortazar, A Capiluppi, JM Gonzalez-Barahona; citation_volume=3; citation_issue=2; citation_publication_date=2011; citation_pages=23-42; citation_doi=10.4018/jossp.2011040102; citation_id=CR48"/>

    <meta name="citation_reference" content="Izquierdo-Cort&#225;zar D., Robles G, Gonz&#225;lez-Barahona J. M. (2012) Do more experienced developers introduce fewer bugs? In: IFIP International conference on open source systems. Springer, pp 268&#8211;273"/>

    <meta name="citation_reference" content="citation_journal_title=Inf Softw Technol; citation_title=Identification of factors that influence defect injection and detection in development of software intensive products; citation_author=J Jacobs, J Moll, R Kusters, J Trienekens, A Brombacher; citation_volume=49; citation_issue=7; citation_publication_date=2007; citation_pages=774-789; citation_doi=10.1016/j.infsof.2006.09.002; citation_id=CR50"/>

    <meta name="citation_reference" content="Kalliamvakou E, Gousios G, Blincoe K, Singer L, German DM, Damian D (2014) The promises and perils of mining GitHub. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 92&#8211;101"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=A large-scale empirical study of just-in-time quality assurance; citation_author=Y Kamei, E Shihab, B Adams, AE Hassan, A Mockus, A Sinha, N Ubayashi; citation_volume=39; citation_issue=6; citation_publication_date=2013; citation_pages=757-773; citation_doi=10.1109/TSE.2012.70; citation_id=CR52"/>

    <meta name="citation_reference" content="Kim S, Whitehead E Jr, et al. (2006) Properties of signature change patterns. In: 22nd IEEE international conference on software maintenance, 2006. ICSM&#8217;06. IEEE, pp 4&#8211;13"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=Classifying software changes: Clean or buggy?; citation_author=S Kim, EJr Whitehead, Y Zhang; citation_volume=34; citation_issue=2; citation_publication_date=2008; citation_pages=181-196; citation_doi=10.1109/TSE.2007.70773; citation_id=CR54"/>

    <meta name="citation_reference" content="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE&#8217;06. IEEE, pp 81&#8211;90"/>

    <meta name="citation_reference" content="Kim S, Zimmermann T, Whitehead E Jr, Zeller A (2007) Predicting faults from cached history. In: Proceedings of the 29th international conference on software engineering. IEEE Computer Society, pp 489&#8211;498"/>

    <meta name="citation_reference" content="Knauss E, Damian D, Knauss A, Borici A (2014) Openness and requirements: opportunities and tradeoffs in software ecosystems. In: 2014 IEEE 22nd international requirements engineering conference (RE). IEEE, pp 213&#8211;222"/>

    <meta name="citation_reference" content="Knauss E, Liebel G, Horkoff J, Wohlrab R, Kasauli R, Lange F, Gildert P (2018) T-reqs: Tool support for managing requirements in large-scale agile system development. arXiv:
1805.02769


"/>

    <meta name="citation_reference" content="LaToza TD, Venolia G, DeLine R (2006) Maintaining mental models: a study of developer work habits. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 492&#8211;501"/>

    <meta name="citation_reference" content="Le T-DB, Linares-V&#225;squez M, Lo D, Poshyvanyk D (2015) Rclinker: automated linking of issue reports and commits leveraging rich contextual information. In: 2015 IEEE 23rd international conference on program comprehension (ICPC). IEEE, pp 36&#8211;47"/>

    <meta name="citation_reference" content="Li Z, Tan L, Wang X, Lu S, Zhou Y, Zhai C (2006) Have things changed now?: an empirical study of bug characteristics in modern open source software. In: Proceedings of the 1st workshop on Architectural and system support for improving software dependability. ACM, pp 25&#8211;33"/>

    <meta name="citation_reference" content="Marsavina C, Romano D, Zaidman A (2014) Studying fine-grained co-evolution patterns of production and test code. In: 2014 IEEE 14th international working conference on source code analysis and manipulation (SCAM). IEEE, pp 195&#8211;204"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=An empirical methodology to evaluate vulnerability discovery models; citation_author=F Massacci, VH Nguyen; citation_volume=40; citation_issue=12; citation_publication_date=2014; citation_pages=1147-1162; citation_doi=10.1109/TSE.2014.2354037; citation_id=CR63"/>

    <meta name="citation_reference" content="Meneely A, Srinivasan H, Musa A, Tejeda AR, Mokary M, Spates B (2013) When a patch goes bad: Exploring the properties of vulnerability-contributing commits. In: 2013 ACM/IEEE international symposium on empirical software engineering and measurement. IEEE, pp 65&#8211;74"/>

    <meta name="citation_reference" content="Mens T, Wermelinger M, Ducasse S, Demeyer S, Hirschfeld R, Jazayeri M (2005) Challenges in software evolution. In: Eighth international workshop on principles of software evolution. IEEE, pp 13&#8211;22"/>

    <meta name="citation_reference" content="citation_journal_title=Bell Labs Technical Journal; citation_title=Predicting risk of software changes; citation_author=A Mockus, DM Weiss; citation_volume=5; citation_issue=2; citation_publication_date=2000; citation_pages=169-180; citation_doi=10.1002/bltj.2229; citation_id=CR66"/>

    <meta name="citation_reference" content="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173&#8211;202"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=The design space of bug fixes and how developers navigate it; citation_author=E Murphy-Hill, T Zimmermann, C Bird, N Nagappan; citation_volume=41; citation_issue=1; citation_publication_date=2015; citation_pages=65-81; citation_doi=10.1109/TSE.2014.2357438; citation_id=CR68"/>

    <meta name="citation_reference" content="Nagappan N, Ball T, Zeller A (2006) Mining metrics to predict component failures. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 452&#8211;461"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=A case history analysis of software error cause-effect relationships; citation_author=T Nakajo, H Kume; citation_volume=17; citation_issue=8; citation_publication_date=1991; citation_pages=830-838; citation_doi=10.1109/32.83917; citation_id=CR70"/>

    <meta name="citation_reference" content="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380&#8211;390"/>

    <meta name="citation_reference" content="Neto EC, da Costa DA, Kulesza U (2019) Revisiting and improving SZZ implementations. In: 2019 ACM/IEEE International symposium on empirical software engineering and measurement. ACM"/>

    <meta name="citation_reference" content="Nuseibeh B, Easterbrook S (2000) Requirements engineering: a roadmap. In: Proceedings of the conference on the future of software engineering. ACM, pp 35&#8211;46"/>

    <meta name="citation_reference" content="citation_journal_title=ACM Sigplan Notices; citation_title=The program dependence graph in a software development environment; citation_author=KJ Ottenstein, LM Ottenstein; citation_volume=19; citation_issue=5; citation_publication_date=1984; citation_pages=177-184; citation_doi=10.1145/390011.808263; citation_id=CR74"/>

    <meta name="citation_reference" content="Palomba F, Panichella A, Zaidman A, Oliveto R, De Lucia A (2016) Automatic test case generation: what if test code quality matters? In: Proceedings of the 25th international symposium on software testing and analysis (ISSTA). ACM, pp 130&#8211;141"/>

    <meta name="citation_reference" content="Palomba F, Zaidman A (2017) Does refactoring of test smells induce fixing flaky tests? In: Proceedings of the International Conference on Software Maintenance and Evolution (ICSME). IEEE, pp 1&#8211;12"/>

    <meta name="citation_reference" content="citation_journal_title=Empirical Software Engineering (EMSE); citation_title=The smell of fear: on the relation between test smells and flaky tests; citation_author=F Palomba, A Zaidman; citation_volume=24; citation_issue=5; citation_publication_date=2019; citation_pages=2907-2946; citation_doi=10.1007/s10664-019-09683-z; citation_id=CR77"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Toward an understanding of bug fix patterns; citation_author=K Pan, S Kim, EJJr Whitehead; citation_volume=14; citation_issue=3; citation_publication_date=2009; citation_pages=286-315; citation_doi=10.1007/s10664-008-9077-5; citation_id=CR78"/>

    <meta name="citation_reference" content="citation_journal_title=Inf Softw Technol; citation_title=Why software repositories are not used for defect-insertion circumstance analysis more often: A case study; citation_author=L Prechelt, A Pepper; citation_volume=56; citation_issue=10; citation_publication_date=2014; citation_pages=1377-1389; citation_doi=10.1016/j.infsof.2014.05.001; citation_id=CR79"/>

    <meta name="citation_reference" content="Rahman F, Khatri S, Barr E, Devanbu P (2014) Comparing static bug finders and statistical prediction. In: Proceedings of the 36th international conference on software engineering. ACM, pp 424&#8211;434"/>

    <meta name="citation_reference" content="Rahman F, Posnett D, Hindle A, Barr E, Devanbu P (2011) Bugcache for inspections: hit or miss? In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering. ACM, pp 322&#8211;331"/>

    <meta name="citation_reference" content="Ray B, Hellendoorn V, Godhane S, Tu Z, Bacchelli A, Devanbu P (2016) On the naturalness of buggy code. In: Proceedings of the 38th international conference on software engineering. ACM, pp 428&#8211;439"/>

    <meta name="citation_reference" content="Ray B, Posnett D, Filkov V, Devanbu P (2014) A large scale study of programming languages and code quality in github. In: Proceedings of the 22nd ACM SIGSOFT international symposium on foundations of software engineering. ACM, pp 155&#8211;165"/>

    <meta name="citation_reference" content="Rodr&#237;guez-P&#233;rez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192&#8211;198"/>

    <meta name="citation_reference" content="Rodriguez-Perez G, Robles G, Gonzalez-Barahona JM (2017) How much time did it take to notify a bug?: two case studies: elasticsearch and nova. In: Proceedings of the 8th workshop on emerging trends in software metrics. IEEE Press, pp 29&#8211;35"/>

    <meta name="citation_reference" content="citation_journal_title=Inf Softw Technol; citation_title=Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm; citation_author=G Rodr&#237;guez-P&#233;rez, G Robles, JM Gonz&#225;lez-Barahona; citation_volume=99; citation_publication_date=2018; citation_pages=164-176; citation_doi=10.1016/j.infsof.2018.03.009; citation_id=CR86"/>

    <meta name="citation_reference" content="Rodr&#237;guez-P&#233;rez G, Zaidman A, Serebrenik A, Robles G, Gonz&#225;lez-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1&#8211;52:4"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=Analyzing regression test selection techniques; citation_author=G Rothermel, MJ Harrold; citation_volume=22; citation_issue=8; citation_publication_date=1996; citation_pages=529-551; citation_doi=10.1109/32.536955; citation_id=CR88"/>

    <meta name="citation_reference" content="citation_title=Case study research in software engineering: Guidelines and examples; citation_publication_date=2012; citation_id=CR89; citation_author=P Runeson; citation_author=M Host; citation_author=A Rainer; citation_author=B Regnell; citation_publisher=Wiley"/>

    <meta name="citation_reference" content="Sahal E, Tosun A (2018) Identifying bug-inducing changes for code additions. In: Proceedings of the 12th ACM/IEEE international symposium on empirical software engineering and measurement. ACM, p 57"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Studying re-opened bugs in open source software; citation_author=E Shihab, A Ihara, Y Kamei, WM Ibrahim, M Ohira, B Adams, AE Hassan, K-i Matsumoto; citation_volume=18; citation_issue=5; citation_publication_date=2013; citation_pages=1005-1042; citation_doi=10.1007/s10664-012-9228-6; citation_id=CR91"/>

    <meta name="citation_reference" content="Sinha VS, Sinha S, Rao S (2010) Buginnings: identifying the origins of a bug. In: Proceedings of the 3rd India software engineering conference. ACM, pp 3&#8211;12"/>

    <meta name="citation_reference" content="&#346;liwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1&#8211;5"/>

    <meta name="citation_reference" content="Soetens QD, P&#233;rez J., Demeyer S, Zaidman A (2015) Circumventing refactoring masking using fine-grained change recording. In: Proceedings of the 14th international workshop on principles of software evolution. ACM, pp 9&#8211;18"/>

    <meta name="citation_reference" content="citation_journal_title=Inf Softw Technol; citation_title=Frlink: Improving the recovery of missing issue-commit links by revisiting file relevance; citation_author=Y Sun, Q Wang, Y Yang; citation_volume=84; citation_publication_date=2017; citation_pages=33-47; citation_doi=10.1016/j.infsof.2016.11.010; citation_id=CR95"/>

    <meta name="citation_reference" content="citation_journal_title=IEEE Trans Softw Eng; citation_title=Replicating and re-evaluating the theory of relative defect-proneness; citation_author=MD Syer, M Nagappan, B Adams, AE Hassan; citation_volume=41; citation_issue=2; citation_publication_date=2015; citation_pages=176-197; citation_doi=10.1109/TSE.2014.2361131; citation_id=CR96"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Bug characteristics in open source software; citation_author=L Tan, C Liu, Z Li, X Wang, Y Zhou, C Zhai; citation_volume=19; citation_issue=6; citation_publication_date=2014; citation_pages=1665-1705; citation_doi=10.1007/s10664-013-9258-8; citation_id=CR97"/>

    <meta name="citation_reference" content="Tantithamthavorn C, Teekavanich R, Ihara A, Matsumoto K-i (2013) Mining a change history to quickly identify bug locations: a case study of the eclipse project. In: 2013 IEEE international symposium on software reliability engineering workshops (ISSREW). IEEE, pp 108&#8211;113"/>

    <meta name="citation_reference" content="Thung F, Lo D, Jiang L (2013) Automatic recovery of root causes from bug-fixing changes. In: 2013 20th working conference on reverse engineering (WCRE). IEEE, pp 92&#8211;101"/>

    <meta name="citation_reference" content="Vassallo C, Zampetti F, Romano D, Beller M, Panichella A, Penta MD, Zaidman A (2016) Continuous delivery practices in a large financial organization. In: Proceedings of the international conference on software maintenance and evolution (ICSME). IEEE Computer Society, pp 519&#8211;528"/>

    <meta name="citation_reference" content="citation_journal_title=Interact Comput; citation_title=Human factors in requirements engineering: A survey of human sciences literature relevant to the improvement of dependable systems development processes; citation_author=S Viller, J Bowers, T Rodden; citation_volume=11; citation_issue=6; citation_publication_date=1999; citation_pages=665-698; citation_doi=10.1016/S0953-5438(98)00049-6; citation_id=CR101"/>

    <meta name="citation_reference" content="Vonken F, Zaidman A (2012) Refactoring with unit testing: a match made in heaven?. In: Proceeedings of the working conference on reverse engineering (WCRE), pp 29&#8211;38"/>

    <meta name="citation_reference" content="Weiss C, Premraj R, Zimmermann T, Zeller A (2007) How long will it take to fix this bug? In: Fourth international workshop on mining software repositories, 2007. ICSE Workshops MSR&#8217;07. IEEE, pp 1&#8211;1"/>

    <meta name="citation_reference" content="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32&#8211;36"/>

    <meta name="citation_reference" content="Wohlin C, Runeson P, H&#246;st M, Ohlsson MC, Regnell B, Wessl&#233;n A (2012) Experimentation in software engineering. Springer Science &amp; Business Media"/>

    <meta name="citation_reference" content="Wu R, Zhang H, Kim S, Cheung S-C (2011) Relink: recovering links between bugs and changes. In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering. ACM, pp 15&#8211;25"/>

    <meta name="citation_reference" content="citation_journal_title=Autom Softw Eng; citation_title=Automatic, high accuracy prediction of reopened bugs; citation_author=X Xia, D Lo, E Shihab, X Wang, B Zhou; citation_volume=22; citation_issue=1; citation_publication_date=2015; citation_pages=75-109; citation_doi=10.1007/s10515-014-0162-2; citation_id=CR107"/>

    <meta name="citation_reference" content="Zaidman A, Van Rompaey B, Demeyer S, van Deursen A (2008) Mining software repositories to study co-evolution of production &amp; test code. In: First international conference on software testing, verification, and validation (ICST). IEEE, pp 220&#8211;229"/>

    <meta name="citation_reference" content="citation_journal_title=Empir Softw Eng; citation_title=Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining; citation_author=A Zaidman, B Rompaey, A Deursen, S Demeyer; citation_volume=16; citation_issue=3; citation_publication_date=2011; citation_pages=325-364; citation_doi=10.1007/s10664-010-9143-7; citation_id=CR109"/>

    <meta name="citation_reference" content="citation_title=Why programs fail - a guide to systematic debugging; citation_publication_date=2009; citation_id=CR110; citation_author=A Zeller; citation_publisher=Academic Press"/>

    <meta name="citation_reference" content="Zeller A, Hughes W, Lavery J, Doran K, Morrison CT, Snodgrass RT, St&#228;rk RF (2011) Causes and effects in computer programs. In: Proceedings of the fifth international workshop on computer, pp 482&#8211;508"/>

    <meta name="citation_reference" content="Zimmermann T, Premraj R, Zeller A (2007) Predicting defects for Eclipse. In: International workshop on predictor models in software engineering, 2007. PROMISE&#8217;07: ICSE workshops 2007. IEEE, pp 9&#8211;9"/>

    <meta name="citation_reference" content="Zimmermann T, Nagappan N, Guo PJ, Murphy B (2012) Characterizing and predicting which bugs get reopened. In: Proceedings of the 34th international conference on software engineering. IEEE Press, pp 1074&#8211;1083"/>

    <meta name="citation_author" content="Gema Rodr&#237;guez-P&#233;rez"/>

    <meta name="citation_author_email" content="gema.rodriguez-perez@uwaterloo.ca"/>

    <meta name="citation_author_institution" content="University of Waterloo, Waterloo, Canada"/>

    <meta name="citation_author" content="Gregorio Robles"/>

    <meta name="citation_author_email" content="grex@gsyc.urjc.es"/>

    <meta name="citation_author_institution" content="Universidad Rey Juan Carlos, Madrid, Spain"/>

    <meta name="citation_author" content="Alexander Serebrenik"/>

    <meta name="citation_author_email" content="a.serebrenik@tue.nl"/>

    <meta name="citation_author_institution" content="Eindhoven University of Technology, Eindhoven, The Netherlands"/>

    <meta name="citation_author" content="Andy Zaidman"/>

    <meta name="citation_author_email" content="a.e.zaidman@tudelft.nl"/>

    <meta name="citation_author_institution" content="Delft University of Technology, Delft, The Netherlands"/>

    <meta name="citation_author" content="Daniel M. Germ&#225;n"/>

    <meta name="citation_author_email" content="dmg@uvic.ca"/>

    <meta name="citation_author_institution" content="University of Victoria, Victoria, Canada"/>

    <meta name="citation_author" content="Jesus M. Gonzalez-Barahona"/>

    <meta name="citation_author_email" content="jgb@gsyc.urjc.es"/>

    <meta name="citation_author_institution" content="Universidad Rey Juan Carlos, Madrid, Spain"/>

    <meta name="citation_springer_api_url" content="http://api.springer.com/metadata/pam?q=doi:10.1007/s10664-019-09781-y&amp;api_key="/>

    <meta name="format-detection" content="telephone=no"/>

    <meta name="citation_cover_date" content="2020/03/01"/>


    
        <meta property="og:url" content="https://link.springer.com/article/10.1007/s10664-019-09781-y"/>
        <meta property="og:type" content="article"/>
        <meta property="og:site_name" content="Empirical Software Engineering"/>
        <meta property="og:title" content="How bugs are born: a model to identify how bugs are introduced in software components"/>
        <meta property="og:description" content="When identifying the origin of software bugs, many studies assume that “a bug was introduced by the lines of code that were modified to fix it”. However, this assumption does not always hold and at least in some cases, these modified lines are not responsible for introducing the bug. For example, when the bug was caused by a change in an external API. The lack of empirical evidence makes it impossible to assess how important these cases are and therefore, to which extent the assumption is valid. To advance in this direction, and better understand how bugs “are born”, we propose a model for defining criteria to identify the first snapshot of an evolving software system that exhibits a bug. This model, based on the perfect test idea, decides whether a bug is observed after a change to the software. Furthermore, we studied the model’s criteria by carefully analyzing how 116 bugs were introduced in two different open source software projects. The manual analysis helped classify the root cause of those bugs and created manually curated datasets with bug-introducing changes and with bugs that were not introduced by any change in the source code. Finally, we used these datasets to evaluate the performance of four existing SZZ-based algorithms for detecting bug-introducing changes. We found that SZZ-based algorithms are not very accurate, especially when multiple commits are found; the F-Score varies from 0.44 to 0.77, while the percentage of true positives does not exceed 63%. Our results show empirical evidence that the prevalent assumption, “a bug was introduced by the lines of code that were modified to fix it”, is just one case of how bugs are introduced in a software system. Finding what introduced a bug is not trivial: bugs can be introduced by the developers and be in the code, or be created irrespective of the code. Thus, further research towards a better understanding of the origin of bugs in software projects could help to improve design integration tests and to design other procedures to make software development more robust."/>
        <meta property="og:image" content="https://media.springernature.com/w110/springer-static/cover/journal/10664.jpg"/>
    

    <title>How bugs are born: a model to identify how bugs are introduced in software components | SpringerLink</title>

    <link rel="shortcut icon" href=/oscar-static/images/favicons/springerlink/favicon-eb9f5576a3.ico />
<link rel="icon" sizes="16x16 32x32 48x48" href=/oscar-static/images/favicons/springerlink/favicon-eb9f5576a3.ico />
<link rel="icon" sizes="16x16" type="image/png" href=/oscar-static/images/favicons/springerlink/favicon-16x16-8bd8c1c945.png />
<link rel="icon" sizes="32x32" type="image/png" href=/oscar-static/images/favicons/springerlink/favicon-32x32-61a52d80ab.png />
<link rel="icon" sizes="48x48" type="image/png" href=/oscar-static/images/favicons/springerlink/favicon-48x48-0ec46b6b10.png />
<link rel="apple-touch-icon" href=/oscar-static/images/favicons/springerlink/app-icon-iphone@3x-f259d46347.png />
<link rel="apple-touch-icon" sizes="72x72" href=/oscar-static/images/favicons/springerlink/ic_launcher_hdpi-f77cda7f65.png />
<link rel="apple-touch-icon" sizes="76x76" href=/oscar-static/images/favicons/springerlink/app-icon-ipad-c3fd26520d.png />
<link rel="apple-touch-icon" sizes="114x114" href=/oscar-static/images/favicons/springerlink/app-icon-114x114-3d7d4cf9f3.png />
<link rel="apple-touch-icon" sizes="120x120" href=/oscar-static/images/favicons/springerlink/app-icon-iphone@2x-67b35150b3.png />
<link rel="apple-touch-icon" sizes="144x144" href=/oscar-static/images/favicons/springerlink/ic_launcher_xxhdpi-986442de7b.png />
<link rel="apple-touch-icon" sizes="152x152" href=/oscar-static/images/favicons/springerlink/app-icon-ipad@2x-677ba24d04.png />
<link rel="apple-touch-icon" sizes="180x180" href=/oscar-static/images/favicons/springerlink/app-icon-iphone@3x-f259d46347.png />


    
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>

    <link rel="stylesheet" href=/oscar-static/app-springerlink/css/core-article-b0cd12fb00.css media="screen">
    <link rel="stylesheet" id="js-mustard" href=/oscar-static/app-springerlink/css/enhanced-article-92dda72269.css media="only screen and (-webkit-min-device-pixel-ratio:0) and (min-color-index:0), (-ms-high-contrast: none), only all and (min--moz-device-pixel-ratio:0) and (min-resolution: 3e1dpcm)">
    

    
    <script type="text/javascript">
        window.dataLayer = [{"Country":"IT","doi":"10.1007-s10664-019-09781-y","Journal Title":"Empirical Software Engineering","Journal Id":10664,"Keywords":"Bug origins, Bug-introducing changes, First-failing change, SZZ algorithm, Extrinsic bugs, Intrinsic bugs","kwrd":["Bug_origins","Bug-introducing_changes","First-failing_change","SZZ_algorithm","Extrinsic_bugs","Intrinsic_bugs"],"Labs":"Y","ksg":"Krux.segments","kuid":"Krux.uid","Has Body":"Y","Features":[],"Open Access":"Y","hasAccess":"Y","bypassPaywall":"N","user":{"license":{"businessPartnerID":[],"businessPartnerIDString":""}},"Access Type":"subscription","Bpids":"","Bpnames":"","BPID":["1"],"VG Wort Identifier":"vgzm.415900-10.1007-s10664-019-09781-y","Full HTML":"Y","Subject Codes":["SCI","SCI14002","SCI14037"],"pmc":["I","I14002","I14037"],"session":{"authentication":{"loginStatus":"N"},"attributes":{"edition":"academic"}},"content":{"serial":{"eissn":"1573-7616","pissn":"1382-3256"},"type":"Article","category":{"pmc":{"primarySubject":"Computer Science","primarySubjectCode":"I","secondarySubjects":{"1":"Software Engineering/Programming and Operating Systems","2":"Programming Languages, Compilers, Interpreters"},"secondarySubjectCodes":{"1":"I14002","2":"I14037"}},"sucode":"SC6"},"attributes":{"deliveryPlatform":"oscar"}},"Event Category":"Article","GA Key":"UA-26408784-1","DOI":"10.1007/s10664-019-09781-y","Page":"article","page":{"attributes":{"environment":"live"}}}];
        var event = new CustomEvent('dataLayerCreated');
        document.dispatchEvent(event);
    </script>


    


<script src="/oscar-static/js/jquery-220afd743d.js" id="jquery"></script>

<script>
    function OptanonWrapper() {
        dataLayer.push({
            'event' : 'onetrustActive'
        });
    }
</script>


    <script data-test="onetrust-link" type="text/javascript" src="https://cdn.cookielaw.org/consent/6b2ec9cd-5ace-4387-96d2-963e596401c6.js" charset="UTF-8"></script>





    <script>
    window.config = window.config || {};
    window.config.mustardcut = false;

    
    if (window.matchMedia && window.matchMedia('only screen and (-webkit-min-device-pixel-ratio:0) and (min-color-index:0), (-ms-high-contrast: none), only all and (min--moz-device-pixel-ratio:0) and (min-resolution: 3e1dpcm)').matches) {
        window.config.mustardcut = true;
    }
</script>

    
    
        <!-- Google Tag Manager -->
        <script data-test="gtm-head">
            if (window.config.mustardcut) {
                (function (w, d, s, l, i) {
                    w[l] = w[l] || [];
                    w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
                    var f = d.getElementsByTagName(s)[0],
                            j = d.createElement(s),
                            dl = l != 'dataLayer' ? '&l=' + l : '';
                    j.async = true;
                    j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
                    f.parentNode.insertBefore(j, f);
                })(window, document, 'script', 'dataLayer', 'GTM-WCF9Z9');
            }
        </script>
        <!-- End Google Tag Manager -->
    


    <script class="js-entry">
    if (window.config.mustardcut) {
        (function(w, d) {
            
            
            
                window.Component = {};
            

            var currentScript = d.currentScript || d.head.querySelector('script.js-entry');

            
            function catchNoModuleSupport() {
                var scriptEl = d.createElement('script');
                return (!('noModule' in scriptEl) && 'onbeforeload' in scriptEl)
            }

            var headScripts = [
                {'src': '/oscar-static/js/polyfill-es5-bundle-1d169163b6.js', 'async': false, 'module': false},
                {'src': '/oscar-static/js/airbrake-es5-bundle-b9c2ac74ec.js', 'async': false, 'module': false},
                {'src': '/oscar-static/js/airbrake-es6-bundle-199a69f0a5.js', 'async': false, 'module': true}
            ];

            var bodyScripts = [
                {'src': '/oscar-static/js/app-es5-bundle-461b219dac.js', 'async': false, 'module': false},
                {'src': '/oscar-static/js/app-es6-bundle-a44158b15b.js', 'async': false, 'module': true}
                
                
                    , {'src': '/oscar-static/js/global-article-es5-bundle-78410e1423.js', 'async': false, 'module': false},
                    {'src': '/oscar-static/js/global-article-es6-bundle-94baff64b9.js', 'async': false, 'module': true}
                
            ];

            function createScript(script) {
                var scriptEl = d.createElement('script');
                scriptEl.src = script.src;
                scriptEl.async = script.async;
                if (script.module === true) {
                    scriptEl.type = "module";
                    if (catchNoModuleSupport()) {
                        scriptEl.src = '';
                    }
                } else if (script.module === false) {
                    scriptEl.setAttribute('nomodule', true)
                }
                if (script.charset) {
                    scriptEl.setAttribute('charset', script.charset);
                }

                return scriptEl;
            }

            for (var i = 0; i < headScripts.length; ++i) {
                var scriptEl = createScript(headScripts[i]);
                currentScript.parentNode.insertBefore(scriptEl, currentScript.nextSibling);
            }

            d.addEventListener('DOMContentLoaded', function() {
                for (var i = 0; i < bodyScripts.length; ++i) {
                    var scriptEl = createScript(bodyScripts[i]);
                    d.body.appendChild(scriptEl);
                }
            });

            // Webfont repeat view
            var config = w.config;
            if (config && config.publisherBrand && sessionStorage.fontsLoaded === 'true') {
                d.documentElement.className += ' webfonts-loaded';
            }
        })(window, document);
    }
</script>

</head>
<body class="shared-article-renderer">
    
    
    
        <!-- Google Tag Manager (noscript) -->
        <noscript data-test="gtm-body">
            <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WCF9Z9"
            height="0" width="0" style="display:none;visibility:hidden"></iframe>
        </noscript>
        <!-- End Google Tag Manager (noscript) -->
    


    <div class="u-vh-full">
        
    <aside class="c-ad c-ad--728x90" data-test="springer-doubleclick-ad">
        <div class="c-ad__inner">
            <p class="c-ad__label">Advertisement</p>
            <div id="div-gpt-ad-LB1" data-gpt-unitpath="/270604982/springerlink/10664/article" data-gpt-sizes="728x90" data-gpt-targeting="pos=LB1;articleid=9781;"></div>
        </div>
    </aside>

<div class="u-position-relative">
    <header class="c-header u-mb-24" data-test="publisher-header">
        <div class="c-header__container">
            <div class="c-header__brand">
                
    <a id="logo" class="u-display-block" href="/" title="Go to homepage" data-test="springerlink-logo">
        <picture>
            <source type="image/svg+xml" srcset=/oscar-static/images/springerlink/svg/springerlink-253e23a83d.svg>
            <img src=/oscar-static/images/springerlink/png/springerlink-1db8a5b8b1.png alt="SpringerLink" width="148" height="30" data-test="header-academic">
        </picture>
        
        
    </a>


            </div>
            <div class="c-header__navigation">
                
    
        <button type="button"
                class="c-header__link u-button-reset u-mr-24"
                data-expander
                data-expander-target="#popup-search"
                data-expander-autofocus="firstTabbable"
                data-test="header-search-button">
            <span class="u-display-flex u-align-items-center">
                Search
                <svg class="c-icon u-ml-8" width="22" height="22" aria-hidden="true" focusable="false">
                    <use xlink:href="#global-icon-search"></use>
                </svg>
            </span>
        </button>
        <nav>
            <ul class="c-header__menu">
                
                <li class="c-header__item">
                    <a data-test="login-link" class="c-header__link" href="//link.springer.com/signup-login?previousUrl=https%3A%2F%2Flink.springer.com%2Farticle%2F10.1007%2Fs10664-019-09781-y">Log in</a>
                </li>
                

                
            </ul>
        </nav>
    

    



            </div>
        </div>
    </header>

    
        <div id="popup-search" class="c-popup-search u-mb-16 js-header-search u-js-hide">
            <div class="c-popup-search__content">
                <div class="u-container">
                    <div class="c-popup-search__container" data-test="springerlink-popup-search">
                        <div class="app-search">
    <form role="search" method="GET" action="/search" >
        <label for="search" class="app-search__label">Search SpringerLink</label>
        <div class="app-search__content">
            <input id="search" class="app-search__input" data-search-input autocomplete="off" role="textbox" name="query" type="text" value="">
            <button class="app-search__button" type="submit">
                <span class="u-visually-hidden">Search</span>
                <svg class="c-icon" width="14" height="14" aria-hidden="true" focusable="false">
                    <use xlink:href="#global-icon-search"></use>
                </svg>
            </button>
            
                <input type="hidden" name="searchType" value="publisherSearch">
            
            
        </div>
    </form>
</div>

                    </div>
                </div>
            </div>
        </div>
    
</div>

        

    <div class="u-container u-mt-32 u-mb-32 u-clearfix" id="main-content" data-component="article-container">
        <main class="c-article-main-column u-float-left js-main-column" data-track-component="article body">
            
                
                <div class="c-context-bar u-hide" data-component="context-bar" aria-hidden="true">
                    <div class="c-context-bar__container u-container">
                        <div class="c-context-bar__title">
                            How bugs are born: a model to identify how bugs are introduced in software components
                        </div>
                        
    
    <div class="c-pdf-download u-clear-both">
        <a href="https://link.springer.com/content/pdf/10.1007/s10664-019-09781-y.pdf" class="c-pdf-download__link" data-article-pdf="true" data-readcube-pdf-url="true" data-test="pdf-link" data-draft-ignore="true" data-track="click" data-track-action="download pdf" data-track-label="button">
            
                <span>Download PDF</span>
                <svg aria-hidden="true" focusable="false" width="16" height="16" class="u-icon"><use xlink:href="#global-icon-download"/></svg>
            
        </a>
    </div>
    

                    </div>
                </div>
            

            <div class="c-pdf-button__container">
                
    
    <div class="c-pdf-download u-clear-both">
        <a href="https://link.springer.com/content/pdf/10.1007/s10664-019-09781-y.pdf" class="c-pdf-download__link" data-article-pdf="true" data-readcube-pdf-url="true" data-test="pdf-link" data-draft-ignore="true" data-track="click" data-track-action="download pdf" data-track-label="button">
            
                <span>Download PDF</span>
                <svg aria-hidden="true" focusable="false" width="16" height="16" class="u-icon"><use xlink:href="#global-icon-download"/></svg>
            
        </a>
    </div>
    

            </div>

            <article itemscope itemtype="http://schema.org/ScholarlyArticle" lang="en">
                <div class="c-article-header">
                    <header>
                        <ul class="c-article-identifiers" data-test="article-identifier">
                            
    
    
        <li class="c-article-identifiers__item">
            <span class="c-article-identifiers__open" data-test="open-access">Open Access</span>
        </li>
    
    

                            <li class="c-article-identifiers__item"><a href="#article-info" data-track="click" data-track-action="publication date" data-track-label="link">Published: <time datetime="2020-02-04" itemprop="datePublished">04 February 2020</time></a></li>
                        </ul>

                        
                        <h1 class="c-article-title" data-test="article-title" data-article-title="" itemprop="name headline">How bugs are born: a model to identify how bugs are introduced in software components</h1>
                        <ul class="c-author-list js-etal-collapsed" data-etal="25" data-etal-small="3" data-test="authors-list" data-component-authors-activator="authors-list"><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Gema-Rodr_guez_P_rez" data-author-popup="auth-Gema-Rodr_guez_P_rez">Gema Rodríguez-Pérez</a></span><sup class="u-js-hide"><a href="#Aff1">1</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="University of Waterloo" /><meta itemprop="address" content="grid.46078.3d, 0000 0000 8644 1405, University of Waterloo, Waterloo, ON, N2L 3G1, Canada" /></span></sup>, </li><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Gregorio-Robles" data-author-popup="auth-Gregorio-Robles" data-corresp-id="c1">Gregorio Robles<svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-email"></use></svg></a></span><sup class="u-js-hide"><a href="#Aff2">2</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="Universidad Rey Juan Carlos" /><meta itemprop="address" content="grid.28479.30, 0000 0001 2206 5938, Universidad Rey Juan Carlos, Madrid, Spain" /></span></sup>, </li><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Alexander-Serebrenik" data-author-popup="auth-Alexander-Serebrenik">Alexander Serebrenik</a></span><sup class="u-js-hide"><a href="#Aff3">3</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="Eindhoven University of Technology" /><meta itemprop="address" content="grid.6852.9, 0000 0004 0398 8763, Eindhoven University of Technology, Eindhoven, The Netherlands" /></span></sup>, </li><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Andy-Zaidman" data-author-popup="auth-Andy-Zaidman">Andy Zaidman</a></span><sup class="u-js-hide"><a href="#Aff4">4</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="Delft University of Technology" /><meta itemprop="address" content="grid.5292.c, 0000 0001 2097 4740, Delft University of Technology, Delft, The Netherlands" /></span></sup>, </li><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Daniel_M_-Germ_n" data-author-popup="auth-Daniel_M_-Germ_n">Daniel M. Germán</a></span><sup class="u-js-hide"><a href="#Aff5">5</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="University of Victoria" /><meta itemprop="address" content="grid.143640.4, 0000 0004 1936 9465, University of Victoria, Victoria, BC, V8P 5C2, Canada" /></span></sup> &amp; </li><li class="c-author-list__item" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a data-test="author-name" data-track="click" data-track-action="open author" data-track-label="link" href="#auth-Jesus_M_-Gonzalez_Barahona" data-author-popup="auth-Jesus_M_-Gonzalez_Barahona">Jesus M. Gonzalez-Barahona</a></span><sup class="u-js-hide"><a href="#Aff2">2</a><span itemprop="affiliation" itemscope="itemscope" itemtype="http://schema.org/Organization" class="u-visually-hidden"><meta itemprop="name" content="Universidad Rey Juan Carlos" /><meta itemprop="address" content="grid.28479.30, 0000 0001 2206 5938, Universidad Rey Juan Carlos, Madrid, Spain" /></span></sup> </li></ul>
                        <p class="c-article-info-details" data-container-section="info">
                            
    <a data-test="journal-link" href="/journal/10664"><i data-test="journal-title">Empirical Software Engineering</i></a>

                            <b data-test="journal-volume"><span class="u-visually-hidden">volume</span> 25</b>, <span class="u-visually-hidden">pages</span><span itemprop="pageStart">1294</span>–<span itemprop="pageEnd">1340</span>(<span data-test="article-publication-year">2020</span>)<a href="#citeas" class="c-article-info-details__cite-as u-hide-print" data-track="click" data-track-action="cite this article" data-track-label="link">Cite this article</a>
                        </p>
                        
    

                        <div data-test="article-metrics">
                            <div id="altmetric-container">
    
        <div class="c-article-metrics-bar__wrapper u-clear-both">
            <ul class="c-article-metrics-bar u-list-reset">
                
                    <li class=" c-article-metrics-bar__item">
                        <p class="c-article-metrics-bar__count">2513 <span class="c-article-metrics-bar__label">Accesses</span></p>
                    </li>
                
                
                
                    
                        <li class="c-article-metrics-bar__item">
                            <p class="c-article-metrics-bar__count">12 <span class="c-article-metrics-bar__label">Altmetric</span></p>
                        </li>
                    
                
                <li class="c-article-metrics-bar__item">
                    <p class="c-article-metrics-bar__details"><a href="/article/10.1007%2Fs10664-019-09781-y/metrics" data-track="click" data-track-action="view metrics" data-track-label="link" rel="nofollow">Metrics <span class="u-visually-hidden">details</span></a></p>
                </li>
            </ul>
        </div>
    
</div>

                        </div>
                        
                        
                        
                    </header>
                </div>

                <div data-article-body="true" data-track-component="article body" class="c-article-body">
                    <section aria-labelledby="Abs1" data-title="Abstract" lang="en"><div class="c-article-section" id="Abs1-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Abs1">Abstract</h2><div class="c-article-section__content" id="Abs1-content"><p>When identifying the origin of software bugs, many studies assume that “a bug was introduced by the lines of code that were modified to fix it”. However, this assumption does not always hold and at least in some cases, these modified lines are not responsible for introducing the bug. For example, when the bug was caused by a change in an external API. The lack of empirical evidence makes it impossible to assess how important these cases are and therefore, to which extent the assumption is valid. To advance in this direction, and better understand how bugs “are born”, we propose a model for defining criteria to identify the first snapshot of an evolving software system that exhibits a bug. This model, based on the <i>perfect test</i> idea, decides whether a bug is observed after a change to the software. Furthermore, we studied the model’s criteria by carefully analyzing how 116 bugs were introduced in two different open source software projects. The manual analysis helped classify the root cause of those bugs and created manually curated datasets with bug-introducing changes and with bugs that were not introduced by any change in the source code. Finally, we used these datasets to evaluate the performance of four existing SZZ-based algorithms for detecting bug-introducing changes. We found that SZZ-based algorithms are not very accurate, especially when multiple commits are found; the F-Score varies from 0.44 to 0.77, while the percentage of true positives does not exceed 63%. Our results show empirical evidence that the prevalent assumption, “a bug was introduced by the lines of code that were modified to fix it”, is just one case of how bugs are introduced in a software system. Finding what introduced a bug is not trivial: bugs can be introduced by the developers and be in the code, or be created irrespective of the code. Thus, further research towards a better understanding of the origin of bugs in software projects could help to improve design integration tests and to design other procedures to make software development more robust.</p></div></div></section>
                    
    


                    

                    

                    
                        
                            <section aria-labelledby="Sec1" data-title="Introduction"><div class="c-article-section" id="Sec1-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec1">Introduction</h2><div class="c-article-section__content" id="Sec1-content"><p>During the life of a software product developers often fix bugs<sup><a href="#Fn1"><span class="u-visually-hidden">Footnote </span>1</a></sup> (Pan et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Pan K, Kim S, Whitehead EJ Jr (2009) Toward an understanding of bug fix patterns. Empir Softw Eng 14(3):286–315" href="/article/10.1007/s10664-019-09781-y#ref-CR78" id="ref-link-section-d79957e638">2009</a>; Murphy-Hill et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Murphy-Hill E, Zimmermann T, Bird C, Nagappan N (2015) The design space of bug fixes and how developers navigate it. IEEE Trans Softw Eng 41(1):65–81" href="/article/10.1007/s10664-019-09781-y#ref-CR68" id="ref-link-section-d79957e641">2015</a>). Research has shown that developers spend half of their time fixing bugs; while they devote only about 36% to adding features (the rest goes to making code more maintainable) (LaToza et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="LaToza TD, Venolia G, DeLine R (2006) Maintaining mental models: a study of developer work habits. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 492–501" href="/article/10.1007/s10664-019-09781-y#ref-CR59" id="ref-link-section-d79957e644">2006</a>). Fixing a bug consists of determining why software is behaving erroneously, and subsequently correcting the part of the component that causes that erroneous behavior (Zeller <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Zeller A (2009) Why programs fail - a guide to systematic debugging, 2nd edn. Academic Press, New York" href="/article/10.1007/s10664-019-09781-y#ref-CR110" id="ref-link-section-d79957e647">2009</a>; Beller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In: Proceedings of the International Conference on Software Engineering (ICSE). ACM, pp 572–583" href="/article/10.1007/s10664-019-09781-y#ref-CR8" id="ref-link-section-d79957e651">2018</a>; Beller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Beller M, Gousios G, Zaidman A (2015) How (much) do developers test?. In: Proceedings of the International Conference on Software Engineering (ICSE), vol 2. IEEE Computer Society, pp 559–562" href="/article/10.1007/s10664-019-09781-y#ref-CR6" id="ref-link-section-d79957e654">2015</a>; Ebert et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Ebert F, Castor F, Serebrenik A (2015) An exploratory study on exception handling bugs in Java programs. J Syst Softw 106:82–101" href="/article/10.1007/s10664-019-09781-y#ref-CR27" id="ref-link-section-d79957e657">2015</a>). A developer fixing a bug produces a change to the source code, which can be identified unambiguously as the bug-fixing change (<b><i>BFC</i></b>). However, identifying what change(s) introduced the bug has proven to be a more difficult task (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e663">2017</a>; Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e666">2018a</a>).</p><p>Nonetheless, identifying the changes that introduced bugs would enable to (1) discover bug introduction patterns which could be used to develop techniques to avoid changes introducing bugs (Hassan <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Hassan AE (2009) Predicting faults using the complexity of code changes. In: IEEE 31st international conference on software engineering, 2009. ICSE 2009. IEEE, pp 78–88" href="/article/10.1007/s10664-019-09781-y#ref-CR39" id="ref-link-section-d79957e672">2009</a>; Hassan and Holt <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Hassan AE, Holt R (2005) The top ten list: Dynamic fault prediction. In: Proceedings of the 21st IEEE international conference on software maintenance, 2005. ICSM’05. IEEE, pp 263–272" href="/article/10.1007/s10664-019-09781-y#ref-CR40" id="ref-link-section-d79957e675">2005</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2007" title="Kim S, Zimmermann T, Whitehead E Jr, Zeller A (2007) Predicting faults from cached history. In: Proceedings of the 29th international conference on software engineering. IEEE Computer Society, pp 489–498" href="/article/10.1007/s10664-019-09781-y#ref-CR56" id="ref-link-section-d79957e678">2007</a>); (2) identify who was responsible for introducing the bug for the sake of self-learning and peer-assessment (Izquierdo-Cortazar et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Izquierdo-Cortazar D, Capiluppi A, Gonzalez-Barahona JM (2011) Are developers fixing their own bugs?: Tracing bug-fixing and bug-seeding committers. International Journal of Open Source Software and Processes (IJOSSP) 3(2):23–42" href="/article/10.1007/s10664-019-09781-y#ref-CR48" id="ref-link-section-d79957e681">2011</a>; da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="da Costa DA, Kulesza U, Aranha E, Coelho R (2014) Unveiling developers contributions behind code commits: an exploratory study. In: Proceedings of the 29th annual ACM symposium on applied computing. ACM, pp 1152–1157" href="/article/10.1007/s10664-019-09781-y#ref-CR21" id="ref-link-section-d79957e684">2014</a>; Ell <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Ell J (2013) Identifying failure inducing developer pairs within developer networks. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 1471–1473" href="/article/10.1007/s10664-019-09781-y#ref-CR28" id="ref-link-section-d79957e688">2013</a>); or (3) understand how long the bug has been present in the code (e.g., to infer how many released versions have been affected or how effective the project testing/verification strategy is (Rodriguez-Perez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="Rodriguez-Perez G, Robles G, Gonzalez-Barahona JM (2017) How much time did it take to notify a bug?: two case studies: elasticsearch and nova. In: Proceedings of the 8th workshop on emerging trends in software metrics. IEEE Press, pp 29–35" href="/article/10.1007/s10664-019-09781-y#ref-CR85" id="ref-link-section-d79957e691">2017</a>; Chen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91" href="/article/10.1007/s10664-019-09781-y#ref-CR19" id="ref-link-section-d79957e694">2014</a>; Weiss et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2007" title="Weiss C, Premraj R, Zimmermann T, Zeller A (2007) How long will it take to fix this bug? In: Fourth international workshop on mining software repositories, 2007. ICSE Workshops MSR’07. IEEE, pp 1–1" href="/article/10.1007/s10664-019-09781-y#ref-CR103" id="ref-link-section-d79957e697">2007</a>)). For these, among other reasons, identifying what changes introduced bugs has been a very active area of research over the last decade (Abreu and Premraj <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Abreu R, Premraj R (2009) How developer communication frequency relates to bug introducing changes. In: Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops. ACM, pp 153–158." href="/article/10.1007/s10664-019-09781-y#ref-CR1" id="ref-link-section-d79957e700">2009</a>; Aranda and Venolia <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Aranda J, Venolia G (2009) The secret life of bugs: Going past the errors and omissions in software repositories. In: Proceedings of the 31st international conference on software engineering. IEEE Computer Society, pp 298–308" href="/article/10.1007/s10664-019-09781-y#ref-CR3" id="ref-link-section-d79957e703">2009</a>; da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e707">2017</a>).</p><p>The vast majority of this research is based on the assumption that <i>a bug was introduced by the lines of code that were modified to fix it</i> (Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e716">2005</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e719">2006</a>; Williams and Spacco <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36" href="/article/10.1007/s10664-019-09781-y#ref-CR104" id="ref-link-section-d79957e722">2008</a>). Although the literature frequently uses this assumption, there is not enough empirical evidence supporting it. Indeed, recent studies have demonstrated that well-known algorithms based on this assumption (such as the approach proposed by Sliwerski, Zimmermann, and Zeller (SZZ) (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e725">2005</a>)) tend to incorrectly identify the bug-introducing changes (<b><i>BIC</i></b><i>s</i>) (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e734">2017</a>; Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e737">2018a</a>). For some bugs an explicit change introducing it does not even exist; the system behaves incorrectly due to changes that are external to the system (German et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="German DM, Hassan AE, Robles G (2009) Change impact graphs: Determining the impact of prior codechanges. Inf Softw Technol 51(10):1394–1408" href="/article/10.1007/s10664-019-09781-y#ref-CR34" id="ref-link-section-d79957e740">2009</a>; Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e743">2018b</a>).</p><p>In this work we focus on analyzing how bugs were introduced in a software component, therefore we evaluate whether the aforementioned assumption holds.</p><p>For a major part, this work has been possible because in modern software development the history of a software product is typically recorded in a source code management (<b><i>SCM</i></b>) system, which enables researchers to retrieve and trace all changes to its source code, and understand the reasons why a change fixed a bug.</p><p>We selected two open source projects, Nova and ElasticSearch, as exploratory case studies to understand and locate, whenever possible, what change(s) introduced bugs and their characteristics. We analyze those cases in which a <i>BFC</i> in the SCM of Nova and ElasticSearch can be associated with a bug. To accomplish this task, we identify bugs in the system using the issue tracker system (<b><i>ITS</i></b>) (bugs that were fixed directly in the source code without an entry in the bug tracker system (Aranda and Venolia <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Aranda J, Venolia G (2009) The secret life of bugs: Going past the errors and omissions in software repositories. In: Proceedings of the 31st international conference on software engineering. IEEE Computer Society, pp 298–308" href="/article/10.1007/s10664-019-09781-y#ref-CR3" id="ref-link-section-d79957e765">2009</a>) are outside the scope of this research). The ITS links directly to the change (commit) that fixed the bug (its <i>BFC</i>). Using this information, we will navigate back the history of the source code to identify the origin for each of the bugs in both case studies.</p><h3 class="c-article__sub-heading" id="Sec2">Goal: A Model of How Bugs Were Introduced</h3><p>Based on this analysis, we propose a model of how bugs were introduced, from which the assumption that <i>a bug was introduced by the lines of code that were modified to fix it</i> can be derived as a specific case. The model classifies bugs into two categories: (1) <b>intrinsic bugs</b>: bugs that were introduced by one or more specific changes to the source code; and (2) <b>extrinsic bugs</b>: bugs that were introduced by changes not registered in the SCM (e.g., from an external dependency), or changes in requirements.</p><p>The proposed model will be of help in the complex task of identifying the origin of bugs, particularly, the idea of the “perfect test”. This idea is fundamental (1) to decide whether a <b>snapshot</b><sup><a href="#Fn2"><span class="u-visually-hidden">Footnote </span>2</a></sup> of a software component is affected by a bug; and (2) to identify which version of a software component exhibits the bug for the first time. Furthermore, this model is necessary for two main reasons: (1) its application in real-world cases provides the formalisms (e.g., definitions) to create a manually curated dataset with bug-introducing changes, when they exist; and (2) it can precisely define criteria to decide the first manifestation of a bug in the history of an open source software product.</p><p>The current absence of such criteria causes ambiguity of what snapshot should be considered as “exhibiting a bug”, which renders any approach to find the <i>BIC</i> arguable. For example, software may work properly until the system where it runs on upgrades a library it depends on (an event that might not be recorded in version control). Note that in this scenario the same snapshot does not exhibit the bug before the library upgrade, but exhibits the bug after.</p><p>In such a case, the changed lines by the <i>BFC</i> were not the cause of the bug (these lines were correct until the upgrade). Our proposed model establishes criteria that allow researchers to determine that the snapshot after the upgrade did not introduce the bug but, it exhibited the bug for the first time.</p><p>In the previous example, the snapshot that first exhibited the bug was the one that was run after the library upgrade. However, which snapshot exhibits the bug? The one before the library upgrade, or any version that exhibits the bug after the library upgrade? Currently, there is not a common way to assess that the changes identified as first exhibiting the bug by current approaches (Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e812">2005</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e815">2006</a>; Thung et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Thung F, Lo D, Jiang L (2013) Automatic recovery of root causes from bug-fixing changes. In: 2013 20th working conference on reverse engineering (WCRE). IEEE, pp 92–101" href="/article/10.1007/s10664-019-09781-y#ref-CR99" id="ref-link-section-d79957e818">2013</a>) are true/false positives/negatives since they do not have into account this example.</p><p>Hence, in this paper, we set out to address the following question:</p><blockquote class="c-blockquote"><div class="c-blockquote__body"><p><i>“How can we identify the origin of a defect based on information in source control systems?”</i></p></div></blockquote><h3 class="c-article__sub-heading" id="Sec3">Research Questions</h3><p>In particular, to answer our central question, we first defined specific criteria that help determine whether a change in the source code introduced a bug, and the moment this change was introduced. Then, we studied these criteria in some real-world cases. Thus, we addressed the following research questions (RQs):
</p><ul class="u-list-style-dash"><li><p><b>RQ1</b>: Is there a criteria to help researchers find a useful classification of changes leading to bugs? <b>Motivation:</b> Our designed model provides defined criteria to decide whether a certain bug is present in a snapshot. However, we need to ensure that these criteria can be applied to real-world projects to determine whether a change in the source code introduced a bug. Thus, we used the model to understand and classify the root cause in 116 bugs. This process produced two manually curated datasets that contain a collection of bugs, and information on a) the change to the source code that introduced the bug, or b) the absence of such a change.</p></li><li><p><b>RQ2</b>: Do these criteria help in defining precision and recall in four existing SZZ-based algorithms for detecting bug-introducing changes? <b>Motivation:</b> The positive answer to RQ1, at least for some cases, helped us create manually curated datasets that may be considered as the “ground truth” for some bugs. We use this “ground truth” datasets to compare four existing SZZ-based algorithms that identify <i>BICs</i> and compute their performance (in terms of precision, recall and F-score), and compare them against each other. The analysis of the results helps to find ways to improve them.</p></li></ul><h3 class="c-article__sub-heading" id="Sec4">Contributions</h3><p>This work is a further development of our preliminary work (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e864">2018b</a>), which we are extending with the following main results, based on prior literature and empirical findings:
</p><ol class="u-list-style-none"><li><span class="u-custom-list-number">1.</span><p>A <b>model</b> that, given a <i>BFC</i>, describes when the corresponding bug was introduced, consisting of (i) a set of explicit assumptions on how bugs were introduced, (ii) specific criteria for deciding whether a bug is present in a snapshot, (iii) a process for determining which change in the source introduced the bug, or the knowledge that it was not introduced by a change, and (iv) a proposed terminology of the components that play a role in the bug introduction process.</p></li><li><span class="u-custom-list-number">2.</span><p>An <b>operationalization of the process to determine which change first exhibited the bug</b> that can be used to (i) classify the bug as intrinsic or extrinsic, (ii) identify the first snapshot that contains the bug.</p></li><li><span class="u-custom-list-number">3.</span><p>A <b>unified terminology</b> with all relevant concepts involved in the origin of bugs. A common terminology is needed because we have found in the literature that scholars use different wording for the same concepts or, even worse, use the same wording for different concepts. This situation hinders the understanding of the bug origin problem and can be solved with a unified terminology.</p></li><li><span class="u-custom-list-number">4.</span><p>An <b>empirical study on two open source software systems</b> (ElasticSearch and Nova) that exemplifies how our model and operationalization can be applied to two real open source projects. The result of this study is a manual curated reference dataset that annotates a set of bug fixing changes with the change that introduced the bug, or with the absence of such a change (in our case we do it for a collection of 116 bug reports).</p></li><li><span class="u-custom-list-number">5.</span><p>An <b>evaluation of the performance</b> of four existing SZZ-based algorithms for the identification of <i>BICs</i>. This evaluation provides further insights on how these algorithms could be improved.</p></li></ol><p>The rest of this paper is structured as follows. We first introduce some motivating examples in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a> to support the convenience of developing a model to describe how bugs were introduced. Related work is presented in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec6">3</a>. Then, we introduce the general framework and the assumptions we consider, in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec7">4</a>. Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec25">5</a> describes the model, the associated terminology and the process to determine which change first exhibited the bug. Then, Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec28">6</a> details the operationalization of these process. Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec29">7</a> introduces the case studies and the empirical results. Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec34">8</a> discusses potential applications, guidelines and improvements, and reports on threats to validity. Finally, we draw conclusions and point out potential future research in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec40">9</a>.</p></div></div></section><section aria-labelledby="Sec5" data-title="Background and Motivation Examples"><div class="c-article-section" id="Sec5-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec5">Background and Motivation Examples</h2><div class="c-article-section__content" id="Sec5-content"><p>Software is prone to defects due to its inherent complexity and the developers’ difficulties to understand its design (Itkonen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2007" title="Itkonen J, Mantyla MV, Lassenius C (2007) Defect detection efficiency: Test case based vs. exploratory testing. In: First international symposium on empirical software engineering and measurement, 2007. ESEM 2007. IEEE, pp 61–70" href="/article/10.1007/s10664-019-09781-y#ref-CR47" id="ref-link-section-d79957e951">2007</a>). Therefore, defects and how they are introduced in code have been an active area of research (see Basili and Perricone (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1984" title="Basili VR, Perricone BT (1984) Software errors and complexity: an empirical investigation. Commun ACM 27(1):42–52" href="/article/10.1007/s10664-019-09781-y#ref-CR4" id="ref-link-section-d79957e954">1984</a>), Mockus and Weiss (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2000" title="Mockus A, Weiss DM (2000) Predicting risk of software changes. Bell Labs Technical Journal 5(2):169–180" href="/article/10.1007/s10664-019-09781-y#ref-CR66" id="ref-link-section-d79957e957">2000</a>), and Boehm and Basili (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Boehm B, Basili VR (2005) Software defect reduction top 10 list. Foundations of empirical software engineering: the legacy of Victor R Basili 426(37):426–431" href="/article/10.1007/s10664-019-09781-y#ref-CR14" id="ref-link-section-d79957e960">2005</a>) for some seminal work on the matter of understanding and classifying how defects are introduced). According to IEEE Standard 1044 (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE" href="/article/10.1007/s10664-019-09781-y#ref-CR45" id="ref-link-section-d79957e963">2009</a>), a defect is “<i>an imperfection or deficiency in a work product where that work product does not meet its requirements or specifications and needs to be either repaired or replaced</i>”. When the defect is present in software, it is considered a “fault” (<i>manifestation of an error in software</i>). A defect/fault can be introduced in different phases of a software product life (e.g., planning, coding, deployment) due to many reasons, such as missing or changing requirements, wrong specifications, miscommunication, programming errors, time pressure, poorly documented code, among others (Nakajo and Kume <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1991" title="Nakajo T, Kume H (1991) A case history analysis of software error cause-effect relationships. IEEE Trans Softw Eng 17(8):830–838" href="/article/10.1007/s10664-019-09781-y#ref-CR70" id="ref-link-section-d79957e973">1991</a>; Jacobs et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2007" title="Jacobs J, Van Moll J, Kusters R, Trienekens J, Brombacher A (2007) Identification of factors that influence defect injection and detection in development of software intensive products. Inf Softw Technol 49(7):774–789" href="/article/10.1007/s10664-019-09781-y#ref-CR50" id="ref-link-section-d79957e976">2007</a>; Nuseibeh and Easterbrook <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2000" title="Nuseibeh B, Easterbrook S (2000) Requirements engineering: a roadmap. In: Proceedings of the conference on the future of software engineering. ACM, pp 35–46" href="/article/10.1007/s10664-019-09781-y#ref-CR73" id="ref-link-section-d79957e979">2000</a>). When the software is executed and the system produces wrong results, defects may lead to failures, described as “<i>[e]vents in which a system or system component does not perform a required function within specified limits</i>” (Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE" href="/article/10.1007/s10664-019-09781-y#ref-CR45" id="ref-link-section-d79957e986">2009</a>). Developers, and in many cases researchers too, typically use the term “bug” to refer both to defects/faults (deficiencies) and failures (their manifestation), depending on the context. For example, “fixing a bug” usually means “fixing a failure by correcting the faulty code” while “reporting a bug” means “reporting a failure”. A single fault may lead to several failures and, in some cases, a single failure may be caused by several faults. Through this paper, we will use in general the term “bug”, trying to specify, when that is relevant and is not obvious from the context, if we refer to failures or faults. We will also assume that when a “bug is fixed” means that “a failure was fixed by correcting at least one fault”. In general, we will be interested in the first fault (per order of introduction in the source code), in case there are more that one causing a failure.</p><p>However, neither IEEE 1044 (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE" href="/article/10.1007/s10664-019-09781-y#ref-CR45" id="ref-link-section-d79957e992">2009</a>) nor ISO/IEC 9126 (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2001" title="ISO/IEC (2001) ISO/IEC 9126. Software engineering – Product quality ISO/IEC" href="/article/10.1007/s10664-019-09781-y#ref-CR46" id="ref-link-section-d79957e995">2001</a>) provide a way of determining whether some code can be considered buggy (or faulty) <i>when it was written</i>. Of course, researchers and developers may know if some code is considered faulty when a certain failure is fixed, but that is not enough to know if it could also be considered faulty when it was written, or at that time it was perfectly correct, according to the context of the system at that moment. The lack of definitions and some previous unconsidered origins<sup><a href="#Fn3"><span class="u-visually-hidden">Footnote </span>3</a></sup> for bugs (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e1005">2018b</a>) cause difficulties to correctly identify which change introduced a fault, and even if the fault was introduced by it, or by a later change in the context of the system. Furthermore, with a precise definition of “introducing a fault” (from now on, “introducing a bug”), researchers can identify whether a change that exhibits a given bug is also the change responsible for introducing it (i.e., the bug-introducing change (<i>BIC</i>)) or whether this change corresponds to the first time that the system manifested the bug. In other words, the fact that before a given change the system does not exhibit a bug, but after it, the bug appears, is not enough to consider that the change introduced the bug.</p><p>We will refer to this later case with the concept of “first-failing change” (<b><i>FFC</i></b>), in the sense that this change did not introduce the bug, but there was a “first-failing moment” (<b>FFM</b>) –not recorded in the SCM– in which the bug manifests itself for the first time. Thus, in this work, when there is an intrinsic bug, the bug-introducing change, the first-failing change and the first-failing moment are the same (see Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig1">1</a>). However, when there is an extrinsic bug, there is no bug-introducing change in the SCM and the first-failing change is the commit in our SCM right after the first-failing moment occurs (see Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig2">2</a>).
</p><div class="c-article-section__figure c-article-section__figure--no-border" data-test="figure" data-container-section="figure" id="figure-g"><figure><div class="c-article-section__figure-content" id="Figg"><div class="c-article-section__figure-item"><div class="c-article-section__figure-content"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figg_HTML.png?as=webp"></source><img aria-describedby="figure-g-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figg_HTML.png" alt="figureg" loading="lazy" width="685" height="100" /></picture></div></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-g-desc"></div></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-1" data-title="Fig. 1"><figure><figcaption><b id="Fig1" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 1</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/1" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig1_HTML.png?as=webp"></source><img aria-describedby="figure-1-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig1_HTML.png" alt="figure1" loading="lazy" width="685" height="158" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-1-desc"><p>Intrinsic bug: the bug-introducing change (<i>BIC</i>) is recorded in the source code management (<i>SCM</i>). The first-failing change (<i>FFC</i>) and the first-failing moment (<i>FFM</i>) coincide with the <i>BIC</i></p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/1" data-track-dest="link:Figure1 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-2" data-title="Fig. 2"><figure><figcaption><b id="Fig2" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 2</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/2" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig2_HTML.png?as=webp"></source><img aria-describedby="figure-2-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig2_HTML.png" alt="figure2" loading="lazy" width="685" height="149" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-2-desc"><p>Extrinsic bug: the first-failing moment (<i>FFM</i>) does not coincide with a change in the source code management (<i>SCM</i>). There is no bug-introducing change (<i>BIC</i>), and the first-failing change (<i>FFC</i>) is the first change recorded in the SCM after the first-failing moment <i>FFM</i></p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/2" data-track-dest="link:Figure2 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><p>Extrinsic bugs are caused by changes that are not recorded in the SCM. These bugs are not the result of introducing faulty code, but might be due to incorrect assumptions, changes in requirements, dependencies on the run-time environment, changes to the environment, bugs in external APIs, among others. As far as we know, this kind of bugs has not been studied before from the perspective of their introduction; this work aims to offer more insights into such bugs. In the next examples, we show some extrinsic bugs and motivate the interest in researching them.
</p>
                <h3 class="c-article__sub-heading" id="FPar1">
                  <i>Example 1</i>
                </h3>
                <p>Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig3">3</a> shows a bug report from the ElasticSearch project.<sup><a href="#Fn4"><span class="u-visually-hidden">Footnote </span>4</a></sup> The bug occurred when downloading a site plugin from GitHub. In this case, the dependency of the source code of ElasticSearch on the GitHub API caused the bug. Around seven months after inserting the original lines, the GitHub API changed and the source code in ElasticSearch became buggy because the plugin no longer worked. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig4">4</a> shows the lines modified to fix the bug. The original version of these lines did not introduce the bug, but they are the lines where the bug manifested itself (after the change in the GitHub API). Thus, there is no change to the source code of ElasticSearch itself that introduced the bug because when those lines were introduced the GitHub API worked as the developer expected. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab1">1</a> summarizes the existence of the bug-introducing change, first-failing change and first-failing moment in this example.
</p><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-3" data-title="Fig. 3"><figure><figcaption><b id="Fig3" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 3</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/3" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig3_HTML.png?as=webp"></source><img aria-describedby="figure-3-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig3_HTML.png" alt="figure3" loading="lazy" width="685" height="266" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-3-desc"><p>ElasticSearch bug report #3551 (Example 1)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/3" data-track-dest="link:Figure3 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-4" data-title="Fig. 4"><figure><figcaption><b id="Fig4" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 4</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/4" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig4_HTML.png?as=webp"></source><img aria-describedby="figure-4-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig4_HTML.png" alt="figure4" loading="lazy" width="685" height="189" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-4-desc"><p>Bug Fixing commit of #3551 (Example 1)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/4" data-track-dest="link:Figure4 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-1"><figure><figcaption class="c-article-table__figcaption"><b id="Tab1" data-test="table-caption">Table 1 First-failing moment (FFM), first-failing change (FFC) and bug-introducing change (BIC) in Example 1</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/1"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
              
                <h3 class="c-article__sub-heading" id="FPar2">
                  <i>Example 2</i>
                </h3>
                <p>Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig5">5</a> offers another bug report from ElasticSearch<sup><a href="#Fn5"><span class="u-visually-hidden">Footnote </span>5</a></sup>. This bug pertains to setting permissions in subdirectories; it was caused by the post-installation script setting all data permissions to 644 inside of <span class="u-monospace">/etc/elasticsearch</span>, and failing to set appropriate permissions (755) to subdirectories. The only line that was modified to fix this bug was line 37 (see Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig6">6</a>). However, as directories did not exist in <span class="u-monospace">/etc/elasticsearch</span> when the original version of line 37 was introduced, we can conclude that there is no <i>BIC</i>. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab2">2</a> summarizes the existence of the bug-introducing change, first-failing change and first-failing moment in this example.
</p><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-5" data-title="Fig. 5"><figure><figcaption><b id="Fig5" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 5</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/5" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig5_HTML.png?as=webp"></source><img aria-describedby="figure-5-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig5_HTML.png" alt="figure5" loading="lazy" width="685" height="185" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-5-desc"><p>ElasticSearch bug report #3820 (Example 2)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/5" data-track-dest="link:Figure5 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-6" data-title="Fig. 6"><figure><figcaption><b id="Fig6" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 6</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/6" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig6_HTML.png?as=webp"></source><img aria-describedby="figure-6-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig6_HTML.png" alt="figure6" loading="lazy" width="685" height="181" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-6-desc"><p>Bug Fixing commit of #3820 (Example 2)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/6" data-track-dest="link:Figure6 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-2"><figure><figcaption class="c-article-table__figcaption"><b id="Tab2" data-test="table-caption">Table 2 First-failing moment (FFM), first-failing change (FFC) and bug-introducing change (BIC) in Example 2</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/2"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
              
                <h3 class="c-article__sub-heading" id="FPar3">
                  <i>Example 3</i>
                </h3>
                <p>Some bugs manifest themselves if the software is used in a different environment than it was intended for. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig7">7</a> shows a bug report in Nova describing a failure when using Windows Server 2012; Windows Server 2012 introduced support for projecting a virtual NUMA topology into Hyper-V virtual machines. Here, as well, there is no <i>BIC</i>, and the manifestation of the bug depends on the environment used. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab3">3</a> summarizes the existence of the bug-introducing change, first-failing change and first-failing moment in this example.
</p><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-7" data-title="Fig. 7"><figure><figcaption><b id="Fig7" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 7</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/7" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig7_HTML.png?as=webp"></source><img aria-describedby="figure-7-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig7_HTML.png" alt="figure7" loading="lazy" width="685" height="357" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-7-desc"><p>Bug caused by the operating system where the code is being used (Example 3)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/7" data-track-dest="link:Figure7 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-3"><figure><figcaption class="c-article-table__figcaption"><b id="Tab3" data-test="table-caption">Table 3 First-failing moment (FFM), first-failing change (FFC) and bug-introducing change (BIC) in Example 3</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/3"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
              <p>The bug in Example 1 manifested itself due to a change to an external artefact upon which the software depends. The bug in Example 2 manifested itself due to an incorrect assumption (in this case, an omission of a requirement). Example 3 shows a bug caused by a change in the environment, as the bug manifested when the software was used in a platform it did not officially support at the time of writing the code. These cases are examples of extrinsic bugs, in which there is no bug-introducing change causing the bug.
</p><p>As we can observe, extrinsic bugs are not the result of an explicit change in the SCM. Thus, it is necessary to develop new models to describe their origin.</p></div></div></section><section aria-labelledby="Sec6" data-title="Related Work"><div class="c-article-section" id="Sec6-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec6">Related Work</h2><div class="c-article-section__content" id="Sec6-content"><p>Traditionally, in mining software repositories, researchers identify the lines of source code that introduced the bug assuming that the last change that touched the fixed line(s) in a bug-fixing change (<i>BFC</i>) introduced the bug (Zeller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zeller A, Hughes W, Lavery J, Doran K, Morrison CT, Snodgrass RT, Stärk RF (2011) Causes and effects in computer programs. In: Proceedings of the fifth international workshop on computer, pp 482–508" href="/article/10.1007/s10664-019-09781-y#ref-CR111" id="ref-link-section-d79957e1331">2011</a>; Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e1334">2005</a>; Williams and Spacco <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36" href="/article/10.1007/s10664-019-09781-y#ref-CR104" id="ref-link-section-d79957e1337">2008</a>). Thus, the introduction of bugs has been studied over the last years from the <i>BFC</i> backward by using two different methods: dependency-based and text-based methods.</p><p>Dependency-based approaches use changes in the relationship between control and data in the code. Ottenstein and Ottenstein proposed the first program dependence graph to be used in software engineering (Ottenstein and Ottenstein <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1984" title="Ottenstein KJ, Ottenstein LM (1984) The program dependence graph in a software development environment. ACM Sigplan Notices 19(5):177–184" href="/article/10.1007/s10664-019-09781-y#ref-CR74" id="ref-link-section-d79957e1346">1984</a>). This approach achieves higher accuracy than text-based approaches (Sinha et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2010" title="Sinha VS, Sinha S, Rao S (2010) Buginnings: identifying the origins of a bug. In: Proceedings of the 3rd India software engineering conference. ACM, pp 3–12" href="/article/10.1007/s10664-019-09781-y#ref-CR92" id="ref-link-section-d79957e1349">2010</a>) in identifying the bug-introducing change (<i>BIC</i>), taking into account the semantics of the source code, because it addresses some of the limitations of text-based approaches (Davies et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the origins of bugs. Journal of Software: Evolution and Process 26(1):107–139" href="/article/10.1007/s10664-019-09781-y#ref-CR23" id="ref-link-section-d79957e1355">2014</a>). However, dependency-based approaches are not appropriate for identifying the origins of all bugs because they have some implementation challenges. For instance, these approaches cannot identify the <i>BIC</i> when the <i>BFC</i> s do not change the method’s dependencies.</p><p>On the other hand, the text-based approaches are more popular when identifying the <i>BIC</i> since they pose less implementation challenges (Davies et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the origins of bugs. Journal of Software: Evolution and Process 26(1):107–139" href="/article/10.1007/s10664-019-09781-y#ref-CR23" id="ref-link-section-d79957e1371">2014</a>), thus the related work section focuses on these approaches. Text-based approaches are based on textual differences to discover addition, deletion and modifications lines between the <i>BFC</i> s and its previous version, and then backtrack the modification and deletion lines to identify the change that introduced the bug. The approach proposed by Sliwerski, Zimmermann, and Zeller (SZZ) is a popular text-based algorithm (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e1377">2018a</a>), improving on previous text-based approaches (Čubranic and Murphy <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2003" title="Čubranic D, Murphy GC (2003) Hipikat: Recommending pertinent software development artifacts. In: 25th international conference on software engineering, 2003. Proceedings. IEEE, pp 408–418" href="/article/10.1007/s10664-019-09781-y#ref-CR20" id="ref-link-section-d79957e1380">2003</a>; Fischer et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2003a" title="Fischer M, Pinzger M, Gall H (2003) Analyzing and relating bug report data for feature tracking. In: Proceedings of the 10th working conference on reverse engineering (WCRE). IEEE, pp 90–100" href="/article/10.1007/s10664-019-09781-y#ref-CR29" id="ref-link-section-d79957e1384">2003a</a>; <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2003b" title="Fischer M, Pinzger M, Gall H (2003) Populating a release history database from version control and bug tracking systems. In: International conference on software maintenance, 2003. ICSM 2003. Proceedings. IEEE, pp 23–32" href="/article/10.1007/s10664-019-09781-y#ref-CR30" id="ref-link-section-d79957e1387">2003b</a>). As such, it assumes that the last change that touched the fixed line in a <i>BFC</i> introduced the bug (Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e1393">2005</a>) and relies on historical data to identify changes in the source code that introduced bugs. For that, the algorithm links the SCM and the ITS in order to identify the <i>BFC</i> and then, it identifies the <i>BIC</i>. To that end, it employs the diff functionality to determine the lines that have been changed between the <i>BFC</i> and its previous version and the blame functionality to identify the last change(s) to those lines. Finally, it uses a temporary window from the bug report date until the <i>BFC</i> date to remove false positives.</p><p>Since the inception of SZZ two main improvements have been proposed: Kim et al. used annotation graphs to reduce false positives and gain precision by excluding comments, blank lines, and format changes from the analysis (Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e1412">2006</a>); and Williams and Spacco improved the line mapping algorithm of SZZ by using weights to map the evolution of a line (Williams and Spacco <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36" href="/article/10.1007/s10664-019-09781-y#ref-CR104" id="ref-link-section-d79957e1415">2008</a>). Many studies have largely used these SZZ algorithms to predict, classify and find bugs. Kamei et al. proposed a model to identify defect-prone changes instead of defect-prone files or defect-prone packages; this model allows developers to review these risky changes while they are still fresh in their minds, which is known as ‘Just-in Time Quality Assurance’ (JIT) (Kamei et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Kamei Y, Shihab E, Adams B, Hassan AE, Mockus A, Sinha A, Ubayashi N (2013) A large-scale empirical study of just-in-time quality assurance. IEEE Trans Softw Eng 39(6):757–773" href="/article/10.1007/s10664-019-09781-y#ref-CR52" id="ref-link-section-d79957e1418">2013</a>). Kim et al. showed how to classify file changes as buggy or clean using change information features and source code terms (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Kim S, Whitehead E Jr, Zhang Y (2008) Classifying software changes: Clean or buggy? IEEE Trans Softw Eng 34(2):181–196" href="/article/10.1007/s10664-019-09781-y#ref-CR54" id="ref-link-section-d79957e1421">2008</a>). Tantithamthavorn et al. studied how to improve the bug localization performance assuming that a recently fixed file may be fixed in the near future (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Tantithamthavorn C, Teekavanich R, Ihara A, Matsumoto K-i (2013) Mining a change history to quickly identify bug locations: a case study of the eclipse project. In: 2013 IEEE international symposium on software reliability engineering workshops (ISSREW). IEEE, pp 108–113" href="/article/10.1007/s10664-019-09781-y#ref-CR98" id="ref-link-section-d79957e1424">2013</a>). Nagappan et al. used the SZZ idea of mapping as the base to associate metrics with post-release defects, and built regression models to predict the likelihood of post-release defects for new entities (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Nagappan N, Ball T, Zeller A (2006) Mining metrics to predict component failures. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 452–461" href="/article/10.1007/s10664-019-09781-y#ref-CR69" id="ref-link-section-d79957e1428">2006</a>). Zimmermann et al. used the SZZ to predict bugs in large software systems (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2007" title="Zimmermann T, Premraj R, Zeller A (2007) Predicting defects for Eclipse. In: International workshop on predictor models in software engineering, 2007. PROMISE’07: ICSE workshops 2007. IEEE, pp 9–9" href="/article/10.1007/s10664-019-09781-y#ref-CR112" id="ref-link-section-d79957e1431">2007</a>).</p><p>Recently, Da Costa et al. have made an important effort proposing a framework for evaluating the results of five SZZ implementations. This framework assesses the data generated by SZZ implementations and flags changes as not likely to be <i>BIC</i> s. For that, this framework relies on three criteria: (1) the earliest bug appearance which is related to the number of disagreements that SZZ has with the affected-version reported; (2) the impact that a <i>BIC</i> has in future bugs; and (3) the likelihood that the <i>BIC</i> given by SZZ is the <i>real</i> cause of the bug computed as the difference in days between the first and the last suspicious <i>BIC</i> s; if this difference is several years, the commit is removed. Their findings showed that current SZZ implementations still lack mechanisms to correctly identify <i>real</i><i>BIC</i> s (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e1459">2017</a>). In this work, we describe how to use our model to identify <i>real</i><i>BIC</i> s, which is one of the the major problems of SZZ algorithms. While Da Costa et al. base their study on the reliability of SZZ results with computing metrics, our aim is to describe a model that can help to reason about whether an earlier change in the SCM caused the bug.</p><p>Furthermore, Campos Neto et al. have studied the impact of refactoring changes on SZZ and have proposed the RA-SZZ implementation (<i>Refactoring Aware-SZZ</i>). Refactoring changes are one of the major limitations of SZZ since the algorithm blame them as bug-introducing changes when, in fact, these changes did not introduce the bug because they did not change the system behavior. The authors observed that 6.5% of the lines blamed as <i>BIC</i> s by SZZ were refactoring changes and that 19.9% of the lines removed in a <i>BFC</i> were related to refactoring changes (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e1479">2018</a>). In addition, Campos Neto et al. re-evaluated the RA-SZZ implementation in Defects4J dataset and observed that 44% of the lines identified as <i>BIC</i> s by RA-SZZ are very like to real <i>BIC</i> s. However, there exist refactoring operations (31.17%) and equivalent changes (13.64%) that are misidentified by RA-SZZ (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2019" title="Neto EC, da Costa DA, Kulesza U (2019) Revisiting and improving SZZ implementations. In: 2019 ACM/IEEE International symposium on empirical software engineering and measurement. ACM" href="/article/10.1007/s10664-019-09781-y#ref-CR72" id="ref-link-section-d79957e1489">2019</a>). While Campos Neto et al. assumed that the <i>BIC</i> should be in the evolutionary history of the lines that have been changed in a <i>BFC</i>, our work takes a backward step to understand how bugs were introduced and describe a model that can help with this identification. In our model, the evolution history of the lines that have been changed in a <i>BFC</i> can be derived as a specific case of how bugs were introduced.</p><p>More recently, Sahal and Tosun proposed a way to link the code additions in a fixing change to a list of candidate <i>BIC</i> s (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Sahal E, Tosun A (2018) Identifying bug-inducing changes for code additions. In: Proceedings of the 12th ACM/IEEE international symposium on empirical software engineering and measurement. ACM, p 57" href="/article/10.1007/s10664-019-09781-y#ref-CR90" id="ref-link-section-d79957e1507">2018</a>). The authors state that their approach works well for linking code additions with previous changes, although it still produces many false positives since this approach assumes that the <i>BIC</i> is one of the changes surrounding the new additions in a <i>BFC</i>. Our model helps researchers to understand whether an incomplete change caused a bug and then, the <i>BFC</i> fixed this bug by adding only new lines of source code. However, our model does not assume that the <i>BIC</i> s have to be the changes surrounding the new additions.</p><p>In addition, other studies observed serious limitations when using both dependency-based and text-based approaches. These limitations are addressed in the model proposed in this work. Murphy-Hill et al. observed that when developers fix bugs, they have different options as to how to fix them and each decision may lead to a different location where a bug was introduced (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Murphy-Hill E, Zimmermann T, Bird C, Nagappan N (2015) The design space of bug fixes and how developers navigate it. IEEE Trans Softw Eng 41(1):65–81" href="/article/10.1007/s10664-019-09781-y#ref-CR68" id="ref-link-section-d79957e1526">2015</a>). Qualitatively, the authors showed the many factors that influence how bugs are fixed, most of them being non-technical. These factors may affect bug prediction and localization because the bug fixing cannot be at the same location as the bug, or because the bug fixing might be covering the symptom and not the cause of the bug. Rodríguez-Pérez et al. performed a systematic literature study on the use of the SZZ algorithm and quantify its limitations (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e1529">2018a</a>). Prechelt and Pepper offered an overview of the limitations of the text-based approaches when they are used for <i>Defect-Insertion Circumstance Analysis (DICA)</i> (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Prechelt L, Pepper A (2014) Why software repositories are not used for defect-insertion circumstance analysis more often: A case study. Inf Softw Technol 56 (10):1377–1389" href="/article/10.1007/s10664-019-09781-y#ref-CR79" id="ref-link-section-d79957e1535">2014</a>). The authors observed that <i>BFC</i> s may have touched non-buggy lines, and even when they touched those lines, the actual <i>BIC</i> may have been made earlier. Also, they stated that bugs and issues are not easy to distinguish in bug trackers, causing low reliability when mapping <i>BFC</i> s with <i>BIC</i> s. In particular, the precision of mapping <i>BFC</i> s with <i>BIC</i> s in their case study was only 50% due to changes considered as bugs that, in fact, were not bug reports (e.g., feature request, refactoring). Furthermore, others authors highlighted limitations to map <i>BFC</i> s with <i>BIC</i> s due to some characteristics of the software that can negatively affect textual approaches. For example, German et al. investigated bugs that manifested themselves in unchanged parts of the software and their impact across the whole system (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="German DM, Hassan AE, Robles G (2009) Change impact graphs: Determining the impact of prior codechanges. Inf Softw Technol 51(10):1394–1408" href="/article/10.1007/s10664-019-09781-y#ref-CR34" id="ref-link-section-d79957e1564">2009</a>). Chen et al. studied the impact of dormant bugs (i.e., introduced in a version of the software system, but are not found until much later) on bug localization (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91" href="/article/10.1007/s10664-019-09781-y#ref-CR19" id="ref-link-section-d79957e1567">2014</a>). As opposed to the previous studies that have relied on the lines modified in the <i>BFC</i> s to identify the <i>BIC</i>, this study proposes (1) a model that helps researchers to reasoning whether the origin of a bug is intrinsic or extrinsic; and (2) how researchers can operationalize the model to identify the <i>BIC</i>, when it exists. Our preliminary approach (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e1580">2018b</a>) was the seed to extend the work and provide a more comprehensive description of how to correctly identify <i>BIC</i> s. Furthermore, in this work we detail the process of using the model and its operationalization to build reliable datasets that can be used to evaluate four existing SZZ-based algorithms.</p></div></div></section><section aria-labelledby="Sec7" data-title="The Framework and its Assumptions"><div class="c-article-section" id="Sec7-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec7">The Framework and its Assumptions</h2><div class="c-article-section__content" id="Sec7-content"><p>Given a bug-fixing change (<i>BFC</i>), identifying its bug-introducing change (<i>BIC</i>) is not necessarily straightforward as bugs can have different origins as shown in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a>. Thus, in order to identify when and how bugs were introduced, we designed a model that consists in a framework based on five assumptions. These assumptions enable the framework to describe the first time that the software exhibited the bug according to a <i>BFC</i>.</p><p>The model we propose is based on the following five assumptions:
</p><div class="c-article-section__figure c-article-section__figure--no-border" data-test="figure" data-container-section="figure" id="figure-h"><figure><div class="c-article-section__figure-content" id="Figh"><div class="c-article-section__figure-item"><div class="c-article-section__figure-content"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figh_HTML.png?as=webp"></source><img aria-describedby="figure-h-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figh_HTML.png" alt="figureh" loading="lazy" width="685" height="217" /></picture></div></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-h-desc"></div></div></figure></div><p>The first assumption allows researchers to track how code changes as it evolves, and to recover any past version of it. The second one enables researchers to identify the <i>BFC</i>, and to link it to the contextual information of how the bug was fixed. The third assumption permits researchers to know when the software exhibited the bug that was fixed in the <i>BFC</i>. The fourth one allows researchers to identify whether the bug has been previously introduced in the SCM. And the fifth assumption enables researchers to decide that the bug is no longer present in the <i>BFC</i> snapshot, but it was present in a previous snapshot.</p><p>These assumptions can, to some extent, be implemented with today’s technologies and processes. For some of them, however, we required theoretical conceptualizations and simplifications, as we discuss in an extensive way in the subsequent sections. We, therefore, offer details on how the model implemented each assumption. Furthermore, we inform researchers about known limitations and possible solutions for all assumptions. In those cases where an assumption, due to its theoretical or practical novelty, was elaborated more, we also provide context and introduce the necessary definitions and concepts.</p><h3 class="c-article__sub-heading" id="Sec8">The Model Assumes that there is Version Control for the Software</h3><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec9">Implementation</h4><p>The model assumes that the development history of the project is recorded in the source code management systems (SCM), and that the record is complete, i.e., it starts from the very first change<sup><a href="#Fn6"><span class="u-visually-hidden">Footnote </span>6</a></sup> to the code. Thus, all changes can be tracked because they were done via a version control system (VCS) tool (such as <span class="u-monospace">git</span>). For each change we can recover the state of the system (i.e., snapshots of the system) before and after applying that change; and retrieve the differences between the two snapshots.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec10">Limitations and Solutions</h4><p>Nowadays, the history of a project is recorded in SCM, enabling researchers to reconstruct the process by which the software project was created (Bird et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Bird C, Rigby PC, Barr E, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: 6th IEEE international working conference on mining software repositories, 2009. MSR’09. IEEE, pp 1–10" href="/article/10.1007/s10664-019-09781-y#ref-CR12" id="ref-link-section-d79957e1654">2009</a>). Although old software projects can migrate their history from previous repositories, the migration may not be complete (Gonzalez-Barahona et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Gonzalez-Barahona JM, Robles G, Herraiz I, Ortega F (2014) Studying the laws of software evolution in a long-lived floss project. J Softw Evol Process 26 (7):589–612" href="/article/10.1007/s10664-019-09781-y#ref-CR35" id="ref-link-section-d79957e1657">2014</a>). In addition, the use of SCM imposes some possible limitations that can alter how it was created. For example, changes may have been reordered, deleted or edited (Bird et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Bird C, Rigby PC, Barr E, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: 6th IEEE international working conference on mining software repositories, 2009. MSR’09. IEEE, pp 1–10" href="/article/10.1007/s10664-019-09781-y#ref-CR12" id="ref-link-section-d79957e1660">2009</a>). In particular, commits in a pull-request might be reworked (in response to comments), and only those that are the result of the peer-review can be observed (Kalliamvakou et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Kalliamvakou E, Gousios G, Blincoe K, Singer L, German DM, Damian D (2014) The promises and perils of mining GitHub. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 92–101" href="/article/10.1007/s10664-019-09781-y#ref-CR51" id="ref-link-section-d79957e1663">2014</a>). Another aspect to take into consideration is the effect of gatekeepers, who act as a filter/dispatcher for the incoming changes (Gousios et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Gousios G, Zaidman A, Storey MD, van Deursen A (2015) Work practices and challenges in pull-based development: the integrator’s perspective. In: Bertolino A., Canfora G., Elbaum S.G. (eds) 37th IEEE/ACM international conference on software engineering, ICSE 2015, Florence, Italy, May 16-24, 2015, vol 1. IEEE Computer Society, pp 358–368" href="/article/10.1007/s10664-019-09781-y#ref-CR36" id="ref-link-section-d79957e1666">2015</a>; Canfora et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Canfora G, Cerulo L, Cimitile M, Di Penta M (2011) Social interactions around cross-system bug fixings: the case of freebsd and openbsd. In: Proceedings of the 8th working conference on mining software repositories. ACM, pp 143–152" href="/article/10.1007/s10664-019-09781-y#ref-CR16" id="ref-link-section-d79957e1670">2011</a>).</p><h3 class="c-article__sub-heading" id="Sec11">The Model Assumes that it has means to Identify the Bug-Fixing Change (<i>BFC</i>)</h3><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec12">Implementation</h4><p>When a bug report is closed by a <i>BFC</i>, the model assumes that it has means for linking the <i>BFC</i> with the bug report. If the system also uses a code review system, the model assumes there is a way to find the discussion corresponding to a given <i>BFC</i>. Therefore, a bug report can be linked to its <i>BFC</i> and the information related to its review.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec13">Limitations and Solutions</h4><p>Several studies that focus on issue tracker systems used to collect bug reports or feature requests have demonstrated that a substantial part of bug notifications are not correctly categorized, and are functionality requests or suggestions for refactoring. Herzig et al. reported 33.8% (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392–401" href="/article/10.1007/s10664-019-09781-y#ref-CR42" id="ref-link-section-d79957e1710">2013</a>), while Rodríguez-Pérez et al. reported up to 40% (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192–198" href="/article/10.1007/s10664-019-09781-y#ref-CR84" id="ref-link-section-d79957e1713">2016</a>). In addition, Herzig et al. pointed out that 39% of files marked as defective have never had a bug (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392–401" href="/article/10.1007/s10664-019-09781-y#ref-CR42" id="ref-link-section-d79957e1716">2013</a>).</p><p>Furthermore, when the bug notifications are correctly identified as a bug report, previous studies indicate several limitations of linking the <i>BFC</i> with the bug report. For example, the fixing commit cannot be linked to the bug (Bird et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Bird C, Bachmann A, Aune E, Duffy J, Bernstein A, Filkov V, Devanbu P (2009) Fair and balanced?: bias in bug-fix datasets. In: Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering. ACM, pp 121–130" href="/article/10.1007/s10664-019-09781-y#ref-CR11" id="ref-link-section-d79957e1725">2009</a>), or the fixing commit was linked to a wrong bug report, as they do not correspond to each other (Bissyande et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Bissyande TF, Thung F, Wang S, Lo D, Jiang L, Reveillere L (2013) Empirical evaluation of bug linking. In: 2013 17th european conference on software maintenance and reengineering (CSMR). IEEE, pp 89–98" href="/article/10.1007/s10664-019-09781-y#ref-CR13" id="ref-link-section-d79957e1728">2013</a>).</p><p>A number of tools have been developed to increase the linkage between bugs and fixes, among others, EpiceaUntangler (Dias et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Dias M, Bacchelli A, Gousios G, Cassou D, Ducasse S (2015) Untangling fine-grained code changes. In: 2015 IEEE 22nd international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 341–350" href="/article/10.1007/s10664-019-09781-y#ref-CR25" id="ref-link-section-d79957e1734">2015</a>), BugTracking (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192–198" href="/article/10.1007/s10664-019-09781-y#ref-CR84" id="ref-link-section-d79957e1737">2016</a>), Relink (Wu et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Wu R, Zhang H, Kim S, Cheung S-C (2011) Relink: recovering links between bugs and changes. In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering. ACM, pp 15–25" href="/article/10.1007/s10664-019-09781-y#ref-CR106" id="ref-link-section-d79957e1740">2011</a>), Rclinker (Le et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Le T-DB, Linares-Vásquez M, Lo D, Poshyvanyk D (2015) Rclinker: automated linking of issue reports and commits leveraging rich contextual information. In: 2015 IEEE 23rd international conference on program comprehension (ICPC). IEEE, pp 36–47" href="/article/10.1007/s10664-019-09781-y#ref-CR60" id="ref-link-section-d79957e1743">2015</a>), or Frlink (Sun et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="Sun Y, Wang Q, Yang Y (2017) Frlink: Improving the recovery of missing issue-commit links by revisiting file relevance. Inf Softw Technol 84:33–47" href="/article/10.1007/s10664-019-09781-y#ref-CR95" id="ref-link-section-d79957e1746">2017</a>). The model can use them in order to reduce these limitations, at least partially.</p><h3 class="c-article__sub-heading" id="Sec14">The Model Assumes that it is Possible to Know Whether a Bug is Present in the System or Not</h3><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec15">Definitions and Concepts</h4><p>To study the origin of bugs, our model needs to unequivocally determine if the bug is present for any given snapshot of the software system. In this way, we will be able to know when the bug appeared and when it has been fixed.</p><p>We need to consider what it means that “the bug is present”. Since there is no definition for ensuring that a bug is present in a snapshot, we build upon the definition of “defect” by IEEE Standard 1044 (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE" href="/article/10.1007/s10664-019-09781-y#ref-CR45" id="ref-link-section-d79957e1765">2009</a>):</p><p>“<b><i>Defect</i></b><b>: An imperfection or deficiency in a work product where that work product does not meet its requirements or specifications and needs to be either repaired or replaced.</b>”</p><p>We will slightly adapt this definition in three ways: i) we will use the term “bug”, ii) we are only concerned with “software products”, and iii) we will add temporal behavior, by adding “at the moment of producing the snapshot”. The adapted definition will be as follows:</p><p>“<b><i>Bug</i></b><b>: An imperfection or deficiency in a software product where that software product does not meet its requirements or specifications, as defined at the moment being considered, and needs to be either repaired or replaced.</b>”</p><p>Therefore, to know if a bug is present in a certain snapshot of the product, the model will check if it meets requirements or specifications at the moment of the production of the snapshot. This introduces an essential aspect as some lines of code might be considered a bug for a certain snapshot, because of the specifications at that point. However, the exact same lines could be considered correct if present in another snapshot if at that point some other specifications were applicable and were met (e.g., in Example 3 in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a>).</p><p>As a result, we can define: A bug was present for the first time in the first snapshot where the fixed code can be considered incorrect in any branch that ends merged in the <i>BFC</i>’s branch, according to the specifications applicable to that snapshot. This definition considers that the bug can propagate several times, e.g., in multiple branches that lead to the <i>BFC</i>.</p><p>When developers fix a bug, they can write a test that fails if the bug is present (Beller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In: Proceedings of the International Conference on Software Engineering (ICSE). ACM, pp 572–583" href="/article/10.1007/s10664-019-09781-y#ref-CR8" id="ref-link-section-d79957e1806">2018</a>). Thus, if developers could run such a test for every snapshot, they would see that the bug is not present in those snapshots where the test passes. We consider a test as <i>perfect</i>, if it can be run on any past version of the software.</p><p>This <i>perfect test</i> is a theoretical construct that may be challenging to create in practice. However, it provides an essential and precise definition of “faulty code at the time of writing it”. Furthermore, this <i>perfect test</i> can be seen as a kind of regression test<sup><a href="#Fn7"><span class="u-visually-hidden">Footnote </span>7</a></sup> which will evolve and adapt depending on the software’s changing circumstance (e.g., dependencies, APIs, even requirements) for each past version. The perfect test would encompass all the knowledge about the behavior of the software in the past, thus forming an oracle for each previous version.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec16">Implementation</h4><p>Our model assumes that it is possible to know whether a bug is present in a system or not by using <b>perfect tests</b>. These tests would create a <i>signal</i> that pinpoints when the bug was present. For that, they can also be used with past snapshots, before the bug was fixed. Theoretically, these <i>perfect tests</i> would fail according to our previous definition<sup><a href="#Fn8"><span class="u-visually-hidden">Footnote </span>8</a></sup>.</p><p>The idea of <i>perfect knowledge</i> replicates the idea of the <i>global observer</i> in distributed systems (Chandy and Lamport <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1985" title="Chandy KM, Lamport L (1985) Distributed snapshots: Determining global states of distributed systems. ACM Transactions on Computer Systems (TOCS) 3(1):63–75" href="/article/10.1007/s10664-019-09781-y#ref-CR18" id="ref-link-section-d79957e1858">1985</a>); it is an <b>idealized situation</b> (i.e., difficult or even impossible to implement), but a beneficial concept for reasoning about the system, and for comparing practical implementations and algorithms.</p><p>In order to run the tests for previous snapshots, these tests might have to be updated “for past conditions”, i.e., they have to be adapted to structural changes in the system under test (Moonen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173–202" href="/article/10.1007/s10664-019-09781-y#ref-CR67" id="ref-link-section-d79957e1867">2008</a>). In addition to the tested module, the tests need their dependencies: libraries, compilers or interpreters, external components and maybe even services accessed via remote APIs Zaidman et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Zaidman A, Van Rompaey B, Demeyer S, van Deursen A (2008) Mining software repositories to study co-evolution of production &amp; test code. In: First international conference on software testing, verification, and validation (ICST). IEEE, pp 220–229" href="/article/10.1007/s10664-019-09781-y#ref-CR108" id="ref-link-section-d79957e1870">2008</a>, <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364" href="/article/10.1007/s10664-019-09781-y#ref-CR109" id="ref-link-section-d79957e1873">2011</a>). Thus, a test fails or passes not only for a certain snapshot, but for a certain snapshot of all those dependencies.</p><p>Dependencies can be considered as a part of the requirements (Mens et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Mens T, Wermelinger M, Ducasse S, Demeyer S, Hirschfeld R, Jazayeri M (2005) Challenges in software evolution. In: Eighth international workshop on principles of software evolution. IEEE, pp 13–22" href="/article/10.1007/s10664-019-09781-y#ref-CR65" id="ref-link-section-d79957e1879">2005</a>): the module is expected to work, at any given moment, with a certain set of dependencies. Thus, the test should pass for that set. However, when dependencies change, the test may start failing, even if it is run on the same snapshot (Zaidman et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364" href="/article/10.1007/s10664-019-09781-y#ref-CR109" id="ref-link-section-d79957e1882">2011</a>; Demeyer et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2002" title="Demeyer S, Ducasse S, Nierstrasz O (2002) Object-oriented reengineering patterns. Elsevier" href="/article/10.1007/s10664-019-09781-y#ref-CR24" id="ref-link-section-d79957e1885">2002</a>; Moonen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173–202" href="/article/10.1007/s10664-019-09781-y#ref-CR67" id="ref-link-section-d79957e1888">2008</a>; Marsavina et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Marsavina C, Romano D, Zaidman A (2014) Studying fine-grained co-evolution patterns of production and test code. In: 2014 IEEE 14th international working conference on source code analysis and manipulation (SCAM). IEEE, pp 195–204" href="/article/10.1007/s10664-019-09781-y#ref-CR62" id="ref-link-section-d79957e1891">2014</a>; Palomba and Zaidman <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2019" title="Palomba F, Zaidman A (2019) The smell of fear: on the relation between test smells and flaky tests. Empirical Software Engineering (EMSE) 24(5):2907–2946" href="/article/10.1007/s10664-019-09781-y#ref-CR77" id="ref-link-section-d79957e1895">2019</a>; <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="Palomba F, Zaidman A (2017) Does refactoring of test smells induce fixing flaky tests? In: Proceedings of the International Conference on Software Maintenance and Evolution (ICSME). IEEE, pp 1–12" href="/article/10.1007/s10664-019-09781-y#ref-CR76" id="ref-link-section-d79957e1898">2017</a>). For example, the module can be expected to work with Python 2, but at some point the project decides that it should also run with Python 3. That will break large parts of the code, and many tests will fail when the new interpreter is introduced. Therefore, tests need to evolve to take into account the new dependency, in the same way they need to evolve to take into consideration any change in requirements.</p><p>Thus, the final definition of bug that we use in this work is:</p><p>“<i>Bug: An imperfection or deficiency in a software product that</i><b>causes a given test to fail</b>. <i>The test will be defined for each snapshot of the product, according to the requirements and specifications applicable for that snapshot, and for the dependencies supported in it, and will fail for a snapshot only if the bug is present in that snapshot.</i>”</p><p>Although this definition may be difficult to implement in practice, it provides an accurate test to know when a bug is present, and therefore, when it is introduced. Assuming the model has perfect knowledge about the requirements, specifications, dependencies, and <i>perfect tests</i> are available, it can clearly describe when the bug is present, and from there on, it also knows when the bug was introduced, and how.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec17">Limitations and Solutions</h4><p>Being able to gather information of previous requirements, documentation or dependencies of a project in previous versions is not always easy, as shown by Zaidman et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364" href="/article/10.1007/s10664-019-09781-y#ref-CR109" id="ref-link-section-d79957e1930">2011</a>). Some projects use build tools such as Maven or Gradle, and researchers can analyze the build scripts looking for dependencies or plugins that have changed. But, in other cases there is no formal record of such information. Thus, in the usual case a <i>perfect test</i> is not feasible. However, the contextual information found in issue tracker systems, code review systems and control version systems may help to write the tests, and to identify the origin of bugs.</p><p>Knauss et al. studied how the open communication paradigm in software ecosystems provides opportunities for ‘just-in-time’ requirement engineering (RE) (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Knauss E, Damian D, Knauss A, Borici A (2014) Openness and requirements: opportunities and tradeoffs in software ecosystems. In: 2014 IEEE 22nd international requirements engineering conference (RE). IEEE, pp 213–222" href="/article/10.1007/s10664-019-09781-y#ref-CR57" id="ref-link-section-d79957e1939">2014</a>). They propose T-Reqs, a tool based on git that enables agile cross-functional teams to be aware of requirements at system level and allows them to efficiently propose updates to those requirements (Knauss et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Knauss E, Liebel G, Horkoff J, Wohlrab R, Kasauli R, Lange F, Gildert P (2018) T-reqs: Tool support for managing requirements in large-scale agile system development. arXiv:&#xA;1805.02769&#xA;&#xA;&#xA;" href="/article/10.1007/s10664-019-09781-y#ref-CR58" id="ref-link-section-d79957e1942">2018</a>). This tool can support successful implementation in our model, since researchers can match changes/updates in the requirements with the changes in the source code and then, our model can use this information to build the <i>perfect knowledge</i>.</p><h3 class="c-article__sub-heading" id="Sec18">The Model Assumes that it is Possible to Identify a Candidate of the Bug-Introducing Change (<i>BIC</i>) that Corresponds to the Bug-Fixing Changes</h3><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec19">Implementation</h4><p>To identify the <i>BIC</i>, the model assumes that there is a <i>perfect test</i> for the fixed bug. Any approach that uses the representation of the model should start by analyzing how to link the <i>BFC</i> to the contextual information of how the bug was fixed. Then, it can start looking for the corresponding <i>BIC</i>.</p><p>Finally, once the approach has the test for each snapshot, it runs the test for all the previous snapshots until it finds the first snapshot that fails according to a <i>BFC</i> or until the test cannot be run or build because the tested functionality is not implemented yet.</p><p>The theoretical possible outputs of the test are:
</p><ul class="u-list-style-dash"><li><p>The test passes for all snapshots. This means that the bug was never present until the <i>BFC</i>. This is impossible because if the test is perfect, that would mean there was no bug to fix. So, the model ignores this case.</p></li><li><p>The test fails for at least some of the snapshots. This means that there will be a first snapshot for which the test fails. That snapshot will be the candidate <i>BIC</i>. It can be no other, because if the bug was in an earlier or later snapshot, the test would also fail for it.</p></li><li><p>The test is not-runnable or not-building. The model does not consider these scenarios since it assumes that <i>perfect tests</i> can be updated to previous snapshots.</p></li></ul><p>Once there is a candidate for the <i>BIC</i>, researchers can analyze why the test failed and determine whether this change introduce the bug of not:
</p><ul class="u-list-style-dash"><li><p>If there was no change in the source code that made the test fail, but the reason for the failure of the test was a change in requirements, specifications or dependencies, the candidate <i>BIC</i> is not responsible for introducing the bug. The change will be considered as the <i>FFC</i>. The model assumes that the bug is extrinsic because there is no new code causing the test to fail – the code introduced was correct (at least with respect to this bug).</p></li><li><p>In any other case, the model assumes that the bug is intrinsic because the change includes code that causes the test to fail. Therefore, the candidate <i>BIC</i> is the <i>BIC</i>.</p></li></ul><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec20">Limitations and Solutions</h4><p>In practice, when manually inspecting the changes, we may not need <i>perfect knowledge</i>; we only need to be able to assert on whether the definition of a bug is fulfilled. We also need to consider that when we roll back into earlier snapshots, we could find a moment when the test cannot be run because the feature being tested was not implemented at that moment. Even in the presence of build automation tools such as Maven, it is sometimes not that easy to go back in time to rebuild a project (Zaidman et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364" href="/article/10.1007/s10664-019-09781-y#ref-CR109" id="ref-link-section-d79957e2041">2011</a>). Moonen et al. have shown that about 2/3 of the refactoring changes from Fowler et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1999" title="Fowler M, Beck K, Brant J, Opdyke W, Roberts D (1999) Refactoring: improving the design of existing code. Addison-Wesley Professional" href="/article/10.1007/s10664-019-09781-y#ref-CR31" id="ref-link-section-d79957e2044">1999</a>) can actually result in non-building test cases because the refactoring changes the original interface and the test code requires a change in the types of classes that were involved in the refactoring (Moonen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173–202" href="/article/10.1007/s10664-019-09781-y#ref-CR67" id="ref-link-section-d79957e2047">2008</a>). In contrast, Hilton et al. have recently performed a study on test coverage evolution using Continuous Integration builds (Beller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="Beller M, Gousios G, Zaidman A (2017) Oops, my tests broke the build: an explorative analysis of Travis CI with GitHub. In: Proceedings of the International Conference on Mining Software Repositories (MSR). IEEE, pp 356–367" href="/article/10.1007/s10664-019-09781-y#ref-CR7" id="ref-link-section-d79957e2050">2017</a>), reporting that this modern infrastructure eases building prior versions of a software project considerably (Hilton et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Hilton M, Bell J, Marinov D (2018) A large-scale study of test coverage evolution. In: Proceedings of the 33rd ACM/IEEE international conference on automated software engineering (ASE). ACM, pp 53–63" href="/article/10.1007/s10664-019-09781-y#ref-CR43" id="ref-link-section-d79957e2054">2018</a>).</p><p>We could consider implementing these <i>perfect tests</i> by automatically generating them, e.g., using EvoSuite (Fraser and Arcuri <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013a" title="Fraser G, Arcuri A (2013a) Evosuite: On the challenges of test case generation in the real world. In: 2013 IEEE sixth international conference on software testing, verification and validation (ICST). IEEE, pp 362–369" href="/article/10.1007/s10664-019-09781-y#ref-CR32" id="ref-link-section-d79957e2063">2013a</a>; Palomba et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Palomba F, Panichella A, Zaidman A, Oliveto R, De Lucia A (2016) Automatic test case generation: what if test code quality matters? In: Proceedings of the 25th international symposium on software testing and analysis (ISSTA). ACM, pp 130–141" href="/article/10.1007/s10664-019-09781-y#ref-CR75" id="ref-link-section-d79957e2066">2016</a>). However, automatically generating tests raises a number of issues. First, the generated test may not run or build in previous snapshots. Second, the test may not be precise enough since there will be lack of information to understand and implement the specifications and requirements. In fact, even if developers can implement the <i>perfect tests</i> manually because they have enough information, the results are not binary, as they might return four values: Pass, Fail, Not-Runnable and Not-Building. The test should return not-runnable when the feature to test is not present, and return not-building when there is an issue with the dependencies trying to be built in that snapshot (Zaidman et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364" href="/article/10.1007/s10664-019-09781-y#ref-CR109" id="ref-link-section-d79957e2072">2011</a>; Moonen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173–202" href="/article/10.1007/s10664-019-09781-y#ref-CR67" id="ref-link-section-d79957e2076">2008</a>).</p><p>Nevertheless, researchers can use some test generation tools like EvoSuite (Fraser and Arcuri <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013a" title="Fraser G, Arcuri A (2013a) Evosuite: On the challenges of test case generation in the real world. In: 2013 IEEE sixth international conference on software testing, verification and validation (ICST). IEEE, pp 362–369" href="/article/10.1007/s10664-019-09781-y#ref-CR32" id="ref-link-section-d79957e2082">2013a</a>, <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference b" title="Fraser G, Arcuri A (2013b) Whole test suite generation. IEEE Trans Softw Eng 39(2):276–291" href="/article/10.1007/s10664-019-09781-y#ref-CR33" id="ref-link-section-d79957e2085">b</a>) to further investigate and solve theses issues. In particular, in future work we can investigate targeted search-based strategies to update tests after, e.g., refactoring operations (Vonken and Zaidman <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2012" title="Vonken F, Zaidman A (2012) Refactoring with unit testing: a match made in heaven?. In: Proceeedings of the working conference on reverse engineering (WCRE), pp 29–38" href="/article/10.1007/s10664-019-09781-y#ref-CR102" id="ref-link-section-d79957e2088">2012</a>).</p><p>Finally, another limitation is the assumption that the requirements in previous snapshots were always correct. If we combine that with the assumption that the tests are <i>perfect</i> and we can update them for conditions in the past, we run the risk of running into faulty requirements in previous snapshots (Viller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1999" title="Viller S, Bowers J, Rodden T (1999) Human factors in requirements engineering: A survey of human sciences literature relevant to the improvement of dependable systems development processes. Interact Comput 11(6):665–698" href="/article/10.1007/s10664-019-09781-y#ref-CR101" id="ref-link-section-d79957e2097">1999</a>). If we roll back the tests in this situation, the tests are likely to not fail.</p><h3 class="c-article__sub-heading" id="Sec21">The Model Assumes that the Fix is Perfect</h3><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec22">Implementation</h4><p>This means that the bug is no longer present after being fixed (i.e., after the <i>BFC</i>), and the bug report will not be reopened in the future. To ensure that the bug is no longer in the system, the model again uses the concept of <i>perfect tests</i>: if the snapshot of the <i>BFC</i> passes the test, the model ensures that, under the same specifications and requirements, the bug has been removed. We would then have what we call <i>perfect fixing</i>.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec23">Limitations and Solutions</h4><p><i>Perfect fixing</i> is not always possible in practice and the bug report might need to be reopened (Zimmermann et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2012" title="Zimmermann T, Nagappan N, Guo PJ, Murphy B (2012) Characterizing and predicting which bugs get reopened. In: Proceedings of the 34th international conference on software engineering. IEEE Press, pp 1074–1083" href="/article/10.1007/s10664-019-09781-y#ref-CR113" id="ref-link-section-d79957e2135">2012</a>; Shihab et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Shihab E, Ihara A, Kamei Y, Ibrahim WM, Ohira M, Adams B, Hassan AE, Matsumoto K. -i. (2013) Studying re-opened bugs in open source software. Empir Softw Eng 18(5):1005–1042" href="/article/10.1007/s10664-019-09781-y#ref-CR91" id="ref-link-section-d79957e2138">2013</a>).</p><p>In some cases, bug reports are reopened because they were not correctly fixed. Xia et al., reported that 6%-26% of the bug reports in Eclipse, Apache HTTP and OpenOffice.org were reopened. In this context, they proposed the ReopenPredictor tool which uses various kinds of features such as raw textual information or meta features to build a classification-based framework and predict whether a bug report would be reopened (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Xia X, Lo D, Shihab E, Wang X, Zhou B (2015) Automatic, high accuracy prediction of reopened bugs. Autom Softw Eng 22(1):75–109" href="/article/10.1007/s10664-019-09781-y#ref-CR107" id="ref-link-section-d79957e2144">2015</a>).</p><p>Furthermore, Zimmermann et al. investigated the reasons why bug reports were reopened at Microsoft. Their findings showed that bug reports were typically reopened because either a tester did not provide enough information in the report and there was a misunderstanding about the cause of the bug, or the bug was a regression bug<sup><a href="#Fn9"><span class="u-visually-hidden">Footnote </span>9</a></sup> (Zimmermann et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2012" title="Zimmermann T, Nagappan N, Guo PJ, Murphy B (2012) Characterizing and predicting which bugs get reopened. In: Proceedings of the 34th international conference on software engineering. IEEE Press, pp 1074–1083" href="/article/10.1007/s10664-019-09781-y#ref-CR113" id="ref-link-section-d79957e2157">2012</a>).</p><h3 class="c-article__sub-heading" id="Sec24">Summary of the Assumptions</h3><p>Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab4">4</a> summarizes the need, limitations and possible solutions for each assumption of the model.
</p><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-4"><figure><figcaption class="c-article-table__figcaption"><b id="Tab4" data-test="table-caption">Table 4 Summary of the assumptions, their limitations and possible solutions</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/4"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div></div></div></section><section aria-labelledby="Sec25" data-title="The Model"><div class="c-article-section" id="Sec25-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec25">The Model</h2><div class="c-article-section__content" id="Sec25-content"><p>In this section, we formally define the notions introduced in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a>. We do this with two purposes in mind: (1) to identify the first manifestation of a bug in the history of a software product and, (2) to provide the formalisms used to create and describe a manually curated dataset which can be considered as the “ground truth”. It is important to emphasize that the model is not a mathematical model solving relevant equations or characterizing the system, but it is a conceptual model that qualitatively represents the complex bug introduction process and highlights general rules and concepts. To that end, we use an example that identifies the bug-introducing change (<i>BIC</i>) or the first-failing change (<i>FFC</i>) given a bug-fixing change (<i>BFC</i>). This example describes a software product called Project A <i>(PA)</i> which uses an external library called <i>ExtL</i>. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig8">8</a> shows the model as a black box, with the information of a bug-fixing change as input and a change to the software identified as the bug-introducing change or the first-failing change as output.
</p><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-8" data-title="Fig. 8"><figure><figcaption><b id="Fig8" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 8</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/8" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig8_HTML.png?as=webp"></source><img aria-describedby="figure-8-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig8_HTML.png" alt="figure8" loading="lazy" width="685" height="265" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-8-desc"><p>Model to identify bug-introducing changes (<i>BIC</i> s) or first-failing changes (<i>FFCs</i>)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/8" data-track-dest="link:Figure8 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><h3 class="c-article__sub-heading" id="Sec26">Main Concepts &amp; Unifying Terminology</h3><p>We found that a unique terminology to name each of the concepts when identifying bug-introducing changes did not exist. We think that a common terminology would be desirable because researchers currently refer to different concepts as the same, and this can cause problems when trying to understand or reproduce previous studies. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab5">5</a> offers a comparison of the terminology used in this work and how the concepts have been referred to in previous publications. To the best of our knowledge, no previous study has presented a comprehensive list of all these concepts and terms used, and neither has someone investigated whether the terms are being used consistently.
</p><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-5"><figure><figcaption class="c-article-table__figcaption"><b id="Tab5" data-test="table-caption">Table 5 Comparison of our terminology with the one found in the research literature</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/5"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><p>The terminology describes that developers using the source code management (SCM) to write software in terms of <b><i>commits</i></b>, observable changes (additions, deletions or modifications) performed on a file (or set of files). The impact of a commit on a system might be represented as a <b><i>snapshot</i></b>, which is a state of the project after the commit has been performed.</p><p>Depending on the origin of the bug, we distinguish between: an <b><i>extrinsic bug</i></b> which has its origin in a change not recorded in its source code,<sup><a href="#Fn10"><span class="u-visually-hidden">Footnote </span>10</a></sup> or an <b><i>intrinsic bug</i></b> which has its origin in a change to the source code, this change is the bug-introducing change (<i>BIC</i>). Notice that extrinsic bugs do not have a bug-introducing change but a first-failing change (<i>FFC</i>).</p><p>To identify the bug-introducing change, we analyze the changes that fixed the bug in a bug-fixing change (<i>BFC</i>). To fix a bug, the bug-fixing change may add new lines or change (modify or delete) the existing ones. For a commit <i>c</i>, we label modified or deleted, but not added, lines as <b><i>lines changed by a commit</i></b><i>LC(c)</i>.
</p><p>If <i>L</i><i>C</i>(<i>B</i><i>F</i><i>C</i>) ≠ ∅, we can track down whether the revision which last modified each line in <i>LC(BFC)</i> lead to the bug that is fixed in the <i>BFC</i>, e.g., using tools such as “git blame”. This last revision is called the <b><i>previous commit</i></b><i>(pc)</i>.</p><p>Since the bug-fixing change can change more than one line, it is possible that different lines in <i>LC(BFC)</i> may have different previous commits. We will refer to <i>PC(c)</i> as the set of previous commits of a commit.</p><p>But, it is also possible to go further back in time and recursively analyze the previous commits of the <i>LC(pc)</i>. These commits are referred to as <b><i>descendants commits</i></b> of a bug-fixing change, <i>(DC(BFC))</i>. The previous commits are the immediately previous commits to the lines changed in the bug-fixing change; the descendant commits are all the commits that previously modified the lines changed in the bug-fixing change. The remaining commits in the source code management of a software product from the bug-fixing change backwards are the <b><i>ancestors commits</i></b>, <i>A</i><i>C</i>(<i>B</i><i>F</i><i>C</i>), which also includes the previous and descendants commits. Formally,</p><p><span class="mathjax-tex">\( PC(BFC) \cup DC(BFC) \subseteq AC(BFC)\)</span>.
</p><h3 class="c-article__sub-heading" id="Sec27">A Process to Identify when and How a Bug was Introduced</h3><p>This subsection describes the process used by our proposed model (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec7">4</a>) to determine when and how a bug was introduced. This process can be generalized and allows us to demonstrate how existing SZZ-based algorithms can be evaluated, which is something missing in the current literature.</p><p>This process consists of the following steps, which can be adopted by other researchers as well.</p>
                  <h3 class="c-article__sub-heading" id="FPar4">Ensure that a Control Version Exists</h3>
                  <p>The first step is to ensure that the selected project has a development history recorded in a SCM. Furthermore, to identify every change in the code from the beginning of the project until the bug fixing change, we need to ensure that the SCM of the selected project holds the complete history of the project.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar5">Identify the Bug-Fixing Change (<i>BFC</i>)</h3>
                  <p>The second step is to identify the bug-fixing change linked to a bug report. To that end, researchers should analyze only issues labeled (manually or by developers) as bugs reports.</p>
                  <p>When analyzing a bug fix, it is important to consider that a <i>BFC</i> may fix different bugs; and that fixing a bug might require multiple partial fixes (commits). Furthermore, a <i>BFC</i> can modify other parts of the source code that are not related to the bug, e.g., removing dead code or refactoring the source code (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e3006">2018a</a>; Neto et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e3009">2018</a>). Thus, when those cases exist, researchers should only analyze the source code of the <i>BFC</i> that fixed the aimed bug.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar6">Ensure the Perfect Fixing</h3>
                  <p>The third step is to ensure that the perfect fixing exists. A <i>BFC</i> might be incomplete and spread over several commits. In such cases, there is no <i>perfect fixing</i>. However, researchers need to be sure of this fact when analyzing the origin of bugs and they have to identify whether a bug report was reopened or not. In the affirmative case, researchers should consider the last <i>BFC</i>.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar7">Describe Whether a Bug is Present</h3>
                  <p>The fourth step is to describe whether a bug was present in a certain snapshot or not. For that, researchers can use all the information available in the SCM, in the ITS, in the code review system and/or in the testing system to build the <b><i>perfect test</i></b> signaling a bug, as explained in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec14">4.3</a>.</p>
                  <p>Thus, in order to describe whether a certain snapshot contains the bug fixed in the bug-fixing change, researchers need to run the perfect test from the bug-fixing snapshot backward. If the test passes, the snapshot does not contain the bug but, if the test fails, the snapshot contains the bug.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar8">Identify the First-Failing Change</h3>
                  <p>The last step is to identify the first-failing change given a bug-fixing change and decide whether it is the bug-introducing change or not. To find the first-failing change, we assume linear history and need to identify the first snapshot in the continuous sequence of test failing snapshots, which finishes right before the bug-fixing change. That is, there is a continuous sequence of snapshots for which the test fails, starting in the possible first-failing change, and finishing right before the bug-fixing change. Since the test is failing –all the way– from this snapshot up to the fix, we can say that this is the first snapshot “with the bug present”, thereby we have identified the first-failing change. Furthermore, if this change introduced the bug, it is the bug-introducing change.</p>
                  <p>We use the example in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig9">9</a> to illustrate how researchers can distinguish both scenarios. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig9">9</a> shows the timeline of Project A (PA) represented by its snapshots from the bug-fixing change backward, and the timeline of an external library (ExtL) used in PA. The following scenarios are possible when analyzing the first snapshot in the continuous sequence of test failing snapshots:
</p><ul class="u-list-style-dash"><li><p>The bug is intrinsic. The <i>LC(commit)</i> introduced the bug because the lines were faulty. For example, Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig9">9</a> shows how line 2 added in the previous commit of bug-fixing change inserted the bug. This line uses an external library (<i>numpy</i>) in a wrong way causing the bug to appear and manifest itself for the first time in the bug-introducing change. In this case<sup><a href="#Fn11"><span class="u-visually-hidden">Footnote </span>11</a></sup>, the documentation of <i>numpy</i> clearly describes that by default “arange” infers the data type from the input, thereby the line uses <i>numpy</i> in a wrong way causing the bug. This snapshot is the bug-introducing change.</p></li><li><p>The bug is extrinsic. The <i>LC(commit)</i> did not introduce the bug. For example, Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig10">10</a> shows how line 3 inserted in a previous commit of the bug-fixing change did not insert the bug because these lines are using ExtL, which contained a bug. In this case,<sup><a href="#Fn12"><span class="u-visually-hidden">Footnote </span>12</a></sup> the method <i>a</i><i>r</i><i>r</i><i>a</i><i>y</i>.<i>s</i><i>p</i><i>l</i><i>i</i><i>t</i>() returns an incorrect behavior with array size bigger than <i>MAX_INT32</i>. This snapshot is not the bug-introducing change, but the first-failing change.</p></li></ul><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-9" data-title="Fig. 9"><figure><figcaption><b id="Fig9" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 9</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/9" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig9_HTML.png?as=webp"></source><img aria-describedby="figure-9-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig9_HTML.png" alt="figure9" loading="lazy" width="685" height="275" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-9-desc"><p>Guiding example to identify how the bug was inserted given a bug-fixing change (<i>BFC</i>) in Project A (PA)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/9" data-track-dest="link:Figure9 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-10" data-title="Fig. 10"><figure><figcaption><b id="Fig10" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 10</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/10" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig10_HTML.png?as=webp"></source><img aria-describedby="figure-10-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig10_HTML.png" alt="figure10" loading="lazy" width="685" height="276" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-10-desc"><p>Guiding example to identify how the bug was inserted given a bug-fixing change (<i>BFC</i>) in Project A (PA). In this scenario the bug was extrinsic, caused by a bug the External Library (ExtL) that PA is using. It manifested itself in the lines inserted in the first-failing change (<i>FFC</i>)</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/10" data-track-dest="link:Figure10 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
                </div></div></section><section aria-labelledby="Sec28" data-title="Operationalizing the Process"><div class="c-article-section" id="Sec28-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec28">Operationalizing the Process</h2><div class="c-article-section__content" id="Sec28-content"><p>This section details how we operationalized the process described in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec27">5.2</a>. This operationalization is essential to identify the origin of bugs in real open source projects because the model (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec25">5</a>) is based on five idealized assumptions (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec7">4</a>).</p>
                <h3 class="c-article__sub-heading" id="FPar9">Ensure that a Control Version Exists</h3>
                <p>The projects that we selected have a development history recorded in a SCM. Also, for both projects, the initial commit<sup><a href="#Fn13"><span class="u-visually-hidden">Footnote </span>13</a></sup> was not migrating code from other version control system. Thus, we were able to trace back all the development history of the projects without suffering from the initial import commits observed by Da Costa et al. (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e3196">2017</a>).</p>
              
                <h3 class="c-article__sub-heading" id="FPar10">Identify the Bug-Fixing Change</h3>
                <p>To identify the <i>BFC</i>, we only analyzed issues labeled (manually or by developers) as bugs. Then, from these bugs, we excluded the bugs where developers do not agree whether the <i>BFC</i> was fixing the bug or another kind of issue (Herzig et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392–401" href="/article/10.1007/s10664-019-09781-y#ref-CR42" id="ref-link-section-d79957e3213">2013</a>). In total, we discarded four <i>BFCs</i> (see Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec30">7.1</a>).</p>
                <p>When analyzing a bug fix, we were aware that a <i>BFC</i> might (1) fix different bugs; (2) require multiple partial fixes (commits); and (3) modify other parts of the source code unrelated to the bug. When we identified these cases, we only analyzed the source code of the <i>BFC</i> that fixed the aimed bug.</p>
              
                <h3 class="c-article__sub-heading" id="FPar11">Ensure the Perfect Fixing</h3>
                <p>When we found reopened bug reports, we selected and analyzed the last <i>BFC</i> identified in the ITS. In total, we found two cases of reopened bug reports.</p>
                <p>Although we analyzed bug reports listed until 2016, we cannot assure that these bug reports will not be reopened in the future. However, if these bug reports have not been reopened for at least two years, we can be almost sure that the <i>BFC</i>, indeed, fixed the bug.</p>
              
                <h3 class="c-article__sub-heading" id="FPar12">Describe Whether a Bug is Present</h3>
                <p>Ideally, we should contact developers to identify whether a bug was present in a certain snapshot or not because they are the project experts. However, in practice, this is hard to implement because developers’ time is limited. Furthermore, even if developers participate, they might not be able to decide whether a specific snapshot did not introduce the bug because it fulfilled the requirements of the project in previous snapshots. Indeed, developers might have forgotten those requirements, might misinterpret them retrospectively or might not even have been involved in the project at that time (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e3257">2017</a>).</p>
                <p>Thus, we have to trust the knowledge of researchers, in this case, the authors of the paper. Although we are not experts developers in Nova and ElasticSearch, we had information in the ITS, the source code review system and the SCM that, when analyzed, helped us to identify whether a bug was present in a snapshot. To describe whether a bug was present in a snapshot, we needed to build the “perfect tests”: however, there are no practical means to implement and run the perfect test. Thus, we mentally created and ran the designed test on the previous snapshots and reasoned whether we could assert that these snapshots fulfilled the requirements of the project. We used this mentally designed test as proxy of the “perfect test”.</p>
                <p>For example, a valuable piece of information to mentally create the “perfect test” was the description<sup><a href="#Fn14"><span class="u-visually-hidden">Footnote </span>14</a></sup> of the bug report #1410622 in Nova. This description suggests that this is an extrinsic bug as its origin was a change in an external library (which is not recorded in the SCM of Nova). Other useful information came from the comments and discussion from developers in the ITS. A developer’s comment<sup><a href="#Fn15"><span class="u-visually-hidden">Footnote </span>15</a></sup> at Nova bug #1370590 indicates that the bug is extrinsic because the bug has its origin in a requirement change. A condition was introduced during development that needed some information, but many calls to a function were not providing this information since it was not required before which caused the bug.</p>
              
                <h3 class="c-article__sub-heading" id="FPar13">Identify the First-Failing Change</h3>
                <p>We classified the bug as intrinsic or extrinsic after identifying the <i>BFC</i> and using the mentally designed test as proxy of the “perfect test”.</p>
                <p>For the extrinsic bugs, we linked their <i>BFC</i> with the presence of a <i>FFC</i> because no <i>BIC</i> can be found in the SCM. For the intrinsic bugs, we applied <i>“git diff”</i> to the files touched by the <i>BFC</i>. <i>“Git diff”</i> identified what lines were added, modified or deleted between the snapshot after the <i>BFC</i> and the previous one. That way, we determined the previous commits of the <i>BFC</i> (<i>PC(BFC)</i>) and analyzed whether these previous commits introduced the bug. Notice that, the lines that did not contain source code (e.g., comments or blank lines) or affect test files were filtered out. <i>“Git diff”</i> cannot backtrack the lines that have been added. Thus, when we identified a <i>BFC</i> with only new lines added to fix the bug, we analyzed the lines adjacent to these added lines. This analysis provides good perspective to understand whether the last modification of these adjacent lines were somehow faulty, e.g., the adjacent lines were missing a piece of code to function correctly (i.e., the lines added by the <i>BFC</i>).</p>
                <p>Then, we selected each one of the previous commits to analyze whether the test would fail in the corresponding snapshot. If the test would not fail in none of the snapshots from previous commits, we navigated back to the previous ones, the descendant commits, until finding the first commit for which the test would fail; this commit was the <i>BIC</i>. Due to the complexity of some bugs, sometimes we could not manually identify the <i>BIC</i>.</p>
                <p>At the end of this process, we could have following three different outcomes:
</p><ul class="u-list-style-dash"><li><p>The <i>BFC</i> had a <i>BIC</i>, and we identified it manually.</p></li><li><p>The <i>BFC</i> had a <i>BIC</i>, but we did not identify it manually.</p></li><li><p>The <i>BFC</i> did not have a <i>BIC</i>, but a <i>FFC</i>.</p></li></ul>
              </div></div></section><section aria-labelledby="Sec29" data-title="Case Studies"><div class="c-article-section" id="Sec29-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec29">Case Studies</h2><div class="c-article-section__content" id="Sec29-content"><p>Following Easterbrook et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Easterbrook S, Singer J, Storey M. -A., Damian D (2008) Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering. Springer, pp 285–311" href="/article/10.1007/s10664-019-09781-y#ref-CR26" id="ref-link-section-d79957e3382">2008</a>), we selected two exploratory case studies to gain a deep understanding of the bug introduction phenomenon in two open source projects: Nova and ElasticSearch. We applied the model proposed in this paper to both projects to evaluate its applicability and to provide important insights that led us to validate or refute the assumption that relates the lines fixed in the <i>BFC</i> to the lines that introduced the bug in the software product. The operationalization of the model in these case studies resulted in a procedure that allowed us to build curated reference datasets in which bugs are linked with the presence or absence of <i>BIC</i> s. These manually curated datasets can be considered as the ground truth of the projects computing the real performance of the algorithms that are build upon the current assumption.</p><p>Runeson et al. argued that the systems selected in a case of study must be typical in order to generate a theory based on them (Runeson et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2012" title="Runeson P, Host M, Rainer A, Regnell B (2012) Case study research in software engineering: Guidelines and examples. Wiley, New York" href="/article/10.1007/s10664-019-09781-y#ref-CR89" id="ref-link-section-d79957e3394">2012</a>). Our aim is not to generate a theory of bug introduction, but to qualitatively study the bug introduction phenomenon in open source projects. Thus, we selected two projects with interesting and worthwhile characteristics to study. Besides, both projects have some differences that can allow us to validate the model and may extend the procedure to other similar open source projects. The second case study can be seen as an analytical replication of the first one.</p><p>Nova is the most active module of the OpenStack project in terms of contributions. OpenStack has more than 7,900 contributors, and significant industrial support from several major companies such as Red Hat, Huawei, IBM or HP. Nova is mainly written in Python and currently has more than 52,600 commits with more than 500K lines of code and around 1500 developers.<sup><a href="#Fn16"><span class="u-visually-hidden">Footnote </span>16</a></sup> All its history is saved and available in a version control system (git<sup><a href="#Fn17"><span class="u-visually-hidden">Footnote </span>17</a></sup>), an issue tracker system (Launchpad)<sup><a href="#Fn18"><span class="u-visually-hidden">Footnote </span>18</a></sup> and a source code review system (Gerrit<sup><a href="#Fn19"><span class="u-visually-hidden">Footnote </span>19</a></sup>).</p><p>In addition to the enormous diversity of people and companies contributing to Nova, the project has other characteristics that make it a good case to study: (1) the ease of gathering data. An important factor to ensure the reliability of data is that in a previous study (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192–198" href="/article/10.1007/s10664-019-09781-y#ref-CR84" id="ref-link-section-d79957e3427">2016</a>) we had already identified bug reports in the issue tracker system; (2) Nova uses Python, a dynamically typed, interpreted programming language. Python is dynamically typed and this can affect the way that bugs were introduced into the source code of a project. Ray et al. claim that statically typed languages are less defect prone than the dynamic typed languages (Ray et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Ray B, Posnett D, Filkov V, Devanbu P (2014) A large scale study of programming languages and code quality in github. In: Proceedings of the 22nd ACM SIGSOFT international symposium on foundations of software engineering. ACM, pp 155–165" href="/article/10.1007/s10664-019-09781-y#ref-CR83" id="ref-link-section-d79957e3430">2014</a>), although there is some controversy about this work (Berger et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2019" title="Berger ED, Hollenbeck C, Maj P, Vitek O, Vitek J (2019) On the impact of programming languages on code quality. arXiv:&#xA;1901.10220&#xA;&#xA;&#xA;" href="/article/10.1007/s10664-019-09781-y#ref-CR9" id="ref-link-section-d79957e3433">2019</a>); and (3) it uses a source code review system that it is connected with a continuous integration (CI) tool in order to verify that quality criteria are satisfied before a code change is integrated in the repository (Vassallo et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Vassallo C, Zampetti F, Romano D, Beller M, Panichella A, Penta MD, Zaidman A (2016) Continuous delivery practices in a large financial organization. In: Proceedings of the international conference on software maintenance and evolution (ICSME). IEEE Computer Society, pp 519–528" href="/article/10.1007/s10664-019-09781-y#ref-CR100" id="ref-link-section-d79957e3436">2016</a>).</p><p>ElasticSearch is a distributed open source search and analytics engine written in Java (a statically typed language). It has over 30,500 commits and over 900 developers, which points towards a frequent evolution in the code. This project was chosen because of its rigorous policy of labeling issues, as ElasticSearch developers use the label “bug” to tag issues that describe real bugs. We can thus be sure that the <i>BFC</i> s address real bugs. The code and the bug report list of ElasticSearch are hosted on GitHub.<sup><a href="#Fn20"><span class="u-visually-hidden">Footnote </span>20</a></sup></p><p>In addition, ElasticSearch has other characteristics that makes it a good case study: (1) the ease of gathering the data since its code is hosted on GitHub. In addition, the policy of adding the link of the bug report number or the pull request number into the <i>BFC</i> is helpful when linking and analyzing the two data sources; (2) It is a statically-typed language project written in Java and this programming language might present different characteristics than Python; (3) It uses a source code review that is built into the pull requests system of GitHub. That way, reviewers can discuss and review the proposed changes and add follow-up commits before these changes are merged into the base branch of the project.</p><h3 class="c-article__sub-heading" id="Sec30">Nova and Elasticsearch Datasets</h3><p>We relied on the Nova dataset from our previous work (Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192–198" href="/article/10.1007/s10664-019-09781-y#ref-CR84" id="ref-link-section-d79957e3464">2016</a>). This dataset consists of 60 random bug reports that were reported in 2015. For each of the bug reports that we manually identified, two different researchers manually linked them to the <i>BFC</i> s in the SCM. Then in ElasticSearch, we randomly gather 60 fixed and closed issues labeled as bug and reported between January 2013 and December 2016 from the GitHub issue tracker. Subsequently, we manually checked that the <i>BFC</i> was correctly linked.</p><p>To ensure that the bug reports could be applied to our model, we verified that they describe <i>real</i> bug reports at the moment of their report and not other issues (as the ones studied by Herzig et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2013" title="Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392–401" href="/article/10.1007/s10664-019-09781-y#ref-CR42" id="ref-link-section-d79957e3479">2013</a>)). For that, we carefully read the description and comments in the issue tracker system and code review system to analyze whether we could apply the model.</p><p>For example, the description of the bug report #1185290<sup><a href="#Fn21"><span class="u-visually-hidden">Footnote </span>21</a></sup> looked like a bug. However, after carefully analyzing all the comments, this report was removed because of the discordance between developers of Nova:
</p><ul class="u-list-style-dash"><li><p>“I am not sure that I consider this a bug. Without –all-tenants= 1, the code operates under your own tenant. That means that –all-tenants= 1 foo should really be a no-op without –all-tenants= 1.”</p></li><li><p>“I disagree, mainly because the structure of the requests and code path should largely be transparent to the user. I would suggest that specifying –tenants should imply you are doing a query across –all-tenants= 1unless the –tenants specified is the same as what is contained in OS_TENANT_NAME (the unless part is debatable)”</p></li></ul><p>Furthermore, we uncover other reasons why some bug reports cannot be applied to our model. For instance, bug report #1431571<sup><a href="#Fn22"><span class="u-visually-hidden">Footnote </span>22</a></sup> described a bug in a test file. We removed it because a bug in a test file does not mean that the source code of the project contained a bug. We also discovered that bug reports such as #7740<sup><a href="#Fn23"><span class="u-visually-hidden">Footnote </span>23</a></sup> and #1448075<sup><a href="#Fn24"><span class="u-visually-hidden">Footnote </span>24</a></sup> described hypothetical scenarios (i.e., a possible bug in the future). These bug reports were excluded from the analysis because, although developers described them as bug reports, the bug was still hypothetical and had not occurred yet in the project. As such, we could not build the <i>perfect test</i> in those cases as the <i>BFC</i> s were fixing hypothetical future bugs.</p><p>The result of this analysis was the removal of 3 bug reports from the initial set of 60 random bug reports in Nova and of a 1 bug report from the initial set of 60 random bug reports of ElasticSearch.</p><h3 class="c-article__sub-heading" id="Sec31">Results</h3><p>This section answers the research questions. First, we present the model that helped to describe when a snapshot of a component exhibits the bug. Then, we describe the empirical results of the evaluation of this model. We applied the model on two different datasets, from Nova and ElasticSearch, with the aim of identifying intrinsic and extrinsic bugs. In this process, we obtained curated and reliable datasets in which each <i>BFC</i> was connected to a <i>BIC</i> or a <i>FFC</i>. Finally, we used these curated datasets to compute the effectiveness of four existing SZZ algorithms.</p><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec32">RQ1: Can there be Criteria to Help Researchers Find a Useful Classification of Changes Leading to Bugs?</h4><p>To better understand and solve the problem of identifying the origin of bugs, we designed a model (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec25">5</a>) that provides criteria (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec7">4</a>) for reasoning which snapshot of a software product first exhibited the bug. Specifically, the model is based on the idea of the “perfect test” which was designed using prior literature (Rodríguez-Pérez et al., <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e3559">2018a</a>, <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e3562">b</a>; Kim et al., <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e3565">2006</a>; Sinha et al., <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2010" title="Sinha VS, Sinha S, Rao S (2010) Buginnings: identifying the origins of a bug. In: Proceedings of the 3rd India software engineering conference. ACM, pp 3–12" href="/article/10.1007/s10664-019-09781-y#ref-CR92" id="ref-link-section-d79957e3569">2010</a>) and empirical findings (da Costa et al., <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e3572">2017</a>; Rodríguez-Pérez et al., <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e3575">2018a</a>, <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e3578">b</a>).</p><p>To ensure that the criteria defined in the model, in particular the “perfect test”, can be applied to real-world projects, we manually analyzed the origin of the 116 bugs in two open source projects. For that, we applied the operationalization of the process as is described in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec28">6</a> into the two projects and then, we evaluated whether the criteria helped us to find a useful classification of the origin of bugs.</p><p>This study shows that, contrary to what is assumed in the literature (i.e., the last change that touched the fixed line(s) in a bug-fixing change introduced the bug), there are other sources for the introduction of bugs (e.g., changes in external dependencies, or changes in requirements). Although these sources were already known, our proposed model is the first one that includes them as a part of the model.</p><p>Furthermore, this careful analysis enabled us to produce manually curated datasets for Nova and ElasticSearch with bug-introducing changes and bugs that were not introduced by any change in the source code. Thus, we classified bugs as intrinsic and extrinsic and calculated the share of <i>BFC</i> s that have and do not have a <i>BIC</i>.</p><p>We determined whether the bug was intrinsic or extrinsic by applying our criteria to the projects. Although, by definition, intrinsic bugs always have a <i>BIC</i>, sometimes, we were unable to identify it manually. The complexity of the source code and the lack of information, when we analyzed the <i>BFC</i> s, made this identification difficult because we could not (mentally) implement the test. Thus, our results have intrinsic bugs with and without a <i>BIC</i> found. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab6">6</a> shows the number of intrinsic bugs for which the <i>BIC</i> was manually found (or not), the number of extrinsic bugs having a <i>FFC</i>, and the number of bugs that we could not be sure whether they were intrinsic or extrinsic.
</p><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-6"><figure><figcaption class="c-article-table__figcaption"><b id="Tab6" data-test="table-caption">Table 6 Percentage of intrinsic bugs with a bug-introducing change (<i>BIC</i>) manually found (or not); extrinsic bugs with a first-failing change (<i>FFC</i>); and undecided bugs in Nova and ElasticSearch (<i>ES</i>)</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/6"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><p>Notice that classifying a bug as “<i>BIC</i> not found” is different from not having a <i>BIC</i>. When we were sure that there was no <i>BIC</i> causing the test to fail, we classified the bug as not having a <i>BIC</i> (extrinsic). However, we classified the bug as “<i>BIC</i> not found” when we were sure that a <i>BIC</i> exists (the bug was intrinsic), but we were unable to find this <i>BIC</i> manually.</p><p>We observe that the lion’s share of <i>BFC</i> s, both in Nova(60%) and in ElasticSearch(64%), were related to intrinsic bugs, previous changes or omissions caused these bugs. The percentage of extrinsic bugs is higher in Nova (21%) than in ElasticSearch (9%).
</p><div class="c-article-section__figure c-article-section__figure--no-border" data-test="figure" data-container-section="figure" id="figure-i"><figure><div class="c-article-section__figure-content" id="Figi"><div class="c-article-section__figure-item"><div class="c-article-section__figure-content"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figi_HTML.png?as=webp"></source><img aria-describedby="figure-i-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figi_HTML.png" alt="figurei" loading="lazy" width="685" height="136" /></picture></div></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-i-desc"></div></div></figure></div><h4 class="c-article__sub-heading c-article__sub-heading--small c-article__sub-heading--light" id="Sec33">RQ2: Do These Criteria Help in Defining Precision and Recall in Four Existing SZZ-Based Algorithms for Detecting Bug-Introducing Changes?</h4><p>After the positive answer for RQ1, we obtained the manually curated datasets that can be understood as the“ground truth” datasets. We applied four existing SZZ algorithms that retrieve the <i>BIC</i> given the <i>BFC</i> to our datasets. In particular, we used (1) the original SZZ (Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e3740">2005</a>), this algorithm links the SCM and the ITS in order to identify the <i>BFC</i> and then, it identifies a set of changes that, according to the algorithm, are flagged as the <i>BIC(s)</i>. This set is identified by determining the lines that have been changed between the <i>BFC</i> and its previous version (e.g., diff) and identifying the last change(s) to those lines (e.g., git blame). Then, it uses a temporary window from the bug report date until the <i>BFC</i> date to remove some false positives from the set of previous changes. The remaining changes in this set were blamed as the bug-introducing change(s) by the SZZ algorithm. We used (2) the SZZ-1 (Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e3756">2006</a>), this algorithm is an improvement of the SZZ algorithm, which uses annotation graphs to reduce false positives and gain precision by excluding comments, blank lines, and format changes from the analysis. We use the SZZ-1 with two different heuristics; (3) SZZ-1E (Izquierdo-Cortazar et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2011" title="Izquierdo-Cortazar D, Capiluppi A, Gonzalez-Barahona JM (2011) Are developers fixing their own bugs?: Tracing bug-fixing and bug-seeding committers. International Journal of Open Source Software and Processes (IJOSSP) 3(2):23–42" href="/article/10.1007/s10664-019-09781-y#ref-CR48" id="ref-link-section-d79957e3759">2011</a>) that identifies an unique <i>BIC</i> as the earlier commit from the set of <i>PC(b)</i> and, (4) SZZ-1L (Davies et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the origins of bugs. Journal of Software: Evolution and Process 26(1):107–139" href="/article/10.1007/s10664-019-09781-y#ref-CR23" id="ref-link-section-d79957e3769">2014</a>) that identifies an unique <i>BIC</i> as the latest commit from the set of <i>PC(b)</i>. The four SZZ approaches do not attempt to identify <i>FFCs</i> since they do not consider that a bug can be caused by change(s) not recorded in the SCM. For that reason, all the previous changes identified by the SZZ are considered to be <i>BIC</i> s.</p><p>After that, we compared the manually curated datasets with the results from the four existing SZZ algorithm and measured how many <i>BIC</i> s (true positives) these algorithms obtain, how many identified commits were not the <i>BIC</i> s (false positives), and how many <i>BIC</i> s could not be found (false negatives).</p><p>Our criteria helps to determine the first snapshot of a software component that exhibits the bug according to a bug-fixing commit and identify the bug-introducing change. However, according to our model, there is just one change that introduced the bug. Notice that, because of the heuristics of SZZ and SZZ-1, there can be more than one <i>BIC</i> for a <i>BFC</i>. Thus, we can have a set of previous commits (<i>PC(BFC)</i>) identified as <i>BIC</i> s by SZZ and SZZ-1. To compare our manual curated datasets with these algorithms’ results and evaluate their performance, we counted the number of true positives, false positives, and false negatives using the following criteria:
</p><ol class="u-list-style-none"><li><span class="u-custom-list-number">1.</span><p><b>ALL</b>: We counted all the commits that the algorithms identified for a bug-fixing commit as true positives or false positives. When |<i>PC(BFC)</i>| &gt; 1; we counted one true positive whether the <i>BIC</i> existed and it belonged to the set of <i>PC(BFC)</i>. We flagged as false positives the other changes belonging to the set of <i>PC(BFC)</i>. For example, when we applied SZZ and SZZ-1 to #1486541 of Nova these algorithms identified three <i>BIC</i> s and the set of previous commits was three (<i>P</i><i>C</i>(<i>B</i><i>I</i><i>C</i>) = 3). But, just one of these previous commits was the change that introduced the bug reported in #1486541 (there is one true <i>BIC</i>). Thus, we identified one true positive and two false positives for the <i>BFC</i> that fixed #1486541. When none of the changes in the set of <i>PC(BFC)</i> was the <i>BIC</i>, we counted all of them as false positives. In case the algorithms could not be applied (i.e., <i>BFC</i> s with only new lines added to fix the bug) but there was a change that introduced the bug, we counted one false negative.</p></li><li><span class="u-custom-list-number">2.</span><p><b>At least</b>: We counted a true positive whether there was a <i>BIC</i> and it was in the set of previous commits (<i>PC(BFC)</i>) identified by the algorithms. For example, in #1486541 of Nova <i>PC(BFC)</i> = 3. Although just one of the previous commits was the change that introduced the bug (<i>BIC</i>), we counted one true positive and zero false positives for the <i>BFC</i> that fixed #1486541. When none of the changes from the <i>PC(BFC)</i> introduced the bug, we counted one false positive. In case the algorithms could not be applied but there was a change that introduced the bug reported in the bug report, we counted it as one false negative.</p></li><li><span class="u-custom-list-number">3.</span><p><b>Only</b>: We counted a true positive whether there was a <i>BIC</i>, it was in the set of previous commits (<i>PC(BFC)</i>) identified by the algorithms and <i>PC(BFC)</i> = 1. For example, in #1486541 of Nova <i>PC(BFC)</i> = 3, although one of them was the <i>BIC</i> we counted one false positive because <i>PC(BFC)</i> &gt; 1. In case that the algorithms could not be applied but there was a change that introduced the bug reported in the bug report, we counted it as one false negative.</p></li></ol><p>When we applied the SZZ and SZZ-1 algorithms to the set of 46 <i>BFC</i> s of Nova,<sup><a href="#Fn25"><span class="u-visually-hidden">Footnote </span>25</a></sup> we obtained 79 changes considered as <i>BIC</i> s by the algorithms. When these algorithms were applied to the 43 <i>BFC</i> s of ElasticSearch,<sup><a href="#Fn26"><span class="u-visually-hidden">Footnote </span>26</a></sup> we obtained 85 changes flagged as <i>BIC</i> s. On the contrary, when we applied SZZ-1E and SZZ-1L to the 46 <i>BFC</i> s of Nova and 43 <i>BFC</i> s of ElasticSearch, these algorithms returned 43 and 36 changes flagged as <i>BIC</i> s respectively.</p><p>Tables <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab7">7</a> and <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab8">8</a> present the percentage of true positives (TP), false positives (FP) and false negatives (FN), the precision (<span class="mathjax-tex">\(\textit {Precision=}\frac {TP}{TP+FP}\)</span>), recall (<span class="mathjax-tex">\(\textit {Recall=}\frac {TP}{TP+FN}\)</span>) and F-Score (<span class="mathjax-tex">\(\textit {F-Score=}2\frac {(Precision * Recall)}{Precision + Recall}\)</span>) of the SZZ algorithms. There are no True Negatives (TN) in the tables because these would be commits that did not introduce the bug and were not identified by the algorithms, i.e., all the ancestor commits that SZZ does not identify.
</p><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-7"><figure><figcaption class="c-article-table__figcaption"><b id="Tab7" data-test="table-caption">Table 7 Nova project: Results of True Positives <i>TP</i>, False Positives <i>FP</i>, False Negatives <i>FN</i>, Recall and Precision for SZZ-based algorithms assuming that: (1) SZZ and SZZ-1 flag all of the commits belong to a set of <i>PC(b)</i> as <i>BIC</i>; and (2) the four existing SZZ algorithms only flag the earlier <i>SZZ-1E</i> or latest <i>SZZ-1L</i> commits that belongs to a set of <i>PC(b)</i> as <i>BIC</i></b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/7"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-8"><figure><figcaption class="c-article-table__figcaption"><b id="Tab8" data-test="table-caption">Table 8 ElasticSearch project: Results of True Positives <i>TP</i>, False Positives <i>FP</i>, False Negatives <i>FN</i>, Recall and Precision for SZZ-based algorithms assuming that: (1) SZZ and SZZ-1 flag all of the commits belong to a set of <i>PC(b)</i> as <i>BIC</i>; and (2) the four existing SZZ algorithms only flag the earlier <i>SZZ-1E</i> or latest <i>SZZ-1L</i> commits that belongs to a set of <i>PC(b)</i> as <i>BIC</i></b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/8"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><p>When comparing the number of true positives from the SZZ approaches, we observed that the assumption “a bug was introduced by the lines of code that were modified to fix it” varies depending on the approach and the criteria being used. For example, Tables <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab7">7</a> and <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab8">8</a> shows that this assumption holds better in SZZ and SZZ-1 (54%-63%) when we consider that at least one of the changes identified by the algorithm is the <i>BIC</i>. The other results showed that the assumption holds in less than a half of the bugs analyzed in both projects.</p><p>Tables <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab7">7</a> and <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab8">8</a> show that in both projects, the highest precision, recall and F-Score were obtained using the SZZ-1 algorithm and the “At Least” evaluation criteria. Furthermore, from these Tables we see that the SZZ-1 performed sightly better than the original SZZ algorithm.</p><p>The real performance of the four existing SZZ algorithms showed that although the most effective results were obtained by SZZ-1 and the “At Least” criteria, the four algorithms reached a low percentage of true positives, in which the best case was 61% in Nova and 63% in ElasticSearch.
</p><div class="c-article-section__figure c-article-section__figure--no-border" data-test="figure" data-container-section="figure" id="figure-j"><figure><div class="c-article-section__figure-content" id="Figj"><div class="c-article-section__figure-item"><div class="c-article-section__figure-content"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figj_HTML.png?as=webp"></source><img aria-describedby="figure-j-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Figj_HTML.png" alt="figurej" loading="lazy" width="685" height="110" /></picture></div></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-j-desc"></div></div></figure></div>
                    <h3 class="c-article__sub-heading" id="FPar14">What Causes a Previous Commit (as Identified by SZZ-Based Algorithms) to not be the <i>BIC</i>?</h3>
                    <p>In those cases where the previous commit identified by the four existing SZZ algorithm was not the <i>BIC</i>, we investigated the cause for the misclassification. Some of these reasons are already known from previous studies and, although we do not pretend to do an exhaustive classification of why the previous commits analyzed were not the <i>BIC</i>, we identified some other reasons that have not been taken into account previously and added them to the next list of reasons:
</p><ul class="u-list-style-dash"><li><p><b>The bug was already in the modified line</b> (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e4481">2017</a>; Neto et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e4484">2018</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e4487">2006</a>): The modified line was buggy, but the bug was introduced before the last modification. For instance, one of the previous commits (<i>57108c8575b</i>) of bug<sup><a href="#Fn27"><span class="u-visually-hidden">Footnote </span>27</a></sup> #4564 fixed another bug. But lines 194–195 modified by this previous commit already contained the buggy code that caused bug #4564. Thus, this previous commit did not introduce bug #4564, but it was introduced by a descendant commit of these buggy lines 194–195.</p></li><li><p><b>The</b><b><i>BIC</i></b><b>was not in the</b><i>DC(b)</i><b>or</b><i>AC(b)</i><b>because it was an extrinsic bug</b>: The modified line has never been buggy from its introduction. For instance, the bug caused by a change in an external artifact<sup><a href="#Fn28"><span class="u-visually-hidden">Footnote </span>28</a></sup> #3551 explained in the Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig3">3</a>, <i>Example 1</i> in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a>.</p></li><li><p><b>The</b><b><i>BFC</i></b><b>only added new lines to fix the bug</b> (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e4541">2017</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e4544">2006</a>; Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e4547">2018b</a>): Due to how SZZ works, it cannot identify the case with only new lines in the <i>BFC</i>. For instance, commit <i>2442e1fb</i> forgot to add an <i>if</i> condition. Thus, the <i>BFC</i><sup><a href="#Fn29"><span class="u-visually-hidden">Footnote </span>29</a></sup> for bug #2566 only added new lines to fix the bug.</p></li><li><p><b>The previous commit made an equivalent change in line(s) that were not buggy</b> (Neto et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e4573">2018</a>): Due to how SZZ works, it identifies all modified lines in a <i>BFC</i>. Some of these lines many not be related to the bug. Changes under this case do not modify the logic of the source code. For instance, the previous commit<sup><a href="#Fn30"><span class="u-visually-hidden">Footnote </span>30</a></sup> of bug #4417 merged two different lines of code into one. But the logic of the code is still the same.</p></li><li><p><b>The previous commit made a reversion</b>: For instance, the previous commit<sup><a href="#Fn31"><span class="u-visually-hidden">Footnote </span>31</a></sup> of bug #3274 was reverting a previous change. Thus, the commit that reverted the change cannot be the <i>BIC</i>.</p></li><li><p><b>The previous commit made a cosmetic change in a line that was not buggy</b> (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e4604">2017</a>; Neto et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e4607">2018</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e4610">2006</a>): Due to how SZZ works, it can identify lines that were not buggy in previous modifications. Changes under this case include small cosmetic changes such as variable renaming or adding blank spaces to follow a coding style guide. For instance, one of the previous commits<sup><a href="#Fn32"><span class="u-visually-hidden">Footnote </span>32</a></sup> of bug #8526 added a blank space between the equality sign and the value assigned to a variable. This previous commit did not introduce the bug; it is just a cosmetic change to refactor the source code.</p></li></ul>
                  
                    <h3 class="c-article__sub-heading" id="FPar15">Is there an Alternative Approach to find the <i>BIC</i> with Higher Accuracy?</h3>
                    <p>Previous approaches (Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e4631">2005</a>; Kim et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90" href="/article/10.1007/s10664-019-09781-y#ref-CR55" id="ref-link-section-d79957e4634">2006</a>; Williams and Spacco <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36" href="/article/10.1007/s10664-019-09781-y#ref-CR104" id="ref-link-section-d79957e4637">2008</a>) rely on the analysis of lines of code and assume that “a given bug is introduced by the lines of code that are modified to fix it”. Thus, to determine the last revision that modified the lines fixed in a bug-fixing commit, researchers use features of the SCM systems such as “blame”. Tools like blame only show the last change that modified the lines of code, but the source code lines may be modified several times. Thus, the disadvantage of using blame is that when a descendant change of a source code line introduced the bug, this change can be masked with posterior changes in the same line of the source code. In fact, according to Soetens et al., almost 25% of refactoring operations applied are masked when studying the version history of a software project at the commit level (Soetens et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2015" title="Soetens QD, Pérez J., Demeyer S, Zaidman A (2015) Circumventing refactoring masking using fine-grained change recording. In: Proceedings of the 14th international workshop on principles of software evolution. ACM, pp 9–18" href="/article/10.1007/s10664-019-09781-y#ref-CR94" id="ref-link-section-d79957e4640">2015</a>).</p>
                    <p>Hence, an approach that increases the granularity of tools like blame may find <i>BIC</i> s with higher accuracy than the previous approaches (e.g., the four existing SZZ algorithms that we have studied previously). This alternative approach would track additions and deletions of tokens instead of additions and deletions of lines, so for every single token in the source code, this approach identifies the change that has last added/modified that token. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig11">11</a> shows a <i>BFC</i> analyzed using the line-based approach and Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="/article/10.1007/s10664-019-09781-y#Fig12">12</a> shows the same <i>BFC</i> analyzed using the token-based approach.
</p><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-11" data-title="Fig. 11"><figure><figcaption><b id="Fig11" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 11</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/11" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig11_HTML.png?as=webp"></source><img aria-describedby="figure-11-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig11_HTML.png" alt="figure11" loading="lazy" width="685" height="249" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-11-desc"><p>BFC line based #1370177 of Nova</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/11" data-track-dest="link:Figure11 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div><div class="c-article-section__figure js-c-reading-companion-figures-item" data-test="figure" data-container-section="figure" id="figure-12" data-title="Fig. 12"><figure><figcaption><b id="Fig12" class="c-article-section__figure-caption" data-test="figure-caption-text">Fig. 12</b></figcaption><div class="c-article-section__figure-content"><div class="c-article-section__figure-item"><a class="c-article-section__figure-link" data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/12" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig12_HTML.png?as=webp"></source><img aria-describedby="figure-12-desc" src="//media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10664-019-09781-y/MediaObjects/10664_2019_9781_Fig12_HTML.png" alt="figure12" loading="lazy" width="685" height="435" /></picture></a></div><div class="c-article-section__figure-description" data-test="bottom-caption" id="figure-12-desc"><p>BFC token based #1370177 of Nova</p></div></div><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="article-link" data-track="click" data-track-label="button" data-track-action="view figure" href="/article/10.1007/s10664-019-09781-y/figures/12" data-track-dest="link:Figure12 Full size image" rel="nofollow"><span>Full size image</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
                    <p>We will refer to the token-approach as <i>TSZZ</i> since it can be seen as a token-based SZZ approach. To evaluate whether the <i>TSZZ</i> approach increases the precision and recall when identifying <i>BIC</i> s, we analyzed the tokens that were modified in the <i>BFC</i> rather than the lines of the source code modified.</p>
                    <p>When we applied the TSZZ to the 46 <i>BFC</i> s of Nova it returned a set of 87 possible <i>BIC</i> s. When we applied TSZZ to the 43 <i>BFC</i> s of ElasticSearch it returned a set of 107 possible <i>BIC</i> s. Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="/article/10.1007/s10664-019-09781-y#Tab9">9</a> shows the values of precision, recall, and F-Score of the token-based algorithm. The table does not show the token-based counterpart of SZZ-1 because SZZ-1 uses annotation graphs (a line-based algorithm) and the result is the same as TSZZ.
</p><div class="c-article-table" data-test="inline-table" data-container-section="table" id="table-9"><figure><figcaption class="c-article-table__figcaption"><b id="Tab9" data-test="table-caption">Table 9 Results of True Positives <i>TP</i>, False Positives <i>FP</i>, False Negatives <i>FN</i>, Recall and Precision for the TSZZ-based, TSZZE-based and TSZZL-based algorithms</b></figcaption><div class="u-text-right u-hide-print"><a class="c-article__pill-button" data-test="table-link" data-track="click" data-track-action="view table" data-track-label="button" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/tables/9"><span>Full size table</span><svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-chevron-right"></use></svg></a></div></figure></div>
                    <p>The token-based SZZ solution slightly increases the precision and recall in Nova. However, in ElasticSearch this method performs worse, increasing the number of FN and FP, which decreases precision and recall.</p>
                  </div></div></section><section aria-labelledby="Sec34" data-title="Discussion"><div class="c-article-section" id="Sec34-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec34">Discussion</h2><div class="c-article-section__content" id="Sec34-content"><p>In this section we discuss the implications of our findings. First, we discuss to what extent our findings help towards establishing a bug introduction theory in the context of identifying the origin of bugs in open source projects (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec35">8.1</a>). Then, we discuss the generalizability of our findings (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec37">8.3</a>) and the implications with regard to the real evaluation of currents algorithms used during the bug identification process (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec38">8.4</a>). Finally, we discuss the threats to validity of this paper (Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec39">8.5</a>).</p><h3 class="c-article__sub-heading" id="Sec35">Towards a Better Understanding of Bug Introduction</h3><p>The complex phenomenon of bug introduction has been studied before. Previous studies have helped researchers to understand that fixing bugs consist of determining why software behaves erroneously (Zeller <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Zeller A (2009) Why programs fail - a guide to systematic debugging, 2nd edn. Academic Press, New York" href="/article/10.1007/s10664-019-09781-y#ref-CR110" id="ref-link-section-d79957e4879">2009</a>; Beller et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In: Proceedings of the International Conference on Software Engineering (ICSE). ACM, pp 572–583" href="/article/10.1007/s10664-019-09781-y#ref-CR8" id="ref-link-section-d79957e4882">2018</a>), that bugs can have different root causes (Li et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Li Z, Tan L, Wang X, Lu S, Zhou Y, Zhai C (2006) Have things changed now?: an empirical study of bug characteristics in modern open source software. In: Proceedings of the 1st workshop on Architectural and system support for improving software dependability. ACM, pp 25–33" href="/article/10.1007/s10664-019-09781-y#ref-CR61" id="ref-link-section-d79957e4885">2006</a>; Catolino et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2019" title="Catolino G, Palomba F, Zaidman A, Ferrucci F (2019) Not all bugs are the same Understanding, characterizing, and classifying bug types. J Syst Softw 152:165–181" href="/article/10.1007/s10664-019-09781-y#ref-CR17" id="ref-link-section-d79957e4888">2019</a>), and that bugs can be introduced in a version of the software system but were not found until much later (Chen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91" href="/article/10.1007/s10664-019-09781-y#ref-CR19" id="ref-link-section-d79957e4891">2014</a>). However, the state-of-the-art lacks a better understanding of the origin of bugs. We believe that there are not enough empirical studies that attempt to define or evaluate how researchers can ensure that a change in the source code introduced a bug, the moment it was introduced.</p><p>Hence, researches assume that the lines of code that have been used to fix the bug were also the ones that introduced the bug in the first place is an inaccurate assumption that has been used in many studies. Furthermore, these studies implicitly assume that bugs have always been introduced by a developer. However, some recent studies (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e4897">2017</a>; Rodríguez-Pérez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018a" title="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176" href="/article/10.1007/s10664-019-09781-y#ref-CR86" id="ref-link-section-d79957e4900">2018a</a>, <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference b" title="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4" href="/article/10.1007/s10664-019-09781-y#ref-CR87" id="ref-link-section-d79957e4903">b</a>) showed that this assumption should be reconsidered because other factors exist.</p><p>In our work, we have put this assumption aside and provided a model for ensuring when the software exhibits the bug and which change introduced it, in case that change exists. One of the most relevant contributions of the model is that it distinguishes between two different kind of bugs: intrinsic and extrinsic. The model relates intrinsic bugs with <i>BIC</i> s and extrinsic bugs with a fingerprint that the <i>BIC</i> does not exist.</p><p>Our model enables to understand the different ways in which bugs can be introduced. Practitioners can use it to describe the first time that the software exhibits the bug according to the <i>BFC</i>. Although our model is descriptive and defines many concepts and relationships, it cannot be understood as a theory of bug introduction because the lack of explicit prediction disqualifies it as a theory (Easterbrook et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Easterbrook S, Singer J, Storey M. -A., Damian D (2008) Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering. Springer, pp 285–311" href="/article/10.1007/s10664-019-09781-y#ref-CR26" id="ref-link-section-d79957e4921">2008</a>; Gregor <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2006" title="Gregor S (2006) The nature of theory in information systems. MIS quarterly:611–642" href="/article/10.1007/s10664-019-09781-y#ref-CR37" id="ref-link-section-d79957e4924">2006</a>). However, this work can be the starting point towards a better understanding of bug introduction because it goes beyond the mere observation of this phenomenon and tries to understand how and why this phenomenon occurs.</p><h3 class="c-article__sub-heading" id="Sec36">Guidelines for the Perfect Test Approximations Design</h3><p>The perfect test provides a precise definition of “faulty code at the time of writing it”. This definition encompasses all the knowledge about the past software behavior, thus forming an oracle for each previous version; it also helps to describe whether a certain snapshot contains the bug fixed in the bug-fixing change. Although, this perfect test may be challenging to create because it is a theoretical construct, we can use some approximations to design it.</p><p>This section provides a guidelines to design these approximations based on our experience after our manual analysis of 116 bug reports. During this analysis we learned some lessons that would help assist researchers when designing perfect test approximations.</p>
                  <h3 class="c-article__sub-heading" id="FPar16">The Context Approximation</h3>
                  <p>This is the main source of information to design approximations for the perfect test. Descriptions and comments of a bug report provide a valuable knowledge about the context of the bug (e.g., bug cause, bug fix, bug symptoms ... ), which helps researchers to decide whether there is a <i>BIC</i> or a <i>FFC</i>. Thus, when we understand the context of the bug, we can design the “perfect test” and analyze whether it would pass or fail in previous snapshots to find the <i>BIC</i> or the <i>FFC</i>. For example, the description of the bug report #2991<sup><a href="#Fn33"><span class="u-visually-hidden">Footnote </span>33</a></sup> from ElasticSearch says:</p><blockquote class="c-blockquote"><div class="c-blockquote__body"><p>The BytesRefOrdValComparator uses Ordinals.Docs.getNumOrdinals() -1 as the upper bound for the binary search. The -1 causes that we ignore the last value in the segment.</p></div></blockquote><p>and the description of the fix of this bug report says:</p><blockquote class="c-blockquote"><div class="c-blockquote__body"><p>Use full ord range in binary search. The upper bound of the binary search in BytesRefOrdValComparator starts at 1 and ends at maxOrd - 1. Yet, numOrd is defined as maxOrd - 1 excluding the 0 ord. This causes wrong sort ords when the bottom of the queue is compared to the next segment and the greatest term in the new segment is in-fact less than the current queue bottom.</p></div></blockquote><p>With this information, we can mentally design an approximation for the “perfect test”. It will test which snapshot, starting from the <i>BFC</i> backward, would fail because the source code of that snapshot causes wrong sort ords. Although, we cannot run this approximation automatically, to identify the <i>BIC</i>, we can manually analyze the source code of the previous snapshots and identify the first time that the test would fail. In some snapshots, we would not run the test because the function or feature tested is not present in that moment. In these cases, the first snapshot that fails after the test cannot run would be the <i>BIC</i> because the code was buggy when this snapshot introduced the function or feature tested.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar17">The Modified Files Approximation</h3>
                  <p>When we do not have enough information to fully comprehend the context of the bug, we can also analyze the files modified by the <i>BFC</i> to understand whether the bug was caused by a <i>BIC</i> or a <i>FFC</i>. Either the name and the modified lines of some files can give us a useful hint to design the approximation for the “perfect test”. For example, the bug fixing commit<sup><a href="#Fn34"><span class="u-visually-hidden">Footnote </span>34</a></sup> from Nova modified the files: <span class="u-monospace">doc/api-samples/versions-get-resp.json</span> and <span class="u-monospace">nova/api/openstack/compute/views/versions.py</span>. Furthermore, the description of this <i>BFC</i> says:</p><blockquote class="c-blockquote"><div class="c-blockquote__body"><p>Apply v2.1 API to href of version API. Now Nova contains v2 and v2.1 APIs, but version API returns the same href between v2 and v2.1.</p></div></blockquote><p>With this information, we can mentally design an approximation for the “perfect test”. This approximation will test which snapshot, starting from the <i>BFC</i> backward, would fail because the source code of that snapshot returns a wrong API version. In this case, we will notice that, based on the definition of “the perfect test”, there is no faulty code at the time of writing it. Thus, the test would always pass, which indicates that there is no <i>BIC</i> but a <i>FFC</i> because the bug was caused by the evolution of the code. After adding a new version of the API, the bug manifested itself in the source code causing the URL links to not show correctly. Sometimes, when we have enough information, we manually can point out which is the <i>FFC</i>. However, in most of the cases, we cannot identify the <i>FFC</i> because the developers do not give such information; and it is difficult to manually identify this change navigating from the <i>BFC</i> backward.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar18">The Bug Live Period Approximation</h3>
                  <p>In addition to the context, in some cases, we can analyze some metadata such as the date of the snapshots. With this information we can compute how long the bug has survived in the source code until it was reported in the issue tracking system, previous studies suggested that this period should not be bigger than two years (da Costa et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e5046">2017</a>; Rodriguez-Perez et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="Rodriguez-Perez G, Robles G, Gonzalez-Barahona JM (2017) How much time did it take to notify a bug?: two case studies: elasticsearch and nova. In: Proceedings of the 8th workshop on emerging trends in software metrics. IEEE Press, pp 29–35" href="/article/10.1007/s10664-019-09781-y#ref-CR85" id="ref-link-section-d79957e5049">2017</a>; Chen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91" href="/article/10.1007/s10664-019-09781-y#ref-CR19" id="ref-link-section-d79957e5052">2014</a>). For example, when we analyze the previous snapshots to identify whether the “perfect test” would pass or not, we can also analyze the time period between the bug report date and the date of the snapshot. If this period spans more than two years, we can assume that the source code at the time of writing it was correct, thereby, the “perfect test” would pass.</p>
                <h3 class="c-article__sub-heading" id="Sec37">Generalizability of our Findings</h3><p>The process of operationalizing the model in two different projects leads us to obtain a method to identify the first time that the software fails according to a <i>BFC</i>. We think that the case studies selected in this article are so different that this method can be generalized. Thus, researchers can apply this method in other projects in order to build reliable datasets that contain the information about the <i>BIC</i> s.</p><p>By using ElasticSearch and Nova as case studies, we gain deep insights into how bugs manifest themselves for the first time in these projects. They are exploratory case studies as we do not have a theory to refute or circumspect. However, the empirical results in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec31">7.2</a> demonstrate that the current assumption –“a bug was introduced by the lines of code that were modified to fix it”– is just one of the cases among others of how bugs were introduced in software.</p><p>First, 21% of the bugs analyzed in Nova and 9% in ElasticSearch are extrinsic, meaning that they do not have a change that introduced the bug directly in the SCM. We hypothesize that the reason why the percentage of extrinsic bugs is higher in Nova is due to the nature of the software and its changing environments. It should be noted that Nova, in contrast to ElasticSearch, is infrastructure software, that runs at the OS level and on many different platforms, which leads us to think that situations that end in extrinsic bugs appear more frequently. However, we do not have evidence to demonstrate what specific characteristics of software can contribute more to this difference.</p><p>Second, in both projects, the F-score of the four existing SZZ algorithms aimed at determining the origin of bugs varies from 0.44 to 0.77 depending on the criteria that we use to evaluate the SZZ-based algorithms. The assumption “a bug was introduced by the lines of code that were modified to fix it” is one of many cases when a bug is introduced; in our manual analysis, we found that this holds true for only about 61% of the cases in the best scenario. The bugs that were not introduced by the lines of code that were modified to fix them were identified as false positives, some of the reasons of being false positives were refactoring changes, reverting commits or equivalent changes, among others.</p><p>Hence, it is comprehensible to think that these results can be generalized to other projects. Thus, if we analyze how bugs were introduced in other projects we will find that a percentage of them are being caused by factors different from a developer introducing buggy code in the software.</p><h3 class="c-article__sub-heading" id="Sec38">Drawbacks of Existing Algorithms and Benefits of the Proposed Model to Software Engineering</h3><p>Over the past decades, researchers have used datasets obtained from SZZ-based algorithms to feed their bug prediction or classification models. For example, Ray et al. used a dataset gathered using the SZZ algorithm (Rahman et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Rahman F, Khatri S, Barr E, Devanbu P (2014) Comparing static bug finders and statistical prediction. In: Proceedings of the 36th international conference on software engineering. ACM, pp 424–434" href="/article/10.1007/s10664-019-09781-y#ref-CR80" id="ref-link-section-d79957e5095">2014</a>) to study the naturalness of buggy code (Ray et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2016" title="Ray B, Hellendoorn V, Godhane S, Tu Z, Bacchelli A, Devanbu P (2016) On the naturalness of buggy code. In: Proceedings of the 38th international conference on software engineering. ACM, pp 428–439" href="/article/10.1007/s10664-019-09781-y#ref-CR82" id="ref-link-section-d79957e5098">2016</a>). Massacci et al. evaluated most existing vulnerabilities discovery models on web browsers and took many datasets obtained using SZZ (Massacci and Nguyen <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Massacci F, Nguyen VH (2014) An empirical methodology to evaluate vulnerability discovery models. IEEE Trans Softw Eng 40(12):1147–1162" href="/article/10.1007/s10664-019-09781-y#ref-CR63" id="ref-link-section-d79957e5101">2014</a>). Abreu et al. used the dataset obtained in Śliwerski et al. (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e5104">2005</a>) to study how the frequency of communication between developers affects the introduction of a bug in the source code (Abreu and Premraj <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Abreu R, Premraj R (2009) How developer communication frequency relates to bug introducing changes. In: Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops. ACM, pp 153–158." href="/article/10.1007/s10664-019-09781-y#ref-CR1" id="ref-link-section-d79957e5107">2009</a>). These datasets can contain a noteworthy number of false positives and false negatives as we have seen in the findings of our case studies (see Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec33">7.2.2</a>). Consequently, the results of previous studies in the larger domain of software engineering (e.g., bug prediction or bug detection) can differ (negatively) if we take into account that they have used those datasets.</p><p>This work demonstrates that the process of applying our model to 116 bug reports and analyzing 236 previous commits leads to reliable datasets in which each <i>BFC</i> is linked with its <i>BIC</i> or without one. These curated datasets are one of the benefits of using the model as they represent the ground truth of the projects and they could be crucial to improve other areas of software engineering.</p><p>In this work, we manually built these curated datasets, and then we used them to compute the real performance in terms of precision, recall, and F-score of four SZZ-based algorithms. The results show that: (i) there are intrinsic and extrinsic bugs, although the SZZ-based algorithms consider all bugs as the same; (ii) the correct identification of <i>BIC</i> s is still a challenge when using SZZ-based algorithms; (iii) specific characteristics of the project might affect the performance of the algorithms when identifying <i>BIC</i> s. For example, we have noticed that the SZZ-1E algorithm obtains the best performance in Nova, while the SZZ-1L algorithm did in ElasticSearch; (iv) the existence of extrinsic bugs is a crucial factor for the performance of these algorithms: when they are removed from the dataset, the performance of these algorithms increases. We have also shown that researchers can decide what criteria they prefer to use when evaluating the SZZ algorithms depending on different factors. For example, if they attempt to analyze which algorithm creates a better dataset of false positives, they can decide to use the “All” criteria. Also, they can use the “At least” criteria to analyze which algorithm identifies more <i>BIC</i> s. Finally, they may prefer to use the “Only” criteria to evaluate whether just one change introduced the bug.</p><p>After the manual analysis, we have realized that establishing whether a <i>BIC</i> exists, and determining when it was introduced is not straightforward. However, the proposed model helps to identify the first time that the software exhibits the bug and to understand whether it was a <i>BIC</i> or a <i>FFC</i>. This model not only provides guidelines on how to become operational in real projects to build reliable datasets, it also contemplates <i>BFC</i> s that have been largely not considered in the current research literature. For example, the <i>BFC</i> s with only new lines added are not considered in the current research literature because the SZZ-based algorithm cannot track back these lines. Thus, another benefit of this paper is that our model decreases the number of false negatives in the datasets because it considers all kinds of <i>BFC</i> s.</p><p>All in all, we believe that the proposed model greatly benefits software engineering, as for the first time, we have described when a software system exhibits a bug, and we have looked into how bugs were inserted. In addition, with the empirical evaluation of the proposed model and the evaluation of the effectiveness of SZZ-based algorithms, we shed some more light on the problem of identifying software bugs realistically. However, to achieve greater bug localization automation, we need a concerted effort in testing to find ways or techniques to address the challenges of making the model operational (see Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec28">6</a>). In particular, a (partially) automated technique for building and subsequently evolving a <i>perfect test</i> would be of great importance, as it is this test that can signal the bug and then find the <i>BIC</i> or the <i>FFC</i>.</p><h3 class="c-article__sub-heading" id="Sec39">Threats to Validity</h3><p>The validity of our work is described in terms of the four main threats to validity in empirical software engineering research: construct, internal, external and conclusion validity (Wohlin et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2012" title="Wohlin C, Runeson P, Höst M, Ohlsson MC, Regnell B, Wesslén A (2012) Experimentation in software engineering. Springer Science &amp; Business Media" href="/article/10.1007/s10664-019-09781-y#ref-CR105" id="ref-link-section-d79957e5181">2012</a>).</p>
                  <h3 class="c-article__sub-heading" id="FPar19">Construct Validity</h3>
                  <p>Since we do not have enough means to build or automatize the perfect test, we have to create it mentally and this can lead to some threats in the results. However, we mitigate this threat by discussing those cases in which we were unsure about how the perfect test should be implemented. However, if a bug exists and it is fixed, then a test can be created to show the existence/lack of a bug. Otherwise, researchers cannot know for sure if the bug was fixed.</p>
                  <p>Also, assuming that the bug reports analyzed were not reopened later and that their <i>BFC</i> was always complete or that there is no duplicates of the same bug may be a threat to the study. We try to mitigate these cases by analyzing whether the <i>BFC</i> s have one or more <i>BFC</i> s attached to them or whether there was any information in the bug tracker system about the bug reports being reopened. Also, there can be cases where commits detected as <i>BFC</i> s turn out to be false because the bug report did not describe a real bug. To reduce this threat, the <i>BFC</i> s were manually reviewed to filter out the uncertain cases. Also, we manually located the <i>BIC</i> and in order to compute the performance of SZZ-based algorithms, we removed those bugs for which we were unsure from the datasets. Other threats are related to the peculiarities of the projects. The use of <i>GNU Diffutils</i> is the most extended way of providing diff information when looking for the difference between two files. However, other ways of providing diff information can be considered.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar20">Internal Validity</h3>
                  <p>The most important internal threat is that the authors, although they know OpenStack and ElasticSearch from using and having previously investigated them, do not have advanced programming expertise in these systems. This may have influenced the results of the analysis. To mitigate, the cases where we were unsure were discussed among the authors of this paper and removed when no agreement was reached.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar21">External Validity</h3>
                  <p>In terms of the number of commits that we analyzed for our study, it should be noted that our numbers are in the order of magnitude of similar studies that require intensive human labor, Hindle et al. considered 100 large commits in their study (Hindle et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Hindle A, German DM, Holt R (2008) What do large commits tell us?: a taxonomical study of large commits. In: Proceedings of the 2008 international working conference on mining software repositories. ACM, pp 99–108" href="/article/10.1007/s10664-019-09781-y#ref-CR44" id="ref-link-section-d79957e5232">2008</a>), Da Costa et al. analyzed 160 bugs and 80 <i>BIC</i> s (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2017" title="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657" href="/article/10.1007/s10664-019-09781-y#ref-CR22" id="ref-link-section-d79957e5238">2017</a>), and Williams and Spacco studied 25 <i>BFC</i> s that contained a total of 50 changed lines which were mapped back to a <i>BIC</i> (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2008" title="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36" href="/article/10.1007/s10664-019-09781-y#ref-CR104" id="ref-link-section-d79957e5248">2008</a>).</p>
                  <p>Another threat is that this work has only selected two different programming languages, Java and Python. It is possible that the study of different programming languages leads to different results. The use of Nova and ElasticSearch as the case studies implies a better understanding of how bugs appear in these projects. However, a higher number of projects would enrich the study because Nova and ElasticSearch can have specific properties. Both have rapid evolution and an active community of developers, thus other projects with fewer commits per year could have different results.</p>
                
                  <h3 class="c-article__sub-heading" id="FPar22">Conclusion Validity</h3>
                  <p>The metrics used to evaluate the four existing SZZ algorithms (i.e., accuracy, precision, recall, and F1-Score) are widely used when evaluating the performance of algorithms that identify the origin of bugs (Davies et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the origins of bugs. Journal of Software: Evolution and Process 26(1):107–139" href="/article/10.1007/s10664-019-09781-y#ref-CR23" id="ref-link-section-d79957e5263">2014</a>). Not having used or compared all the existing SZZ-based approaches (e.g., RA-SZZ (Neto et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2018" title="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390" href="/article/10.1007/s10664-019-09781-y#ref-CR71" id="ref-link-section-d79957e5266">2018</a>) can be a threat to the conclusion validity of the study since these approaches may have better accuracy and precision. Although comparing our manually curated dataset with other SZZ-based approaches would give us more insights into the performance of those approaches, we discarded using them because of the complexity of implementing them and the unavailability to use them as open source software. However, we study the token-based approach because we believe that it would have better precision that the four SZZ-based approaches that we selected.</p>
                </div></div></section><section aria-labelledby="Sec40" data-title="Conclusions and Future Work"><div class="c-article-section" id="Sec40-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Sec40">Conclusions and Future Work</h2><div class="c-article-section__content" id="Sec40-content"><p>In this study, to answer our central question: <i>How can we identify the origin of a defect based on information in source control systems?</i>, we proposed a model for defining criteria to decide the first snapshot of an evolving software system that exhibits a certain bug. For that, the model defines “the perfect test”, which fails when the bug is observed after a change to the software and passes when the bug in not observed. In practice, this “perfect test” can be (mentally) created using information from the source control systems, issue tracker systems and code review systems.</p><p>When applying the criteria to two real world projects, we qualitatively show that in the 116 bugs that we consider it is not always straightforward to identify how bugs were introduced. Furthermore, we witnessed how some bugs were caused by changes or omissions in the source code of the project (60%–64%). Other bugs (i.e., the extrinsic ones) were caused by changes that are not recorded in the source code (9%–21%). The proposed model helps to distinguish both cases and identifies when the <i>BIC</i> was made. The evaluation of four existing SZZ algorithms shows that when a change in the source code caused the bug, the assumption “a bug was introduced by the lines of code that were modified to fix it” only holds for 61%-63% of the commits analyzed, in the best case of SZZ-1. The precision does not exceed 0.75 and the maximum value for the recall is 0.80 in the projects that we evaluated. Furthermore, the results show that the version of SZZ with a higher effectiveness is SZZ-1 when using the “At least” criteria.</p><p>The lion’s share of identifying the bug-introducing changes is based on techniques which rely on the assumption that the lines of code changed to fix the bug are also the ones that have introduced it. This work provides evidence of the problematic nature of this assumption, and demonstrates that it is just one of the cases among others of how bugs were introduced in software components. Potentially, this finding has many implications in other fields of software engineering (e.g., bug prediction or bug detection) since many studies are misidentifying or even omitting the origin of the bug and this can put their results in jeopardy. This work does not try to make a formal proposal of a theory that explains how bugs were introduced in software products since we cannot be predictive. However, considering the apparent suitability of the model proposed, and the implications of the findings, it seems it could be necessary to obtain such a theory and, this work serves as a motivation towards a theory bug introduction. Our work also contributes to this by defining and explaining all relevant concepts in bug introduction, proposing a unified terminology.</p><p>We have demonstrated that our model enables to identify the snapshot of a component that exhibits the bug. Future work could use this model to build more datasets that can be used as the <i>ground truth</i> to evaluate the real performance of techniques when identifying how bugs were introduced. In order to build these datasets faster, another interesting and useful line of research would be to automate the <i>perfect test</i> that signals whether the bug is present in the code.</p><p>The findings in this study show that there are two kind of bugs, intrinsic bugs (the origin is a <i>BIC</i> in the SCM), and extrinsic bugs (the origin is a change not recorded in the SCM). Furthermore, the findings show that four existing SZZ algorithms misidentify <i>BIC</i> s. Other future lines could be i) to study whether extrinsic bugs can be automatically detected, and ii) to assess the impact of misidentifying <i>BIC</i> s in other areas of software engineering such as automatic bug detection or bug prediction. This could help to better design integration tests, or to envision other procedures to make software development more robust against bugs.</p><p>The full automation of the research methods used in this paper is also interesting for practitioners. That would provide software projects with a valuable tool for understanding how they are introducing bugs, and therefore design measures for mitigation.</p>
                <h3 class="c-article__sub-heading" id="FPar23">Replication Package</h3>
                <p>we have set up a replication package<sup><a href="#Fn35"><span class="u-visually-hidden">Footnote </span>35</a></sup> including data sources, intermediate data and scripts.</p>
              </div></div></section>
                        
                    

                    <section aria-labelledby="notes" data-title="Notes"><div class="c-article-section" id="notes-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="notes">Notes</h2><div class="c-article-section__content" id="notes-content"><ol class="c-article-footnote c-article-footnote--listed"><li class="c-article-footnote--listed__item" id="Fn1"><span class="c-article-footnote--listed__index">1.</span><div class="c-article-footnote--listed__content"><p>Throughout this paper, we use the term “bug”, which we define in detail in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec25">5</a>. Although bugs could be considered as “defects/faults” or “failures”, according to Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2009" title="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE" href="/article/10.1007/s10664-019-09781-y#ref-CR45" id="ref-link-section-d79957e618">2009</a>) and ISO/IEC (<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2001" title="ISO/IEC (2001) ISO/IEC 9126. Software engineering – Product quality ISO/IEC" href="/article/10.1007/s10664-019-09781-y#ref-CR46" id="ref-link-section-d79957e621">2001</a>), we use “bug” as it is widely used in the literature (Tan et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Tan L, Liu C, Li Z, Wang X, Zhou Y, Zhai C (2014) Bug characteristics in open source software. Empir Softw Eng 19(6):1665–1705" href="/article/10.1007/s10664-019-09781-y#ref-CR97" id="ref-link-section-d79957e624">2014</a>; Śliwerski et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2005" title="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5" href="/article/10.1007/s10664-019-09781-y#ref-CR93" id="ref-link-section-d79957e627">2005</a>; Chen et al. <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2014" title="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91" href="/article/10.1007/s10664-019-09781-y#ref-CR19" id="ref-link-section-d79957e631">2014</a>) and it is the term developers use normally. We also describe shades between all these terms in Section <a data-track="click" data-track-label="link" data-track-action="section anchor" href="/article/10.1007/s10664-019-09781-y#Sec5">2</a>.</p></div></li><li class="c-article-footnote--listed__item" id="Fn2"><span class="c-article-footnote--listed__index">2.</span><div class="c-article-footnote--listed__content"><p>A snapshot is the state of the system after a commit.</p></div></li><li class="c-article-footnote--listed__item" id="Fn3"><span class="c-article-footnote--listed__index">3.</span><div class="c-article-footnote--listed__content"><p>The current literature does not consider a change that has not been recorded in the SCM of a project (e.g., in requirements, to external APIs, to the environment) as “the origin of a bug”.</p></div></li><li class="c-article-footnote--listed__item" id="Fn4"><span class="c-article-footnote--listed__index">4.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/issues/3551">https://github.com/elastic/elasticsearch/issues/3551</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn5"><span class="c-article-footnote--listed__index">5.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/issues/3820">https://github.com/elastic/elasticsearch/issues/3820</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn6"><span class="c-article-footnote--listed__index">6.</span><div class="c-article-footnote--listed__content"><p>A change is what developers do in a single commit</p></div></li><li class="c-article-footnote--listed__item" id="Fn7"><span class="c-article-footnote--listed__index">7.</span><div class="c-article-footnote--listed__content"><p>“regression testing is an activity aimed at showing that code has not been adversely affected by changes” (Rothermel and Harrold <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1996" title="Rothermel G, Harrold MJ (1996) Analyzing regression test selection techniques. IEEE Trans Softw Eng 22(8):529–551" href="/article/10.1007/s10664-019-09781-y#ref-CR88" id="ref-link-section-d79957e1824">1996</a>)</p></div></li><li class="c-article-footnote--listed__item" id="Fn8"><span class="c-article-footnote--listed__index">8.</span><div class="c-article-footnote--listed__content"><p>“the tests would fail in the first snapshot preceding the snapshot that fixed the considered bug, according to the specifications applicable for that first snapshot, i.e., for the requirements that were known and specified at that point”.</p></div></li><li class="c-article-footnote--listed__item" id="Fn9"><span class="c-article-footnote--listed__index">9.</span><div class="c-article-footnote--listed__content"><p>“A regression bug is a bug which causes a feature that worked correctly to stop working after a certain event” (Brooks <a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1995" title="Brooks FP Jr (1995) The mythical man-month: essays on software engineering, anniversary edition, 2/E. Pearson Education India" href="/article/10.1007/s10664-019-09781-y#ref-CR15" id="ref-link-section-d79957e2153">1995</a>)</p></div></li><li class="c-article-footnote--listed__item" id="Fn10"><span class="c-article-footnote--listed__index">10.</span><div class="c-article-footnote--listed__content"><p>source code broadly defined as any file under version control</p></div></li><li class="c-article-footnote--listed__item" id="Fn11"><span class="c-article-footnote--listed__index">11.</span><div class="c-article-footnote--listed__content"><p><a href="https://stackoverflow.com/questions/43209391/numpy-is-calculating-wrong">https://stackoverflow.com/questions/43209391/numpy-is-calculating-wrong</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn12"><span class="c-article-footnote--listed__index">12.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/numpy/numpy/issues/11809">https://github.com/numpy/numpy/issues/11809</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn13"><span class="c-article-footnote--listed__index">13.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/commit/b3337c">https://github.com/elastic/elasticsearch/commit/b3337c</a>; <a href="https://github.com/openstack/nova/commit/bf6e6e">https://github.com/openstack/nova/commit/bf6e6e</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn14"><span class="c-article-footnote--listed__index">14.</span><div class="c-article-footnote--listed__content"><p>The description was: <i>“Webob library has a bug Pylons/webob#149 which causes modification of req.body after first access. So it’s critical to calculate the body hash before any other access is made.”</i></p></div></li><li class="c-article-footnote--listed__item" id="Fn15"><span class="c-article-footnote--listed__index">15.</span><div class="c-article-footnote--listed__content"><p>The comment said: <i>“These calls now need to provide disk_info to _create_domain_and_network”</i></p></div></li><li class="c-article-footnote--listed__item" id="Fn16"><span class="c-article-footnote--listed__index">16.</span><div class="c-article-footnote--listed__content"><p><a href="http://stackalytics.com">http://stackalytics.com</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn17"><span class="c-article-footnote--listed__index">17.</span><div class="c-article-footnote--listed__content"><p><a href="https://wiki.openstack.org/wiki/Getting_The_Code">https://wiki.openstack.org/wiki/Getting_The_Code</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn18"><span class="c-article-footnote--listed__index">18.</span><div class="c-article-footnote--listed__content"><p><a href="https://launchpad.net/openstack">https://launchpad.net/openstack</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn19"><span class="c-article-footnote--listed__index">19.</span><div class="c-article-footnote--listed__content"><p><a href="https://review.openstack.org/">https://review.openstack.org/</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn20"><span class="c-article-footnote--listed__index">20.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/">https://github.com/elastic/elasticsearch/</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn21"><span class="c-article-footnote--listed__index">21.</span><div class="c-article-footnote--listed__content"><p><a href="https://bugs.launchpad.net/nova/+bug/1185290">https://bugs.launchpad.net/nova/+bug/1185290</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn22"><span class="c-article-footnote--listed__index">22.</span><div class="c-article-footnote--listed__content"><p><a href="https://bugs.launchpad.net/nova/+bug/1431571">https://bugs.launchpad.net/nova/+bug/1431571</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn23"><span class="c-article-footnote--listed__index">23.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/issues/7740">https://github.com/elastic/elasticsearch/issues/7740</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn24"><span class="c-article-footnote--listed__index">24.</span><div class="c-article-footnote--listed__content"><p><a href="https://bugs.launchpad.net/nova/+bug/1448075">https://bugs.launchpad.net/nova/+bug/1448075</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn25"><span class="c-article-footnote--listed__index">25.</span><div class="c-article-footnote--listed__content"><p>Out of the 46 bugs, we manually found 34 <i>BIC</i> s and 12 <i>FFCs</i>. We removed one bug because we were unsure about its origin.</p></div></li><li class="c-article-footnote--listed__item" id="Fn26"><span class="c-article-footnote--listed__index">26.</span><div class="c-article-footnote--listed__content"><p>Out of the 43 bugs, we manually found 36 <i>BIC</i> s and 5 <i>FFCs</i>. We removed three bugs because we were unsure about their origin.</p></div></li><li class="c-article-footnote--listed__item" id="Fn27"><span class="c-article-footnote--listed__index">27.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/issues/4564">https://github.com/elastic/elasticsearch/issues/4564</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn28"><span class="c-article-footnote--listed__index">28.</span><div class="c-article-footnote--listed__content"><p><a href="https://bugs.launchpad.net/nova/+bug/1449028">https://bugs.launchpad.net/nova/+bug/1449028</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn29"><span class="c-article-footnote--listed__index">29.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/commit/9e4a0cba">https://github.com/elastic/elasticsearch/commit/9e4a0cba</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn30"><span class="c-article-footnote--listed__index">30.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/commit/2e64dbce">https://github.com/elastic/elasticsearch/commit/2e64dbce</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn31"><span class="c-article-footnote--listed__index">31.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/commit/4c493ac">https://github.com/elastic/elasticsearch/commit/4c493ac</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn32"><span class="c-article-footnote--listed__index">32.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/commit/5aa0a8438f">https://github.com/elastic/elasticsearch/commit/5aa0a8438f</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn33"><span class="c-article-footnote--listed__index">33.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/elastic/elasticsearch/issues/2991">https://github.com/elastic/elasticsearch/issues/2991</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn34"><span class="c-article-footnote--listed__index">34.</span><div class="c-article-footnote--listed__content"><p><a href="https://opendev.org/openstack/nova/commit/46bd4e4292648c0474e02ddc1560ce583fbe56d0">https://opendev.org/openstack/nova/commit/46bd4e4292648c0474e02ddc1560ce583fbe56d0</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn35"><span class="c-article-footnote--listed__index">35.</span><div class="c-article-footnote--listed__content"><p><a href="https://github.com/Gemarodri/HowBugsAreBorn">https://github.com/Gemarodri/HowBugsAreBorn</a></p></div></li><li class="c-article-footnote--listed__item" id="Fn36"><span class="c-article-footnote--listed__index">36.</span><div class="c-article-footnote--listed__content"><p><a href="http://bitergia.com">http://bitergia.com</a></p></div></li></ol></div></div></section><section aria-labelledby="Bib1" data-title="References"><div class="c-article-section" id="Bib1-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Bib1">References</h2><div class="c-article-section__content" id="Bib1-content"><div data-container-section="references"><ol class="c-article-references"><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Abreu R, Premraj R (2009) How developer communication frequency relates to bug introducing changes. In: Procee" /><p class="c-article-references__text" id="ref-CR1">Abreu R, Premraj R (2009) How developer communication frequency relates to bug introducing changes. In: Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops. ACM, pp 153–158.</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Alexandru CV, Gall H (2015) Rapid multi-purpose, multi-commit code analysis. In: 2015 IEEE/ACM 37th IEEE Inter" /><p class="c-article-references__text" id="ref-CR2">Alexandru CV, Gall H (2015) Rapid multi-purpose, multi-commit code analysis. In: 2015 IEEE/ACM 37th IEEE International Conference on Software Engineering (ICSE), vol 2. IEEE, pp 635–638</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Aranda J, Venolia G (2009) The secret life of bugs: Going past the errors and omissions in software repositori" /><p class="c-article-references__text" id="ref-CR3">Aranda J, Venolia G (2009) The secret life of bugs: Going past the errors and omissions in software repositories. In: Proceedings of the 31st international conference on software engineering. IEEE Computer Society, pp 298–308</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="VR. Basili, BT. Perricone, " /><meta itemprop="datePublished" content="1984" /><meta itemprop="headline" content="Basili VR, Perricone BT (1984) Software errors and complexity: an empirical investigation. Commun ACM 27(1):42" /><p class="c-article-references__text" id="ref-CR4">Basili VR, Perricone BT (1984) Software errors and complexity: an empirical investigation. Commun ACM 27(1):42–52</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1145%2F69605.2085" aria-label="View reference 4">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 4 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Software%20errors%20and%20complexity%3A%20an%20empirical%20investigation&amp;journal=Commun%20ACM&amp;volume=27&amp;issue=1&amp;pages=42-52&amp;publication_year=1984&amp;author=Basili%2CVR&amp;author=Perricone%2CBT">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Bavota G, Russo B. (2015) Four eyes are better than two: on the impact of code reviews on software quality. In" /><p class="c-article-references__text" id="ref-CR5">Bavota G, Russo B. (2015) Four eyes are better than two: on the impact of code reviews on software quality. In: 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME). IEEE, pp 81–90</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Beller M, Gousios G, Zaidman A (2015) How (much) do developers test?. In: Proceedings of the International Con" /><p class="c-article-references__text" id="ref-CR6">Beller M, Gousios G, Zaidman A (2015) How (much) do developers test?. In: Proceedings of the International Conference on Software Engineering (ICSE), vol 2. IEEE Computer Society, pp 559–562</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Beller M, Gousios G, Zaidman A (2017) Oops, my tests broke the build: an explorative analysis of Travis CI wit" /><p class="c-article-references__text" id="ref-CR7">Beller M, Gousios G, Zaidman A (2017) Oops, my tests broke the build: an explorative analysis of Travis CI with GitHub. In: Proceedings of the International Conference on Mining Software Repositories (MSR). IEEE, pp 356–367</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In" /><p class="c-article-references__text" id="ref-CR8">Beller M, Spruit N, Spinellis D, Zaidman A (2018) On the dichotomy of debugging behavior among programmers. In: Proceedings of the International Conference on Software Engineering (ICSE). ACM, pp 572–583</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Berger ED, Hollenbeck C, Maj P, Vitek O, Vitek J (2019) On the impact of programming languages on code quality" /><p class="c-article-references__text" id="ref-CR9">Berger ED, Hollenbeck C, Maj P, Vitek O, Vitek J (2019) On the impact of programming languages on code quality. arXiv:<a href="http://arxiv.org/abs/1901.10220">1901.10220</a>
</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="N. Bettenburg, AE. Hassan, " /><meta itemprop="datePublished" content="2013" /><meta itemprop="headline" content="Bettenburg N, Hassan AE (2013) Studying the impact of social interactions on software quality. Empir Softw Eng" /><p class="c-article-references__text" id="ref-CR10">Bettenburg N, Hassan AE (2013) Studying the impact of social interactions on software quality. Empir Softw Eng 18(2):375–431</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-012-9205-0" aria-label="View reference 10">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 10 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Studying%20the%20impact%20of%20social%20interactions%20on%20software%20quality&amp;journal=Empir%20Softw%20Eng&amp;volume=18&amp;issue=2&amp;pages=375-431&amp;publication_year=2013&amp;author=Bettenburg%2CN&amp;author=Hassan%2CAE">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Bird C, Bachmann A, Aune E, Duffy J, Bernstein A, Filkov V, Devanbu P (2009) Fair and balanced?: bias in bug-f" /><p class="c-article-references__text" id="ref-CR11">Bird C, Bachmann A, Aune E, Duffy J, Bernstein A, Filkov V, Devanbu P (2009) Fair and balanced?: bias in bug-fix datasets. In: Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering. ACM, pp 121–130</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Bird C, Rigby PC, Barr E, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: " /><p class="c-article-references__text" id="ref-CR12">Bird C, Rigby PC, Barr E, Hamilton DJ, German DM, Devanbu P (2009) The promises and perils of mining git. In: 6th IEEE international working conference on mining software repositories, 2009. MSR’09. IEEE, pp 1–10</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Bissyande TF, Thung F, Wang S, Lo D, Jiang L, Reveillere L (2013) Empirical evaluation of bug linking. In: 201" /><p class="c-article-references__text" id="ref-CR13">Bissyande TF, Thung F, Wang S, Lo D, Jiang L, Reveillere L (2013) Empirical evaluation of bug linking. In: 2013 17th european conference on software maintenance and reengineering (CSMR). IEEE, pp 89–98</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="B. Boehm, VR. Basili, " /><meta itemprop="datePublished" content="2005" /><meta itemprop="headline" content="Boehm B, Basili VR (2005) Software defect reduction top 10 list. Foundations of empirical software engineering" /><p class="c-article-references__text" id="ref-CR14">Boehm B, Basili VR (2005) Software defect reduction top 10 list. Foundations of empirical software engineering: the legacy of Victor R Basili 426(37):426–431</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2F3-540-27662-9_26" aria-label="View reference 14">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 14 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Software%20defect%20reduction%20top%2010%20list&amp;journal=Foundations%20of%20empirical%20software%20engineering%3A%20the%20legacy%20of%20Victor%20R%20Basili&amp;volume=426&amp;issue=37&amp;pages=426-431&amp;publication_year=2005&amp;author=Boehm%2CB&amp;author=Basili%2CVR">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Brooks FP Jr (1995) The mythical man-month: essays on software engineering, anniversary edition, 2/E. Pearson " /><p class="c-article-references__text" id="ref-CR15">Brooks FP Jr (1995) The mythical man-month: essays on software engineering, anniversary edition, 2/E. Pearson Education India</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Canfora G, Cerulo L, Cimitile M, Di Penta M (2011) Social interactions around cross-system bug fixings: the ca" /><p class="c-article-references__text" id="ref-CR16">Canfora G, Cerulo L, Cimitile M, Di Penta M (2011) Social interactions around cross-system bug fixings: the case of freebsd and openbsd. In: Proceedings of the 8th working conference on mining software repositories. ACM, pp 143–152</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="G. Catolino, F. Palomba, A. Zaidman, F. Ferrucci, " /><meta itemprop="datePublished" content="2019" /><meta itemprop="headline" content="Catolino G, Palomba F, Zaidman A, Ferrucci F (2019) Not all bugs are the same Understanding, characterizing, a" /><p class="c-article-references__text" id="ref-CR17">Catolino G, Palomba F, Zaidman A, Ferrucci F (2019) Not all bugs are the same Understanding, characterizing, and classifying bug types. J Syst Softw 152:165–181</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.jss.2019.03.002" aria-label="View reference 17">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 17 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Not%20all%20bugs%20are%20the%20same%20Understanding%2C%20characterizing%2C%20and%20classifying%20bug%20types&amp;journal=J%20Syst%20Softw&amp;volume=152&amp;pages=165-181&amp;publication_year=2019&amp;author=Catolino%2CG&amp;author=Palomba%2CF&amp;author=Zaidman%2CA&amp;author=Ferrucci%2CF">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="KM. Chandy, L. Lamport, " /><meta itemprop="datePublished" content="1985" /><meta itemprop="headline" content="Chandy KM, Lamport L (1985) Distributed snapshots: Determining global states of distributed systems. ACM Trans" /><p class="c-article-references__text" id="ref-CR18">Chandy KM, Lamport L (1985) Distributed snapshots: Determining global states of distributed systems. ACM Transactions on Computer Systems (TOCS) 3(1):63–75</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1145%2F214451.214456" aria-label="View reference 18">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 18 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Distributed%20snapshots%3A%20Determining%20global%20states%20of%20distributed%20systems&amp;journal=ACM%20Transactions%20on%20Computer%20Systems%20%28TOCS%29&amp;volume=3&amp;issue=1&amp;pages=63-75&amp;publication_year=1985&amp;author=Chandy%2CKM&amp;author=Lamport%2CL">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the" /><p class="c-article-references__text" id="ref-CR19">Chen T. -H., Nagappan M, Shihab E, Hassan AE (2014) An empirical study of dormant bugs. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 82–91</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Čubranic D, Murphy GC (2003) Hipikat: Recommending pertinent software development artifacts. In: 25th internat" /><p class="c-article-references__text" id="ref-CR20">Čubranic D, Murphy GC (2003) Hipikat: Recommending pertinent software development artifacts. In: 25th international conference on software engineering, 2003. Proceedings. IEEE, pp 408–418</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="da Costa DA, Kulesza U, Aranha E, Coelho R (2014) Unveiling developers contributions behind code commits: an e" /><p class="c-article-references__text" id="ref-CR21">da Costa DA, Kulesza U, Aranha E, Coelho R (2014) Unveiling developers contributions behind code commits: an exploratory study. In: Proceedings of the 29th annual ACM symposium on applied computing. ACM, pp 1152–1157</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="DA. da Costa, S. McIntosh, W. Shang, U. Kulesza, R. Coelho, AE. Hassan, " /><meta itemprop="datePublished" content="2017" /><meta itemprop="headline" content="da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results" /><p class="c-article-references__text" id="ref-CR22">da Costa DA, McIntosh S, Shang W, Kulesza U, Coelho R, Hassan AE (2017) A framework for evaluating the results of the SZZ approach for identifying bug-introducing changes. IEEE Trans Softw Eng 43(7):641–657</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2016.2616306" aria-label="View reference 22">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 22 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20framework%20for%20evaluating%20the%20results%20of%20the%20SZZ%20approach%20for%20identifying%20bug-introducing%20changes&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=43&amp;issue=7&amp;pages=641-657&amp;publication_year=2017&amp;author=da%20Costa%2CDA&amp;author=McIntosh%2CS&amp;author=Shang%2CW&amp;author=Kulesza%2CU&amp;author=Coelho%2CR&amp;author=Hassan%2CAE">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="S. Davies, M. Roper, M. Wood, " /><meta itemprop="datePublished" content="2014" /><meta itemprop="headline" content="Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the orig" /><p class="c-article-references__text" id="ref-CR23">Davies S, Roper M, Wood M (2014) Comparing text-based and dependence-based approaches for determining the origins of bugs. Journal of Software: Evolution and Process 26(1):107–139</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 23 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Comparing%20text-based%20and%20dependence-based%20approaches%20for%20determining%20the%20origins%20of%20bugs&amp;journal=Journal%20of%20Software%3A%20Evolution%20and%20Process&amp;volume=26&amp;issue=1&amp;pages=107-139&amp;publication_year=2014&amp;author=Davies%2CS&amp;author=Roper%2CM&amp;author=Wood%2CM">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Demeyer S, Ducasse S, Nierstrasz O (2002) Object-oriented reengineering patterns. Elsevier" /><p class="c-article-references__text" id="ref-CR24">Demeyer S, Ducasse S, Nierstrasz O (2002) Object-oriented reengineering patterns. Elsevier</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Dias M, Bacchelli A, Gousios G, Cassou D, Ducasse S (2015) Untangling fine-grained code changes. In: 2015 IEEE" /><p class="c-article-references__text" id="ref-CR25">Dias M, Bacchelli A, Gousios G, Cassou D, Ducasse S (2015) Untangling fine-grained code changes. In: 2015 IEEE 22nd international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 341–350</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Easterbrook S, Singer J, Storey M. -A., Damian D (2008) Selecting empirical methods for software engineering r" /><p class="c-article-references__text" id="ref-CR26">Easterbrook S, Singer J, Storey M. -A., Damian D (2008) Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering. Springer, pp 285–311</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="F. Ebert, F. Castor, A. Serebrenik, " /><meta itemprop="datePublished" content="2015" /><meta itemprop="headline" content="Ebert F, Castor F, Serebrenik A (2015) An exploratory study on exception handling bugs in Java programs. J Sys" /><p class="c-article-references__text" id="ref-CR27">Ebert F, Castor F, Serebrenik A (2015) An exploratory study on exception handling bugs in Java programs. J Syst Softw 106:82–101</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.jss.2015.04.066" aria-label="View reference 27">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 27 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=An%20exploratory%20study%20on%20exception%20handling%20bugs%20in%20Java%20programs&amp;journal=J%20Syst%20Softw&amp;volume=106&amp;pages=82-101&amp;publication_year=2015&amp;author=Ebert%2CF&amp;author=Castor%2CF&amp;author=Serebrenik%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Ell J (2013) Identifying failure inducing developer pairs within developer networks. In: Proceedings of the 20" /><p class="c-article-references__text" id="ref-CR28">Ell J (2013) Identifying failure inducing developer pairs within developer networks. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 1471–1473</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Fischer M, Pinzger M, Gall H (2003) Analyzing and relating bug report data for feature tracking. In: Proceedin" /><p class="c-article-references__text" id="ref-CR29">Fischer M, Pinzger M, Gall H (2003) Analyzing and relating bug report data for feature tracking. In: Proceedings of the 10th working conference on reverse engineering (WCRE). IEEE, pp 90–100</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Fischer M, Pinzger M, Gall H (2003) Populating a release history database from version control and bug trackin" /><p class="c-article-references__text" id="ref-CR30">Fischer M, Pinzger M, Gall H (2003) Populating a release history database from version control and bug tracking systems. In: International conference on software maintenance, 2003. ICSM 2003. Proceedings. IEEE, pp 23–32</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Fowler M, Beck K, Brant J, Opdyke W, Roberts D (1999) Refactoring: improving the design of existing code. Addi" /><p class="c-article-references__text" id="ref-CR31">Fowler M, Beck K, Brant J, Opdyke W, Roberts D (1999) Refactoring: improving the design of existing code. Addison-Wesley Professional</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Fraser G, Arcuri A (2013a) Evosuite: On the challenges of test case generation in the real world. In: 2013 IEE" /><p class="c-article-references__text" id="ref-CR32">Fraser G, Arcuri A (2013a) Evosuite: On the challenges of test case generation in the real world. In: 2013 IEEE sixth international conference on software testing, verification and validation (ICST). IEEE, pp 362–369</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="G. Fraser, A. Arcuri, " /><meta itemprop="datePublished" content="2013" /><meta itemprop="headline" content="Fraser G, Arcuri A (2013b) Whole test suite generation. IEEE Trans Softw Eng 39(2):276–291" /><p class="c-article-references__text" id="ref-CR33">Fraser G, Arcuri A (2013b) Whole test suite generation. IEEE Trans Softw Eng 39(2):276–291</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2012.14" aria-label="View reference 33">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 33 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Whole%20test%20suite%20generation&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=39&amp;issue=2&amp;pages=276-291&amp;publication_year=2013&amp;author=Fraser%2CG&amp;author=Arcuri%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="DM. German, AE. Hassan, G. Robles, " /><meta itemprop="datePublished" content="2009" /><meta itemprop="headline" content="German DM, Hassan AE, Robles G (2009) Change impact graphs: Determining the impact of prior codechanges. Inf S" /><p class="c-article-references__text" id="ref-CR34">German DM, Hassan AE, Robles G (2009) Change impact graphs: Determining the impact of prior codechanges. Inf Softw Technol 51(10):1394–1408</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.infsof.2009.04.018" aria-label="View reference 34">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 34 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Change%20impact%20graphs%3A%20Determining%20the%20impact%20of%20prior%20codechanges&amp;journal=Inf%20Softw%20Technol&amp;volume=51&amp;issue=10&amp;pages=1394-1408&amp;publication_year=2009&amp;author=German%2CDM&amp;author=Hassan%2CAE&amp;author=Robles%2CG">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="JM. Gonzalez-Barahona, G. Robles, I. Herraiz, F. Ortega, " /><meta itemprop="datePublished" content="2014" /><meta itemprop="headline" content="Gonzalez-Barahona JM, Robles G, Herraiz I, Ortega F (2014) Studying the laws of software evolution in a long-l" /><p class="c-article-references__text" id="ref-CR35">Gonzalez-Barahona JM, Robles G, Herraiz I, Ortega F (2014) Studying the laws of software evolution in a long-lived floss project. J Softw Evol Process 26 (7):589–612</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1002%2Fsmr.1615" aria-label="View reference 35">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 35 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Studying%20the%20laws%20of%20software%20evolution%20in%20a%20long-lived%20floss%20project&amp;journal=J%20Softw%20Evol%20Process&amp;volume=26&amp;issue=7&amp;pages=589-612&amp;publication_year=2014&amp;author=Gonzalez-Barahona%2CJM&amp;author=Robles%2CG&amp;author=Herraiz%2CI&amp;author=Ortega%2CF">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Gousios G, Zaidman A, Storey MD, van Deursen A (2015) Work practices and challenges in pull-based development:" /><p class="c-article-references__text" id="ref-CR36">Gousios G, Zaidman A, Storey MD, van Deursen A (2015) Work practices and challenges in pull-based development: the integrator’s perspective. In: Bertolino A., Canfora G., Elbaum S.G. (eds) 37th IEEE/ACM international conference on software engineering, ICSE 2015, Florence, Italy, May 16-24, 2015, vol 1. IEEE Computer Society, pp 358–368</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content=". Gregor, " /><meta itemprop="datePublished" content="2006" /><meta itemprop="headline" content="Gregor S (2006) The nature of theory in information systems. MIS quarterly:611–642" /><p class="c-article-references__text" id="ref-CR37">Gregor S (2006) The nature of theory in information systems. MIS quarterly:611–642</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.2307%2F25148742" aria-label="View reference 37">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 37 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=The%20Nature%20of%20Theory%20in%20Information%20Systems&amp;journal=MIS%20Quarterly&amp;volume=30&amp;issue=3&amp;publication_year=2006&amp;author=Gregor%2C">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Guerrouj L, Kermansaravi Z, Arnaoudova V, Fung BC, Khomh F, Antoniol G, Guéhéneuc Y-G (2015) Investigating the" /><p class="c-article-references__text" id="ref-CR38">Guerrouj L, Kermansaravi Z, Arnaoudova V, Fung BC, Khomh F, Antoniol G, Guéhéneuc Y-G (2015) Investigating the relation between lexical smells and change-and fault-proneness: an empirical study. Softw Qual J:1–30</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Hassan AE (2009) Predicting faults using the complexity of code changes. In: IEEE 31st international conferenc" /><p class="c-article-references__text" id="ref-CR39">Hassan AE (2009) Predicting faults using the complexity of code changes. In: IEEE 31st international conference on software engineering, 2009. ICSE 2009. IEEE, pp 78–88</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Hassan AE, Holt R (2005) The top ten list: Dynamic fault prediction. In: Proceedings of the 21st IEEE internat" /><p class="c-article-references__text" id="ref-CR40">Hassan AE, Holt R (2005) The top ten list: Dynamic fault prediction. In: Proceedings of the 21st IEEE international conference on software maintenance, 2005. ICSM’05. IEEE, pp 263–272</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="H. Hata, O. Mizuno, T. Kikuno, " /><meta itemprop="datePublished" content="2010" /><meta itemprop="headline" content="Hata H, Mizuno O, Kikuno T (2010) Fault-prone module detection using large-scale text features based on spam f" /><p class="c-article-references__text" id="ref-CR41">Hata H, Mizuno O, Kikuno T (2010) Fault-prone module detection using large-scale text features based on spam filtering. Empir Softw Eng 15(2):147–165</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-009-9117-9" aria-label="View reference 41">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 41 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Fault-prone%20module%20detection%20using%20large-scale%20text%20features%20based%20on%20spam%20filtering&amp;journal=Empir%20Softw%20Eng&amp;volume=15&amp;issue=2&amp;pages=147-165&amp;publication_year=2010&amp;author=Hata%2CH&amp;author=Mizuno%2CO&amp;author=Kikuno%2CT">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction" /><p class="c-article-references__text" id="ref-CR42">Herzig K, Just S, Zeller A (2013) It’s not a bug, it’s a feature: how misclassification impacts bug prediction. In: Proceedings of the 2013 international conference on software engineering. IEEE Press, pp 392–401</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Hilton M, Bell J, Marinov D (2018) A large-scale study of test coverage evolution. In: Proceedings of the 33rd" /><p class="c-article-references__text" id="ref-CR43">Hilton M, Bell J, Marinov D (2018) A large-scale study of test coverage evolution. In: Proceedings of the 33rd ACM/IEEE international conference on automated software engineering (ASE). ACM, pp 53–63</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Hindle A, German DM, Holt R (2008) What do large commits tell us?: a taxonomical study of large commits. In: P" /><p class="c-article-references__text" id="ref-CR44">Hindle A, German DM, Holt R (2008) What do large commits tell us?: a taxonomical study of large commits. In: Proceedings of the 2008 international working conference on mining software repositories. ACM, pp 99–108</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Co" /><p class="c-article-references__text" id="ref-CR45">Institute of Electrical and Electronics Engineers and IEEE Computer Society. Software Engineering Standards Committee (2009) IEEE standard 1044-2009: Classification for software anomalies. IEEE std IEEE</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="ISO/IEC (2001) ISO/IEC 9126. Software engineering – Product quality ISO/IEC" /><p class="c-article-references__text" id="ref-CR46">ISO/IEC (2001) ISO/IEC 9126. Software engineering – Product quality ISO/IEC</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Itkonen J, Mantyla MV, Lassenius C (2007) Defect detection efficiency: Test case based vs. exploratory testing" /><p class="c-article-references__text" id="ref-CR47">Itkonen J, Mantyla MV, Lassenius C (2007) Defect detection efficiency: Test case based vs. exploratory testing. In: First international symposium on empirical software engineering and measurement, 2007. ESEM 2007. IEEE, pp 61–70</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="D. Izquierdo-Cortazar, A. Capiluppi, JM. Gonzalez-Barahona, " /><meta itemprop="datePublished" content="2011" /><meta itemprop="headline" content="Izquierdo-Cortazar D, Capiluppi A, Gonzalez-Barahona JM (2011) Are developers fixing their own bugs?: Tracing " /><p class="c-article-references__text" id="ref-CR48">Izquierdo-Cortazar D, Capiluppi A, Gonzalez-Barahona JM (2011) Are developers fixing their own bugs?: Tracing bug-fixing and bug-seeding committers. International Journal of Open Source Software and Processes (IJOSSP) 3(2):23–42</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.4018%2Fjossp.2011040102" aria-label="View reference 48">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 48 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Are%20developers%20fixing%20their%20own%20bugs%3F%3A%20Tracing%20bug-fixing%20and%20bug-seeding%20committers&amp;journal=International%20Journal%20of%20Open%20Source%20Software%20and%20Processes%20%28IJOSSP%29&amp;volume=3&amp;issue=2&amp;pages=23-42&amp;publication_year=2011&amp;author=Izquierdo-Cortazar%2CD&amp;author=Capiluppi%2CA&amp;author=Gonzalez-Barahona%2CJM">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Izquierdo-Cortázar D., Robles G, González-Barahona J. M. (2012) Do more experienced developers introduce fewer" /><p class="c-article-references__text" id="ref-CR49">Izquierdo-Cortázar D., Robles G, González-Barahona J. M. (2012) Do more experienced developers introduce fewer bugs? In: IFIP International conference on open source systems. Springer, pp 268–273</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="J. Jacobs, J. Moll, R. Kusters, J. Trienekens, A. Brombacher, " /><meta itemprop="datePublished" content="2007" /><meta itemprop="headline" content="Jacobs J, Van Moll J, Kusters R, Trienekens J, Brombacher A (2007) Identification of factors that influence de" /><p class="c-article-references__text" id="ref-CR50">Jacobs J, Van Moll J, Kusters R, Trienekens J, Brombacher A (2007) Identification of factors that influence defect injection and detection in development of software intensive products. Inf Softw Technol 49(7):774–789</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.infsof.2006.09.002" aria-label="View reference 50">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 50 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Identification%20of%20factors%20that%20influence%20defect%20injection%20and%20detection%20in%20development%20of%20software%20intensive%20products&amp;journal=Inf%20Softw%20Technol&amp;volume=49&amp;issue=7&amp;pages=774-789&amp;publication_year=2007&amp;author=Jacobs%2CJ&amp;author=Moll%2CJ&amp;author=Kusters%2CR&amp;author=Trienekens%2CJ&amp;author=Brombacher%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Kalliamvakou E, Gousios G, Blincoe K, Singer L, German DM, Damian D (2014) The promises and perils of mining G" /><p class="c-article-references__text" id="ref-CR51">Kalliamvakou E, Gousios G, Blincoe K, Singer L, German DM, Damian D (2014) The promises and perils of mining GitHub. In: Proceedings of the 11th working conference on mining software repositories. ACM, pp 92–101</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="Y. Kamei, E. Shihab, B. Adams, AE. Hassan, A. Mockus, A. Sinha, N. Ubayashi, " /><meta itemprop="datePublished" content="2013" /><meta itemprop="headline" content="Kamei Y, Shihab E, Adams B, Hassan AE, Mockus A, Sinha A, Ubayashi N (2013) A large-scale empirical study of j" /><p class="c-article-references__text" id="ref-CR52">Kamei Y, Shihab E, Adams B, Hassan AE, Mockus A, Sinha A, Ubayashi N (2013) A large-scale empirical study of just-in-time quality assurance. IEEE Trans Softw Eng 39(6):757–773</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2012.70" aria-label="View reference 52">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 52 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20large-scale%20empirical%20study%20of%20just-in-time%20quality%20assurance&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=39&amp;issue=6&amp;pages=757-773&amp;publication_year=2013&amp;author=Kamei%2CY&amp;author=Shihab%2CE&amp;author=Adams%2CB&amp;author=Hassan%2CAE&amp;author=Mockus%2CA&amp;author=Sinha%2CA&amp;author=Ubayashi%2CN">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Kim S, Whitehead E Jr, et al. (2006) Properties of signature change patterns. In: 22nd IEEE international conf" /><p class="c-article-references__text" id="ref-CR53">Kim S, Whitehead E Jr, et al. (2006) Properties of signature change patterns. In: 22nd IEEE international conference on software maintenance, 2006. ICSM’06. IEEE, pp 4–13</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="S. Kim, EJr. Whitehead, Y. Zhang, " /><meta itemprop="datePublished" content="2008" /><meta itemprop="headline" content="Kim S, Whitehead E Jr, Zhang Y (2008) Classifying software changes: Clean or buggy? IEEE Trans Softw Eng 34(2)" /><p class="c-article-references__text" id="ref-CR54">Kim S, Whitehead E Jr, Zhang Y (2008) Classifying software changes: Clean or buggy? IEEE Trans Softw Eng 34(2):181–196</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2007.70773" aria-label="View reference 54">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 54 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Classifying%20software%20changes%3A%20Clean%20or%20buggy%3F&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=34&amp;issue=2&amp;pages=181-196&amp;publication_year=2008&amp;author=Kim%2CS&amp;author=Whitehead%2CEJr&amp;author=Zhang%2CY">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21s" /><p class="c-article-references__text" id="ref-CR55">Kim S, Zimmermann T, Pan K, Whitehead E Jr (2006) Automatic identification of bug-introducing changes. In: 21st IEEE/ACM international conference on automated software engineering, 2006. ASE’06. IEEE, pp 81–90</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Kim S, Zimmermann T, Whitehead E Jr, Zeller A (2007) Predicting faults from cached history. In: Proceedings of" /><p class="c-article-references__text" id="ref-CR56">Kim S, Zimmermann T, Whitehead E Jr, Zeller A (2007) Predicting faults from cached history. In: Proceedings of the 29th international conference on software engineering. IEEE Computer Society, pp 489–498</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Knauss E, Damian D, Knauss A, Borici A (2014) Openness and requirements: opportunities and tradeoffs in softwa" /><p class="c-article-references__text" id="ref-CR57">Knauss E, Damian D, Knauss A, Borici A (2014) Openness and requirements: opportunities and tradeoffs in software ecosystems. In: 2014 IEEE 22nd international requirements engineering conference (RE). IEEE, pp 213–222</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Knauss E, Liebel G, Horkoff J, Wohlrab R, Kasauli R, Lange F, Gildert P (2018) T-reqs: Tool support for managi" /><p class="c-article-references__text" id="ref-CR58">Knauss E, Liebel G, Horkoff J, Wohlrab R, Kasauli R, Lange F, Gildert P (2018) T-reqs: Tool support for managing requirements in large-scale agile system development. arXiv:<a href="http://arxiv.org/abs/1805.02769">1805.02769</a>
</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="LaToza TD, Venolia G, DeLine R (2006) Maintaining mental models: a study of developer work habits. In: Proceed" /><p class="c-article-references__text" id="ref-CR59">LaToza TD, Venolia G, DeLine R (2006) Maintaining mental models: a study of developer work habits. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 492–501</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Le T-DB, Linares-Vásquez M, Lo D, Poshyvanyk D (2015) Rclinker: automated linking of issue reports and commits" /><p class="c-article-references__text" id="ref-CR60">Le T-DB, Linares-Vásquez M, Lo D, Poshyvanyk D (2015) Rclinker: automated linking of issue reports and commits leveraging rich contextual information. In: 2015 IEEE 23rd international conference on program comprehension (ICPC). IEEE, pp 36–47</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Li Z, Tan L, Wang X, Lu S, Zhou Y, Zhai C (2006) Have things changed now?: an empirical study of bug character" /><p class="c-article-references__text" id="ref-CR61">Li Z, Tan L, Wang X, Lu S, Zhou Y, Zhai C (2006) Have things changed now?: an empirical study of bug characteristics in modern open source software. In: Proceedings of the 1st workshop on Architectural and system support for improving software dependability. ACM, pp 25–33</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Marsavina C, Romano D, Zaidman A (2014) Studying fine-grained co-evolution patterns of production and test cod" /><p class="c-article-references__text" id="ref-CR62">Marsavina C, Romano D, Zaidman A (2014) Studying fine-grained co-evolution patterns of production and test code. In: 2014 IEEE 14th international working conference on source code analysis and manipulation (SCAM). IEEE, pp 195–204</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="F. Massacci, VH. Nguyen, " /><meta itemprop="datePublished" content="2014" /><meta itemprop="headline" content="Massacci F, Nguyen VH (2014) An empirical methodology to evaluate vulnerability discovery models. IEEE Trans S" /><p class="c-article-references__text" id="ref-CR63">Massacci F, Nguyen VH (2014) An empirical methodology to evaluate vulnerability discovery models. IEEE Trans Softw Eng 40(12):1147–1162</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2014.2354037" aria-label="View reference 63">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 63 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=An%20empirical%20methodology%20to%20evaluate%20vulnerability%20discovery%20models&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=40&amp;issue=12&amp;pages=1147-1162&amp;publication_year=2014&amp;author=Massacci%2CF&amp;author=Nguyen%2CVH">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Meneely A, Srinivasan H, Musa A, Tejeda AR, Mokary M, Spates B (2013) When a patch goes bad: Exploring the pro" /><p class="c-article-references__text" id="ref-CR64">Meneely A, Srinivasan H, Musa A, Tejeda AR, Mokary M, Spates B (2013) When a patch goes bad: Exploring the properties of vulnerability-contributing commits. In: 2013 ACM/IEEE international symposium on empirical software engineering and measurement. IEEE, pp 65–74</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Mens T, Wermelinger M, Ducasse S, Demeyer S, Hirschfeld R, Jazayeri M (2005) Challenges in software evolution." /><p class="c-article-references__text" id="ref-CR65">Mens T, Wermelinger M, Ducasse S, Demeyer S, Hirschfeld R, Jazayeri M (2005) Challenges in software evolution. In: Eighth international workshop on principles of software evolution. IEEE, pp 13–22</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="A. Mockus, DM. Weiss, " /><meta itemprop="datePublished" content="2000" /><meta itemprop="headline" content="Mockus A, Weiss DM (2000) Predicting risk of software changes. Bell Labs Technical Journal 5(2):169–180" /><p class="c-article-references__text" id="ref-CR66">Mockus A, Weiss DM (2000) Predicting risk of software changes. Bell Labs Technical Journal 5(2):169–180</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1002%2Fbltj.2229" aria-label="View reference 66">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 66 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Predicting%20risk%20of%20software%20changes&amp;journal=Bell%20Labs%20Technical%20Journal&amp;volume=5&amp;issue=2&amp;pages=169-180&amp;publication_year=2000&amp;author=Mockus%2CA&amp;author=Weiss%2CDM">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution " /><p class="c-article-references__text" id="ref-CR67">Moonen L, van Deursen A, Zaidman A, Bruntink M (2008) On the interplay between software testing and evolution and its effect on program comprehension. In: Mens T, Demeyer S (eds) Software evolution. Springer, pp 173–202</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="E. Murphy-Hill, T. Zimmermann, C. Bird, N. Nagappan, " /><meta itemprop="datePublished" content="2015" /><meta itemprop="headline" content="Murphy-Hill E, Zimmermann T, Bird C, Nagappan N (2015) The design space of bug fixes and how developers naviga" /><p class="c-article-references__text" id="ref-CR68">Murphy-Hill E, Zimmermann T, Bird C, Nagappan N (2015) The design space of bug fixes and how developers navigate it. IEEE Trans Softw Eng 41(1):65–81</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2014.2357438" aria-label="View reference 68">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 68 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=The%20design%20space%20of%20bug%20fixes%20and%20how%20developers%20navigate%20it&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=41&amp;issue=1&amp;pages=65-81&amp;publication_year=2015&amp;author=Murphy-Hill%2CE&amp;author=Zimmermann%2CT&amp;author=Bird%2CC&amp;author=Nagappan%2CN">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Nagappan N, Ball T, Zeller A (2006) Mining metrics to predict component failures. In: Proceedings of the 28th " /><p class="c-article-references__text" id="ref-CR69">Nagappan N, Ball T, Zeller A (2006) Mining metrics to predict component failures. In: Proceedings of the 28th international conference on Software engineering. ACM, pp 452–461</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="T. Nakajo, H. Kume, " /><meta itemprop="datePublished" content="1991" /><meta itemprop="headline" content="Nakajo T, Kume H (1991) A case history analysis of software error cause-effect relationships. IEEE Trans Softw" /><p class="c-article-references__text" id="ref-CR70">Nakajo T, Kume H (1991) A case history analysis of software error cause-effect relationships. IEEE Trans Softw Eng 17(8):830–838</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2F32.83917" aria-label="View reference 70">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 70 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20case%20history%20analysis%20of%20software%20error%20cause-effect%20relationships&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=17&amp;issue=8&amp;pages=830-838&amp;publication_year=1991&amp;author=Nakajo%2CT&amp;author=Kume%2CH">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical st" /><p class="c-article-references__text" id="ref-CR71">Neto EC, da Costa DA, Kulesza U (2018) The impact of refactoring changes on the SZZ algorithm: an empirical study. In: 2018 IEEE 25th international conference on software analysis, evolution and reengineering (SANER). IEEE, pp 380–390</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Neto EC, da Costa DA, Kulesza U (2019) Revisiting and improving SZZ implementations. In: 2019 ACM/IEEE Interna" /><p class="c-article-references__text" id="ref-CR72">Neto EC, da Costa DA, Kulesza U (2019) Revisiting and improving SZZ implementations. In: 2019 ACM/IEEE International symposium on empirical software engineering and measurement. ACM</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Nuseibeh B, Easterbrook S (2000) Requirements engineering: a roadmap. In: Proceedings of the conference on the" /><p class="c-article-references__text" id="ref-CR73">Nuseibeh B, Easterbrook S (2000) Requirements engineering: a roadmap. In: Proceedings of the conference on the future of software engineering. ACM, pp 35–46</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="KJ. Ottenstein, LM. Ottenstein, " /><meta itemprop="datePublished" content="1984" /><meta itemprop="headline" content="Ottenstein KJ, Ottenstein LM (1984) The program dependence graph in a software development environment. ACM Si" /><p class="c-article-references__text" id="ref-CR74">Ottenstein KJ, Ottenstein LM (1984) The program dependence graph in a software development environment. ACM Sigplan Notices 19(5):177–184</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1145%2F390011.808263" aria-label="View reference 74">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 74 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=The%20program%20dependence%20graph%20in%20a%20software%20development%20environment&amp;journal=ACM%20Sigplan%20Notices&amp;volume=19&amp;issue=5&amp;pages=177-184&amp;publication_year=1984&amp;author=Ottenstein%2CKJ&amp;author=Ottenstein%2CLM">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Palomba F, Panichella A, Zaidman A, Oliveto R, De Lucia A (2016) Automatic test case generation: what if test " /><p class="c-article-references__text" id="ref-CR75">Palomba F, Panichella A, Zaidman A, Oliveto R, De Lucia A (2016) Automatic test case generation: what if test code quality matters? In: Proceedings of the 25th international symposium on software testing and analysis (ISSTA). ACM, pp 130–141</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Palomba F, Zaidman A (2017) Does refactoring of test smells induce fixing flaky tests? In: Proceedings of the " /><p class="c-article-references__text" id="ref-CR76">Palomba F, Zaidman A (2017) Does refactoring of test smells induce fixing flaky tests? In: Proceedings of the International Conference on Software Maintenance and Evolution (ICSME). IEEE, pp 1–12</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="F. Palomba, A. Zaidman, " /><meta itemprop="datePublished" content="2019" /><meta itemprop="headline" content="Palomba F, Zaidman A (2019) The smell of fear: on the relation between test smells and flaky tests. Empirical " /><p class="c-article-references__text" id="ref-CR77">Palomba F, Zaidman A (2019) The smell of fear: on the relation between test smells and flaky tests. Empirical Software Engineering (EMSE) 24(5):2907–2946</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-019-09683-z" aria-label="View reference 77">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 77 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=The%20smell%20of%20fear%3A%20on%20the%20relation%20between%20test%20smells%20and%20flaky%20tests&amp;journal=Empirical%20Software%20Engineering%20%28EMSE%29&amp;volume=24&amp;issue=5&amp;pages=2907-2946&amp;publication_year=2019&amp;author=Palomba%2CF&amp;author=Zaidman%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="K. Pan, S. Kim, EJJr. Whitehead, " /><meta itemprop="datePublished" content="2009" /><meta itemprop="headline" content="Pan K, Kim S, Whitehead EJ Jr (2009) Toward an understanding of bug fix patterns. Empir Softw Eng 14(3):286–31" /><p class="c-article-references__text" id="ref-CR78">Pan K, Kim S, Whitehead EJ Jr (2009) Toward an understanding of bug fix patterns. Empir Softw Eng 14(3):286–315</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-008-9077-5" aria-label="View reference 78">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 78 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Toward%20an%20understanding%20of%20bug%20fix%20patterns&amp;journal=Empir%20Softw%20Eng&amp;volume=14&amp;issue=3&amp;pages=286-315&amp;publication_year=2009&amp;author=Pan%2CK&amp;author=Kim%2CS&amp;author=Whitehead%2CEJJr">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="L. Prechelt, A. Pepper, " /><meta itemprop="datePublished" content="2014" /><meta itemprop="headline" content="Prechelt L, Pepper A (2014) Why software repositories are not used for defect-insertion circumstance analysis " /><p class="c-article-references__text" id="ref-CR79">Prechelt L, Pepper A (2014) Why software repositories are not used for defect-insertion circumstance analysis more often: A case study. Inf Softw Technol 56 (10):1377–1389</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.infsof.2014.05.001" aria-label="View reference 79">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 79 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Why%20software%20repositories%20are%20not%20used%20for%20defect-insertion%20circumstance%20analysis%20more%20often%3A%20A%20case%20study&amp;journal=Inf%20Softw%20Technol&amp;volume=56&amp;issue=10&amp;pages=1377-1389&amp;publication_year=2014&amp;author=Prechelt%2CL&amp;author=Pepper%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Rahman F, Khatri S, Barr E, Devanbu P (2014) Comparing static bug finders and statistical prediction. In: Proc" /><p class="c-article-references__text" id="ref-CR80">Rahman F, Khatri S, Barr E, Devanbu P (2014) Comparing static bug finders and statistical prediction. In: Proceedings of the 36th international conference on software engineering. ACM, pp 424–434</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Rahman F, Posnett D, Hindle A, Barr E, Devanbu P (2011) Bugcache for inspections: hit or miss? In: Proceedings" /><p class="c-article-references__text" id="ref-CR81">Rahman F, Posnett D, Hindle A, Barr E, Devanbu P (2011) Bugcache for inspections: hit or miss? In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering. ACM, pp 322–331</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Ray B, Hellendoorn V, Godhane S, Tu Z, Bacchelli A, Devanbu P (2016) On the naturalness of buggy code. In: Pro" /><p class="c-article-references__text" id="ref-CR82">Ray B, Hellendoorn V, Godhane S, Tu Z, Bacchelli A, Devanbu P (2016) On the naturalness of buggy code. In: Proceedings of the 38th international conference on software engineering. ACM, pp 428–439</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Ray B, Posnett D, Filkov V, Devanbu P (2014) A large scale study of programming languages and code quality in " /><p class="c-article-references__text" id="ref-CR83">Ray B, Posnett D, Filkov V, Devanbu P (2014) A large scale study of programming languages and code quality in github. In: Proceedings of the 22nd ACM SIGSOFT international symposium on foundations of software engineering. ACM, pp 155–165</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assi" /><p class="c-article-references__text" id="ref-CR84">Rodríguez-Pérez G., Gonzalez-Barahona JM, Robles G, Dalipaj D, Sekitoleko N (2016) Bugtracking: A tool to assist in the identification of bug reports. In: IFIP International conference on open source systems. Springer, pp 192–198</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Rodriguez-Perez G, Robles G, Gonzalez-Barahona JM (2017) How much time did it take to notify a bug?: two case " /><p class="c-article-references__text" id="ref-CR85">Rodriguez-Perez G, Robles G, Gonzalez-Barahona JM (2017) How much time did it take to notify a bug?: two case studies: elasticsearch and nova. In: Proceedings of the 8th workshop on emerging trends in software metrics. IEEE Press, pp 29–35</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="G. Rodríguez-Pérez, G. Robles, JM. González-Barahona, " /><meta itemprop="datePublished" content="2018" /><meta itemprop="headline" content="Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical softwar" /><p class="c-article-references__text" id="ref-CR86">Rodríguez-Pérez G, Robles G, González-Barahona JM (2018a) Reproducibility and credibility in empirical software engineering: A case study based on a systematic literature review of the use of the szz algorithm. Inf Softw Technol 99:164–176</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.infsof.2018.03.009" aria-label="View reference 86">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 86 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Reproducibility%20and%20credibility%20in%20empirical%20software%20engineering%3A%20A%20case%20study%20based%20on%20a%20systematic%20literature%20review%20of%20the%20use%20of%20the%20szz%20algorithm&amp;journal=Inf%20Softw%20Technol&amp;volume=99&amp;pages=164-176&amp;publication_year=2018&amp;author=Rodr%C3%ADguez-P%C3%A9rez%2CG&amp;author=Robles%2CG&amp;author=Gonz%C3%A1lez-Barahona%2CJM">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a differe" /><p class="c-article-references__text" id="ref-CR87">Rodríguez-Pérez G, Zaidman A, Serebrenik A, Robles G, González-Barahona JM (2018b) What if a bug has a different origin? Making sense of bugs without an explicit bug introducing change. In: 12th international symposium on empirical software engineering and measurement (ESEM). ACM, pp 52:1–52:4</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="G. Rothermel, MJ. Harrold, " /><meta itemprop="datePublished" content="1996" /><meta itemprop="headline" content="Rothermel G, Harrold MJ (1996) Analyzing regression test selection techniques. IEEE Trans Softw Eng 22(8):529–" /><p class="c-article-references__text" id="ref-CR88">Rothermel G, Harrold MJ (1996) Analyzing regression test selection techniques. IEEE Trans Softw Eng 22(8):529–551</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2F32.536955" aria-label="View reference 88">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 88 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Analyzing%20regression%20test%20selection%20techniques&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=22&amp;issue=8&amp;pages=529-551&amp;publication_year=1996&amp;author=Rothermel%2CG&amp;author=Harrold%2CMJ">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/Book"><meta itemprop="author" content="P. Runeson, M. Host, A. Rainer, B. Regnell, " /><meta itemprop="datePublished" content="2012" /><meta itemprop="headline" content="Runeson P, Host M, Rainer A, Regnell B (2012) Case study research in software engineering: Guidelines and exam" /><p class="c-article-references__text" id="ref-CR89">Runeson P, Host M, Rainer A, Regnell B (2012) Case study research in software engineering: Guidelines and examples. Wiley, New York</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 89 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Case%20study%20research%20in%20software%20engineering%3A%20Guidelines%20and%20examples&amp;publication_year=2012&amp;author=Runeson%2CP&amp;author=Host%2CM&amp;author=Rainer%2CA&amp;author=Regnell%2CB">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Sahal E, Tosun A (2018) Identifying bug-inducing changes for code additions. In: Proceedings of the 12th ACM/I" /><p class="c-article-references__text" id="ref-CR90">Sahal E, Tosun A (2018) Identifying bug-inducing changes for code additions. In: Proceedings of the 12th ACM/IEEE international symposium on empirical software engineering and measurement. ACM, p 57</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="E. Shihab, A. Ihara, Y. Kamei, WM. Ibrahim, M. Ohira, B. Adams, AE. Hassan, K-i. Matsumoto, " /><meta itemprop="datePublished" content="2013" /><meta itemprop="headline" content="Shihab E, Ihara A, Kamei Y, Ibrahim WM, Ohira M, Adams B, Hassan AE, Matsumoto K. -i. (2013) Studying re-opene" /><p class="c-article-references__text" id="ref-CR91">Shihab E, Ihara A, Kamei Y, Ibrahim WM, Ohira M, Adams B, Hassan AE, Matsumoto K. -i. (2013) Studying re-opened bugs in open source software. Empir Softw Eng 18(5):1005–1042</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-012-9228-6" aria-label="View reference 91">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 91 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Studying%20re-opened%20bugs%20in%20open%20source%20software&amp;journal=Empir%20Softw%20Eng&amp;volume=18&amp;issue=5&amp;pages=1005-1042&amp;publication_year=2013&amp;author=Shihab%2CE&amp;author=Ihara%2CA&amp;author=Kamei%2CY&amp;author=Ibrahim%2CWM&amp;author=Ohira%2CM&amp;author=Adams%2CB&amp;author=Hassan%2CAE&amp;author=Matsumoto%2CK-i">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Sinha VS, Sinha S, Rao S (2010) Buginnings: identifying the origins of a bug. In: Proceedings of the 3rd India" /><p class="c-article-references__text" id="ref-CR92">Sinha VS, Sinha S, Rao S (2010) Buginnings: identifying the origins of a bug. In: Proceedings of the 3rd India software engineering conference. ACM, pp 3–12</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 Internationa" /><p class="c-article-references__text" id="ref-CR93">Śliwerski J, Zimmermann T, Zeller A (2005) When do changes induce fixes?. Proceedings of the 2005 International workshop on mining software repositories: 1–5</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Soetens QD, Pérez J., Demeyer S, Zaidman A (2015) Circumventing refactoring masking using fine-grained change " /><p class="c-article-references__text" id="ref-CR94">Soetens QD, Pérez J., Demeyer S, Zaidman A (2015) Circumventing refactoring masking using fine-grained change recording. In: Proceedings of the 14th international workshop on principles of software evolution. ACM, pp 9–18</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="Y. Sun, Q. Wang, Y. Yang, " /><meta itemprop="datePublished" content="2017" /><meta itemprop="headline" content="Sun Y, Wang Q, Yang Y (2017) Frlink: Improving the recovery of missing issue-commit links by revisiting file r" /><p class="c-article-references__text" id="ref-CR95">Sun Y, Wang Q, Yang Y (2017) Frlink: Improving the recovery of missing issue-commit links by revisiting file relevance. Inf Softw Technol 84:33–47</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2Fj.infsof.2016.11.010" aria-label="View reference 95">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 95 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Frlink%3A%20Improving%20the%20recovery%20of%20missing%20issue-commit%20links%20by%20revisiting%20file%20relevance&amp;journal=Inf%20Softw%20Technol&amp;volume=84&amp;pages=33-47&amp;publication_year=2017&amp;author=Sun%2CY&amp;author=Wang%2CQ&amp;author=Yang%2CY">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="MD. Syer, M. Nagappan, B. Adams, AE. Hassan, " /><meta itemprop="datePublished" content="2015" /><meta itemprop="headline" content="Syer MD, Nagappan M, Adams B, Hassan AE (2015) Replicating and re-evaluating the theory of relative defect-pro" /><p class="c-article-references__text" id="ref-CR96">Syer MD, Nagappan M, Adams B, Hassan AE (2015) Replicating and re-evaluating the theory of relative defect-proneness. IEEE Trans Softw Eng 41 (2):176–197</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1109%2FTSE.2014.2361131" aria-label="View reference 96">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 96 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Replicating%20and%20re-evaluating%20the%20theory%20of%20relative%20defect-proneness&amp;journal=IEEE%20Trans%20Softw%20Eng&amp;volume=41&amp;issue=2&amp;pages=176-197&amp;publication_year=2015&amp;author=Syer%2CMD&amp;author=Nagappan%2CM&amp;author=Adams%2CB&amp;author=Hassan%2CAE">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="L. Tan, C. Liu, Z. Li, X. Wang, Y. Zhou, C. Zhai, " /><meta itemprop="datePublished" content="2014" /><meta itemprop="headline" content="Tan L, Liu C, Li Z, Wang X, Zhou Y, Zhai C (2014) Bug characteristics in open source software. Empir Softw Eng" /><p class="c-article-references__text" id="ref-CR97">Tan L, Liu C, Li Z, Wang X, Zhou Y, Zhai C (2014) Bug characteristics in open source software. Empir Softw Eng 19(6):1665–1705</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-013-9258-8" aria-label="View reference 97">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 97 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Bug%20characteristics%20in%20open%20source%20software&amp;journal=Empir%20Softw%20Eng&amp;volume=19&amp;issue=6&amp;pages=1665-1705&amp;publication_year=2014&amp;author=Tan%2CL&amp;author=Liu%2CC&amp;author=Li%2CZ&amp;author=Wang%2CX&amp;author=Zhou%2CY&amp;author=Zhai%2CC">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Tantithamthavorn C, Teekavanich R, Ihara A, Matsumoto K-i (2013) Mining a change history to quickly identify b" /><p class="c-article-references__text" id="ref-CR98">Tantithamthavorn C, Teekavanich R, Ihara A, Matsumoto K-i (2013) Mining a change history to quickly identify bug locations: a case study of the eclipse project. In: 2013 IEEE international symposium on software reliability engineering workshops (ISSREW). IEEE, pp 108–113</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Thung F, Lo D, Jiang L (2013) Automatic recovery of root causes from bug-fixing changes. In: 2013 20th working" /><p class="c-article-references__text" id="ref-CR99">Thung F, Lo D, Jiang L (2013) Automatic recovery of root causes from bug-fixing changes. In: 2013 20th working conference on reverse engineering (WCRE). IEEE, pp 92–101</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Vassallo C, Zampetti F, Romano D, Beller M, Panichella A, Penta MD, Zaidman A (2016) Continuous delivery pract" /><p class="c-article-references__text" id="ref-CR100">Vassallo C, Zampetti F, Romano D, Beller M, Panichella A, Penta MD, Zaidman A (2016) Continuous delivery practices in a large financial organization. In: Proceedings of the international conference on software maintenance and evolution (ICSME). IEEE Computer Society, pp 519–528</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="S. Viller, J. Bowers, T. Rodden, " /><meta itemprop="datePublished" content="1999" /><meta itemprop="headline" content="Viller S, Bowers J, Rodden T (1999) Human factors in requirements engineering: A survey of human sciences lite" /><p class="c-article-references__text" id="ref-CR101">Viller S, Bowers J, Rodden T (1999) Human factors in requirements engineering: A survey of human sciences literature relevant to the improvement of dependable systems development processes. Interact Comput 11(6):665–698</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1016%2FS0953-5438%2898%2900049-6" aria-label="View reference 101">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 101 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Human%20factors%20in%20requirements%20engineering%3A%20A%20survey%20of%20human%20sciences%20literature%20relevant%20to%20the%20improvement%20of%20dependable%20systems%20development%20processes&amp;journal=Interact%20Comput&amp;volume=11&amp;issue=6&amp;pages=665-698&amp;publication_year=1999&amp;author=Viller%2CS&amp;author=Bowers%2CJ&amp;author=Rodden%2CT">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Vonken F, Zaidman A (2012) Refactoring with unit testing: a match made in heaven?. In: Proceeedings of the wor" /><p class="c-article-references__text" id="ref-CR102">Vonken F, Zaidman A (2012) Refactoring with unit testing: a match made in heaven?. In: Proceeedings of the working conference on reverse engineering (WCRE), pp 29–38</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Weiss C, Premraj R, Zimmermann T, Zeller A (2007) How long will it take to fix this bug? In: Fourth internatio" /><p class="c-article-references__text" id="ref-CR103">Weiss C, Premraj R, Zimmermann T, Zeller A (2007) How long will it take to fix this bug? In: Fourth international workshop on mining software repositories, 2007. ICSE Workshops MSR’07. IEEE, pp 1–1</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 wo" /><p class="c-article-references__text" id="ref-CR104">Williams C, Spacco J (2008) SZZ revisited: Verifying when changes induce fixes. In: Proceedings of the 2008 workshop on defects in large software systems. ACM, pp 32–36</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Wohlin C, Runeson P, Höst M, Ohlsson MC, Regnell B, Wesslén A (2012) Experimentation in software engineering. " /><p class="c-article-references__text" id="ref-CR105">Wohlin C, Runeson P, Höst M, Ohlsson MC, Regnell B, Wesslén A (2012) Experimentation in software engineering. Springer Science &amp; Business Media</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Wu R, Zhang H, Kim S, Cheung S-C (2011) Relink: recovering links between bugs and changes. In: Proceedings of " /><p class="c-article-references__text" id="ref-CR106">Wu R, Zhang H, Kim S, Cheung S-C (2011) Relink: recovering links between bugs and changes. In: Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on foundations of software engineering. ACM, pp 15–25</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="X. Xia, D. Lo, E. Shihab, X. Wang, B. Zhou, " /><meta itemprop="datePublished" content="2015" /><meta itemprop="headline" content="Xia X, Lo D, Shihab E, Wang X, Zhou B (2015) Automatic, high accuracy prediction of reopened bugs. Autom Softw" /><p class="c-article-references__text" id="ref-CR107">Xia X, Lo D, Shihab E, Wang X, Zhou B (2015) Automatic, high accuracy prediction of reopened bugs. Autom Softw Eng 22(1):75–109</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10515-014-0162-2" aria-label="View reference 107">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 107 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Automatic%2C%20high%20accuracy%20prediction%20of%20reopened%20bugs&amp;journal=Autom%20Softw%20Eng&amp;volume=22&amp;issue=1&amp;pages=75-109&amp;publication_year=2015&amp;author=Xia%2CX&amp;author=Lo%2CD&amp;author=Shihab%2CE&amp;author=Wang%2CX&amp;author=Zhou%2CB">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Zaidman A, Van Rompaey B, Demeyer S, van Deursen A (2008) Mining software repositories to study co-evolution o" /><p class="c-article-references__text" id="ref-CR108">Zaidman A, Van Rompaey B, Demeyer S, van Deursen A (2008) Mining software repositories to study co-evolution of production &amp; test code. In: First international conference on software testing, verification, and validation (ICST). IEEE, pp 220–229</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="author" content="A. Zaidman, B. Rompaey, A. Deursen, S. Demeyer, " /><meta itemprop="datePublished" content="2011" /><meta itemprop="headline" content="Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test cod" /><p class="c-article-references__text" id="ref-CR109">Zaidman A, Van Rompaey B, van Deursen A, Demeyer S (2011) Studying the co-evolution of production and test code in open source and industrial developer test processes through repository mining. Empir Softw Eng 16(3):325–364</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" href="https://doi.org/10.1007%2Fs10664-010-9143-7" aria-label="View reference 109">Article</a> 
    <a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 109 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Studying%20the%20co-evolution%20of%20production%20and%20test%20code%20in%20open%20source%20and%20industrial%20developer%20test%20processes%20through%20repository%20mining&amp;journal=Empir%20Softw%20Eng&amp;volume=16&amp;issue=3&amp;pages=325-364&amp;publication_year=2011&amp;author=Zaidman%2CA&amp;author=Rompaey%2CB&amp;author=Deursen%2CA&amp;author=Demeyer%2CS">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/Book"><meta itemprop="author" content="A. Zeller, " /><meta itemprop="datePublished" content="2009" /><meta itemprop="headline" content="Zeller A (2009) Why programs fail - a guide to systematic debugging, 2nd edn. Academic Press, New York" /><p class="c-article-references__text" id="ref-CR110">Zeller A (2009) Why programs fail - a guide to systematic debugging, 2nd edn. Academic Press, New York</p><p class="c-article-references__links u-hide-print"><a data-track="click" data-track-action="outbound reference" data-track-label="link" aria-label="Search for reference 110 on Google Scholar" href="http://scholar.google.com/scholar_lookup?&amp;title=Why%20programs%20fail%20-%20a%20guide%20to%20systematic%20debugging&amp;publication_year=2009&amp;author=Zeller%2CA">
                    Google Scholar</a> 
                </p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Zeller A, Hughes W, Lavery J, Doran K, Morrison CT, Snodgrass RT, Stärk RF (2011) Causes and effects in comput" /><p class="c-article-references__text" id="ref-CR111">Zeller A, Hughes W, Lavery J, Doran K, Morrison CT, Snodgrass RT, Stärk RF (2011) Causes and effects in computer programs. In: Proceedings of the fifth international workshop on computer, pp 482–508</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Zimmermann T, Premraj R, Zeller A (2007) Predicting defects for Eclipse. In: International workshop on predict" /><p class="c-article-references__text" id="ref-CR112">Zimmermann T, Premraj R, Zeller A (2007) Predicting defects for Eclipse. In: International workshop on predictor models in software engineering, 2007. PROMISE’07: ICSE workshops 2007. IEEE, pp 9–9</p></li><li class="c-article-references__item js-c-reading-companion-references-item" itemprop="citation" itemscope="itemscope" itemtype="http://schema.org/ScholarlyArticle"><meta itemprop="headline" content="Zimmermann T, Nagappan N, Guo PJ, Murphy B (2012) Characterizing and predicting which bugs get reopened. In: P" /><p class="c-article-references__text" id="ref-CR113">Zimmermann T, Nagappan N, Guo PJ, Murphy B (2012) Characterizing and predicting which bugs get reopened. In: Proceedings of the 34th international conference on software engineering. IEEE Press, pp 1074–1083</p></li></ol><p class="c-article-references__download u-hide-print"><a data-track="click" data-track-action="download citation references" data-track-label="link" href="/article/10.1007/s10664-019-09781-y-references.ris">Download references<svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-download"></use></svg></a></p></div></div></div></section><section aria-labelledby="Ack1" data-title="Acknowledgments"><div class="c-article-section" id="Ack1-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="Ack1">Acknowledgments</h2><div class="c-article-section__content" id="Ack1-content"><p>We want to express our gratitude to Bitergia<sup><a href="#Fn36"><span class="u-visually-hidden">Footnote </span>36</a></sup> for the support they have provided when questions have arisen using their tools. We also acknowledge the support of several authors by the Government of Spain through projects TIN2014-59400-R and “BugBirth” RTI2018-101963-B-I00. The first author has been supported by the 4TU federation (The Netherlands) through the project “Social aspects of software quality”. Other funding came from the Netherlands Organisation for Scientific Research (NWO) through the “TestRoots” project and the EU Horizon 2020 ICT-10-2016-RIA “STAMP” project (No.731529).</p></div></div></section><section aria-labelledby="author-information" data-title="Author information"><div class="c-article-section" id="author-information-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="author-information">Author information</h2><div class="c-article-section__content" id="author-information-content"><h3 class="c-article__sub-heading" id="affiliations">Affiliations</h3><ol class="c-article-author-affiliation__list"><li id="Aff1"><p class="c-article-author-affiliation__address">University of Waterloo, Waterloo, ON, N2L 3G1, Canada</p><p class="c-article-author-affiliation__authors-list">Gema Rodríguez-Pérez</p></li><li id="Aff2"><p class="c-article-author-affiliation__address">Universidad Rey Juan Carlos, Madrid, Spain</p><p class="c-article-author-affiliation__authors-list">Gregorio Robles &amp; Jesus M. Gonzalez-Barahona</p></li><li id="Aff3"><p class="c-article-author-affiliation__address">Eindhoven University of Technology, Eindhoven, The Netherlands</p><p class="c-article-author-affiliation__authors-list">Alexander Serebrenik</p></li><li id="Aff4"><p class="c-article-author-affiliation__address">Delft University of Technology, Delft, The Netherlands</p><p class="c-article-author-affiliation__authors-list">Andy Zaidman</p></li><li id="Aff5"><p class="c-article-author-affiliation__address">University of Victoria, Victoria, BC, V8P 5C2, Canada</p><p class="c-article-author-affiliation__authors-list">Daniel M. Germán</p></li></ol><div class="js-hide u-hide-print" data-test="author-info"><span class="c-article__sub-heading">Authors</span><ol class="c-article-authors-search u-list-reset"><li id="auth-Gema-Rodr_guez_P_rez"><span class="c-article-authors-search__title u-h3 js-search-name">Gema Rodríguez-Pérez</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Gema+Rodr%C3%ADguez-P%C3%A9rez&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Gema+Rodr%C3%ADguez-P%C3%A9rez" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Gema+Rodr%C3%ADguez-P%C3%A9rez%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li><li id="auth-Gregorio-Robles"><span class="c-article-authors-search__title u-h3 js-search-name">Gregorio Robles</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Gregorio+Robles&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Gregorio+Robles" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Gregorio+Robles%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li><li id="auth-Alexander-Serebrenik"><span class="c-article-authors-search__title u-h3 js-search-name">Alexander Serebrenik</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Alexander+Serebrenik&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Alexander+Serebrenik" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Alexander+Serebrenik%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li><li id="auth-Andy-Zaidman"><span class="c-article-authors-search__title u-h3 js-search-name">Andy Zaidman</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Andy+Zaidman&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Andy+Zaidman" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Andy+Zaidman%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li><li id="auth-Daniel_M_-Germ_n"><span class="c-article-authors-search__title u-h3 js-search-name">Daniel M. Germán</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Daniel M.+Germ%C3%A1n&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Daniel M.+Germ%C3%A1n" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Daniel M.+Germ%C3%A1n%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li><li id="auth-Jesus_M_-Gonzalez_Barahona"><span class="c-article-authors-search__title u-h3 js-search-name">Jesus M. Gonzalez-Barahona</span><div class="c-article-authors-search__list"><div class="c-article-authors-search__item c-article-authors-search__list-item--left"><a href="/search?dc.creator=&#34;Jesus M.+Gonzalez-Barahona&#34;" class="c-article-button" data-track="click" data-track-action="author link - publication" data-track-label="link">View author publications</a></div><div class="c-article-authors-search__item c-article-authors-search__list-item--right"><p class="search-in-title-js c-article-authors-search__text">You can also search for this author in
                        <span class="c-article-identifiers"><a class="c-article-identifiers__item" href="http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&amp;term=Jesus M.+Gonzalez-Barahona" data-track="click" data-track-action="author link - pubmed" data-track-label="link">PubMed</a><span class="u-hide"> </span><a class="c-article-identifiers__item" href="http://scholar.google.co.uk/scholar?as_q=&amp;num=10&amp;btnG=Search+Scholar&amp;as_epq=&amp;as_oq=&amp;as_eq=&amp;as_occt=any&amp;as_sauthors=%22Jesus M.+Gonzalez-Barahona%22&amp;as_publication=&amp;as_ylo=&amp;as_yhi=&amp;as_allsubj=all&amp;hl=en" data-track="click" data-track-action="author link - scholar" data-track-label="link">Google Scholar</a></span></p></div></div></li></ol></div><h3 class="c-article__sub-heading" id="corresponding-author">Corresponding author</h3><p id="corresponding-author-list">Correspondence to
                <a id="corresp-c1" rel="nofollow" href="/article/10.1007/s10664-019-09781-y/email/correspondent/c1/new">Gregorio Robles</a>.</p></div></div></section><section aria-labelledby="additional-information" data-title="Additional information"><div class="c-article-section" id="additional-information-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="additional-information">Additional information</h2><div class="c-article-section__content" id="additional-information-content"><h3 class="c-article__sub-heading">Publisher’s note</h3><p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p><p>Communicated by: Per Runeson</p></div></div></section><section aria-labelledby="rightslink" data-title="Rights and permissions"><div class="c-article-section" id="rightslink-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="rightslink">Rights and permissions</h2><div class="c-article-section__content" id="rightslink-content">
                <p><b>Open Access</b> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <a href="http://creativecommons.org/licenses/by/4.0/" rel="license" itemprop="license">http://creativecommons.org/licenses/by/4.0/</a>.</p>
              <p class="c-article-rights"><a data-track="click" data-track-action="view rights and permissions" data-track-label="link" href="https://s100.copyright.com/AppDispatchServlet?title=How%20bugs%20are%20born%3A%20a%20model%20to%20identify%20how%20bugs%20are%20introduced%20in%20software%20components&amp;author=Gema%20Rodr%C3%ADguez-P%C3%A9rez%20et%20al&amp;contentID=10.1007%2Fs10664-019-09781-y&amp;publication=1382-3256&amp;publicationDate=2020-02-04&amp;publisherName=SpringerNature&amp;orderBeanReset=true&amp;oa=CC%20BY">Reprints and Permissions</a></p></div></div></section><section aria-labelledby="article-info" data-title="About this article"><div class="c-article-section" id="article-info-section"><h2 class="c-article-section__title js-section-title js-c-reading-companion-sections-item" id="article-info">About this article</h2><div class="c-article-section__content" id="article-info-content"><div class="c-bibliographic-information"><div class="u-hide-print c-bibliographic-information__column c-bibliographic-information__column--border"><a data-crossmark="10.1007/s10664-019-09781-y" target="_blank" rel="noopener" href="https://crossmark.crossref.org/dialog/?doi=10.1007/s10664-019-09781-y" data-track="click" data-track-action="Click Crossmark" data-track-label="link" data-test="crossmark"><img width="57" height="81" alt="Verify currency and authenticity via CrossMark" src="data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjgxIiB3aWR0aD0iNTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMTcuMzUgMzUuNDUgMjEuMy0xNC4ydi0xNy4wM2gtMjEuMyIgZmlsbD0iIzk4OTg5OCIvPjxwYXRoIGQ9Im0zOC42NSAzNS40NS0yMS4zLTE0LjJ2LTE3LjAzaDIxLjMiIGZpbGw9IiM3NDc0NzQiLz48cGF0aCBkPSJtMjggLjVjLTEyLjk4IDAtMjMuNSAxMC41Mi0yMy41IDIzLjVzMTAuNTIgMjMuNSAyMy41IDIzLjUgMjMuNS0xMC41MiAyMy41LTIzLjVjMC02LjIzLTIuNDgtMTIuMjEtNi44OC0xNi42Mi00LjQxLTQuNC0xMC4zOS02Ljg4LTE2LjYyLTYuODh6bTAgNDEuMjVjLTkuOCAwLTE3Ljc1LTcuOTUtMTcuNzUtMTcuNzVzNy45NS0xNy43NSAxNy43NS0xNy43NSAxNy43NSA3Ljk1IDE3Ljc1IDE3Ljc1YzAgNC43MS0xLjg3IDkuMjItNS4yIDEyLjU1cy03Ljg0IDUuMi0xMi41NSA1LjJ6IiBmaWxsPSIjNTM1MzUzIi8+PHBhdGggZD0ibTQxIDM2Yy01LjgxIDYuMjMtMTUuMjMgNy40NS0yMi40MyAyLjktNy4yMS00LjU1LTEwLjE2LTEzLjU3LTcuMDMtMjEuNWwtNC45Mi0zLjExYy00Ljk1IDEwLjctMS4xOSAyMy40MiA4Ljc4IDI5LjcxIDkuOTcgNi4zIDIzLjA3IDQuMjIgMzAuNi00Ljg2eiIgZmlsbD0iIzljOWM5YyIvPjxwYXRoIGQ9Im0uMiA1OC40NWMwLS43NS4xMS0xLjQyLjMzLTIuMDFzLjUyLTEuMDkuOTEtMS41Yy4zOC0uNDEuODMtLjczIDEuMzQtLjk0LjUxLS4yMiAxLjA2LS4zMiAxLjY1LS4zMi41NiAwIDEuMDYuMTEgMS41MS4zNS40NC4yMy44MS41IDEuMS44MWwtLjkxIDEuMDFjLS4yNC0uMjQtLjQ5LS40Mi0uNzUtLjU2LS4yNy0uMTMtLjU4LS4yLS45My0uMi0uMzkgMC0uNzMuMDgtMS4wNS4yMy0uMzEuMTYtLjU4LjM3LS44MS42Ni0uMjMuMjgtLjQxLjYzLS41MyAxLjA0LS4xMy40MS0uMTkuODgtLjE5IDEuMzkgMCAxLjA0LjIzIDEuODYuNjggMi40Ni40NS41OSAxLjA2Ljg4IDEuODQuODguNDEgMCAuNzctLjA3IDEuMDctLjIzcy41OS0uMzkuODUtLjY4bC45MSAxYy0uMzguNDMtLjguNzYtMS4yOC45OS0uNDcuMjItMSAuMzQtMS41OC4zNC0uNTkgMC0xLjEzLS4xLTEuNjQtLjMxLS41LS4yLS45NC0uNTEtMS4zMS0uOTEtLjM4LS40LS42Ny0uOS0uODgtMS40OC0uMjItLjU5LS4zMy0xLjI2LS4zMy0yLjAyem04LjQtNS4zM2gxLjYxdjIuNTRsLS4wNSAxLjMzYy4yOS0uMjcuNjEtLjUxLjk2LS43MnMuNzYtLjMxIDEuMjQtLjMxYy43MyAwIDEuMjcuMjMgMS42MS43MS4zMy40Ny41IDEuMTQuNSAyLjAydjQuMzFoLTEuNjF2LTQuMWMwLS41Ny0uMDgtLjk3LS4yNS0xLjIxLS4xNy0uMjMtLjQ1LS4zNS0uODMtLjM1LS4zIDAtLjU2LjA4LS43OS4yMi0uMjMuMTUtLjQ5LjM2LS43OC42NHY0LjhoLTEuNjF6bTcuMzcgNi40NWMwLS41Ni4wOS0xLjA2LjI2LTEuNTEuMTgtLjQ1LjQyLS44My43MS0xLjE0LjI5LS4zLjYzLS41NCAxLjAxLS43MS4zOS0uMTcuNzgtLjI1IDEuMTgtLjI1LjQ3IDAgLjg4LjA4IDEuMjMuMjQuMzYuMTYuNjUuMzguODkuNjdzLjQyLjYzLjU0IDEuMDNjLjEyLjQxLjE4Ljg0LjE4IDEuMzIgMCAuMzItLjAyLjU3LS4wNy43NmgtNC4zNmMuMDcuNjIuMjkgMS4xLjY1IDEuNDQuMzYuMzMuODIuNSAxLjM4LjUuMjkgMCAuNTctLjA0LjgzLS4xM3MuNTEtLjIxLjc2LS4zN2wuNTUgMS4wMWMtLjMzLjIxLS42OS4zOS0xLjA5LjUzLS40MS4xNC0uODMuMjEtMS4yNi4yMS0uNDggMC0uOTItLjA4LTEuMzQtLjI1LS40MS0uMTYtLjc2LS40LTEuMDctLjctLjMxLS4zMS0uNTUtLjY5LS43Mi0xLjEzLS4xOC0uNDQtLjI2LS45NS0uMjYtMS41MnptNC42LS42MmMwLS41NS0uMTEtLjk4LS4zNC0xLjI4LS4yMy0uMzEtLjU4LS40Ny0xLjA2LS40Ny0uNDEgMC0uNzcuMTUtMS4wNy40NS0uMzEuMjktLjUuNzMtLjU4IDEuM3ptMi41LjYyYzAtLjU3LjA5LTEuMDguMjgtMS41My4xOC0uNDQuNDMtLjgyLjc1LTEuMTNzLjY5LS41NCAxLjEtLjcxYy40Mi0uMTYuODUtLjI0IDEuMzEtLjI0LjQ1IDAgLjg0LjA4IDEuMTcuMjNzLjYxLjM0Ljg1LjU3bC0uNzcgMS4wMmMtLjE5LS4xNi0uMzgtLjI4LS41Ni0uMzctLjE5LS4wOS0uMzktLjE0LS42MS0uMTQtLjU2IDAtMS4wMS4yMS0xLjM1LjYzLS4zNS40MS0uNTIuOTctLjUyIDEuNjcgMCAuNjkuMTcgMS4yNC41MSAxLjY2LjM0LjQxLjc4LjYyIDEuMzIuNjIuMjggMCAuNTQtLjA2Ljc4LS4xNy4yNC0uMTIuNDUtLjI2LjY0LS40MmwuNjcgMS4wM2MtLjMzLjI5LS42OS41MS0xLjA4LjY1LS4zOS4xNS0uNzguMjMtMS4xOC4yMy0uNDYgMC0uOS0uMDgtMS4zMS0uMjQtLjQtLjE2LS43NS0uMzktMS4wNS0uN3MtLjUzLS42OS0uNy0xLjEzYy0uMTctLjQ1LS4yNS0uOTYtLjI1LTEuNTN6bTYuOTEtNi40NWgxLjU4djYuMTdoLjA1bDIuNTQtMy4xNmgxLjc3bC0yLjM1IDIuOCAyLjU5IDQuMDdoLTEuNzVsLTEuNzctMi45OC0xLjA4IDEuMjN2MS43NWgtMS41OHptMTMuNjkgMS4yN2MtLjI1LS4xMS0uNS0uMTctLjc1LS4xNy0uNTggMC0uODcuMzktLjg3IDEuMTZ2Ljc1aDEuMzR2MS4yN2gtMS4zNHY1LjZoLTEuNjF2LTUuNmgtLjkydi0xLjJsLjkyLS4wN3YtLjcyYzAtLjM1LjA0LS42OC4xMy0uOTguMDgtLjMxLjIxLS41Ny40LS43OXMuNDItLjM5LjcxLS41MWMuMjgtLjEyLjYzLS4xOCAxLjA0LS4xOC4yNCAwIC40OC4wMi42OS4wNy4yMi4wNS40MS4xLjU3LjE3em0uNDggNS4xOGMwLS41Ny4wOS0xLjA4LjI3LTEuNTMuMTctLjQ0LjQxLS44Mi43Mi0xLjEzLjMtLjMxLjY1LS41NCAxLjA0LS43MS4zOS0uMTYuOC0uMjQgMS4yMy0uMjRzLjg0LjA4IDEuMjQuMjRjLjQuMTcuNzQuNCAxLjA0Ljcxcy41NC42OS43MiAxLjEzYy4xOS40NS4yOC45Ni4yOCAxLjUzcy0uMDkgMS4wOC0uMjggMS41M2MtLjE4LjQ0LS40Mi44Mi0uNzIgMS4xM3MtLjY0LjU0LTEuMDQuNy0uODEuMjQtMS4yNC4yNC0uODQtLjA4LTEuMjMtLjI0LS43NC0uMzktMS4wNC0uN2MtLjMxLS4zMS0uNTUtLjY5LS43Mi0xLjEzLS4xOC0uNDUtLjI3LS45Ni0uMjctMS41M3ptMS42NSAwYzAgLjY5LjE0IDEuMjQuNDMgMS42Ni4yOC40MS42OC42MiAxLjE4LjYyLjUxIDAgLjktLjIxIDEuMTktLjYyLjI5LS40Mi40NC0uOTcuNDQtMS42NiAwLS43LS4xNS0xLjI2LS40NC0xLjY3LS4yOS0uNDItLjY4LS42My0xLjE5LS42My0uNSAwLS45LjIxLTEuMTguNjMtLjI5LjQxLS40My45Ny0uNDMgMS42N3ptNi40OC0zLjQ0aDEuMzNsLjEyIDEuMjFoLjA1Yy4yNC0uNDQuNTQtLjc5Ljg4LTEuMDIuMzUtLjI0LjctLjM2IDEuMDctLjM2LjMyIDAgLjU5LjA1Ljc4LjE0bC0uMjggMS40LS4zMy0uMDljLS4xMS0uMDEtLjIzLS4wMi0uMzgtLjAyLS4yNyAwLS41Ni4xLS44Ni4zMXMtLjU1LjU4LS43NyAxLjF2NC4yaC0xLjYxem0tNDcuODcgMTVoMS42MXY0LjFjMCAuNTcuMDguOTcuMjUgMS4yLjE3LjI0LjQ0LjM1LjgxLjM1LjMgMCAuNTctLjA3LjgtLjIyLjIyLS4xNS40Ny0uMzkuNzMtLjczdi00LjdoMS42MXY2Ljg3aC0xLjMybC0uMTItMS4wMWgtLjA0Yy0uMy4zNi0uNjMuNjQtLjk4Ljg2LS4zNS4yMS0uNzYuMzItMS4yNC4zMi0uNzMgMC0xLjI3LS4yNC0xLjYxLS43MS0uMzMtLjQ3LS41LTEuMTQtLjUtMi4wMnptOS40NiA3LjQzdjIuMTZoLTEuNjF2LTkuNTloMS4zM2wuMTIuNzJoLjA1Yy4yOS0uMjQuNjEtLjQ1Ljk3LS42My4zNS0uMTcuNzItLjI2IDEuMS0uMjYuNDMgMCAuODEuMDggMS4xNS4yNC4zMy4xNy42MS40Ljg0LjcxLjI0LjMxLjQxLjY4LjUzIDEuMTEuMTMuNDIuMTkuOTEuMTkgMS40NCAwIC41OS0uMDkgMS4xMS0uMjUgMS41Ny0uMTYuNDctLjM4Ljg1LS42NSAxLjE2LS4yNy4zMi0uNTguNTYtLjk0LjczLS4zNS4xNi0uNzIuMjUtMS4xLjI1LS4zIDAtLjYtLjA3LS45LS4ycy0uNTktLjMxLS44Ny0uNTZ6bTAtMi4zYy4yNi4yMi41LjM3LjczLjQ1LjI0LjA5LjQ2LjEzLjY2LjEzLjQ2IDAgLjg0LS4yIDEuMTUtLjYuMzEtLjM5LjQ2LS45OC40Ni0xLjc3IDAtLjY5LS4xMi0xLjIyLS4zNS0xLjYxLS4yMy0uMzgtLjYxLS41Ny0xLjEzLS41Ny0uNDkgMC0uOTkuMjYtMS41Mi43N3ptNS44Ny0xLjY5YzAtLjU2LjA4LTEuMDYuMjUtMS41MS4xNi0uNDUuMzctLjgzLjY1LTEuMTQuMjctLjMuNTgtLjU0LjkzLS43MXMuNzEtLjI1IDEuMDgtLjI1Yy4zOSAwIC43My4wNyAxIC4yLjI3LjE0LjU0LjMyLjgxLjU1bC0uMDYtMS4xdi0yLjQ5aDEuNjF2OS44OGgtMS4zM2wtLjExLS43NGgtLjA2Yy0uMjUuMjUtLjU0LjQ2LS44OC42NC0uMzMuMTgtLjY5LjI3LTEuMDYuMjctLjg3IDAtMS41Ni0uMzItMi4wNy0uOTVzLS43Ni0xLjUxLS43Ni0yLjY1em0xLjY3LS4wMWMwIC43NC4xMyAxLjMxLjQgMS43LjI2LjM4LjY1LjU4IDEuMTUuNTguNTEgMCAuOTktLjI2IDEuNDQtLjc3di0zLjIxYy0uMjQtLjIxLS40OC0uMzYtLjctLjQ1LS4yMy0uMDgtLjQ2LS4xMi0uNy0uMTItLjQ1IDAtLjgyLjE5LTEuMTMuNTktLjMxLjM5LS40Ni45NS0uNDYgMS42OHptNi4zNSAxLjU5YzAtLjczLjMyLTEuMy45Ny0xLjcxLjY0LS40IDEuNjctLjY4IDMuMDgtLjg0IDAtLjE3LS4wMi0uMzQtLjA3LS41MS0uMDUtLjE2LS4xMi0uMy0uMjItLjQzcy0uMjItLjIyLS4zOC0uM2MtLjE1LS4wNi0uMzQtLjEtLjU4LS4xLS4zNCAwLS42OC4wNy0xIC4ycy0uNjMuMjktLjkzLjQ3bC0uNTktMS4wOGMuMzktLjI0LjgxLS40NSAxLjI4LS42My40Ny0uMTcuOTktLjI2IDEuNTQtLjI2Ljg2IDAgMS41MS4yNSAxLjkzLjc2cy42MyAxLjI1LjYzIDIuMjF2NC4wN2gtMS4zMmwtLjEyLS43NmgtLjA1Yy0uMy4yNy0uNjMuNDgtLjk4LjY2cy0uNzMuMjctMS4xNC4yN2MtLjYxIDAtMS4xLS4xOS0xLjQ4LS41Ni0uMzgtLjM2LS41Ny0uODUtLjU3LTEuNDZ6bTEuNTctLjEyYzAgLjMuMDkuNTMuMjcuNjcuMTkuMTQuNDIuMjEuNzEuMjEuMjggMCAuNTQtLjA3Ljc3LS4ycy40OC0uMzEuNzMtLjU2di0xLjU0Yy0uNDcuMDYtLjg2LjEzLTEuMTguMjMtLjMxLjA5LS41Ny4xOS0uNzYuMzFzLS4zMy4yNS0uNDEuNGMtLjA5LjE1LS4xMy4zMS0uMTMuNDh6bTYuMjktMy42M2gtLjk4di0xLjJsMS4wNi0uMDcuMi0xLjg4aDEuMzR2MS44OGgxLjc1djEuMjdoLTEuNzV2My4yOGMwIC44LjMyIDEuMi45NyAxLjIuMTIgMCAuMjQtLjAxLjM3LS4wNC4xMi0uMDMuMjQtLjA3LjM0LS4xMWwuMjggMS4xOWMtLjE5LjA2LS40LjEyLS42NC4xNy0uMjMuMDUtLjQ5LjA4LS43Ni4wOC0uNCAwLS43NC0uMDYtMS4wMi0uMTgtLjI3LS4xMy0uNDktLjMtLjY3LS41Mi0uMTctLjIxLS4zLS40OC0uMzctLjc4LS4wOC0uMy0uMTItLjY0LS4xMi0xLjAxem00LjM2IDIuMTdjMC0uNTYuMDktMS4wNi4yNy0xLjUxcy40MS0uODMuNzEtMS4xNGMuMjktLjMuNjMtLjU0IDEuMDEtLjcxLjM5LS4xNy43OC0uMjUgMS4xOC0uMjUuNDcgMCAuODguMDggMS4yMy4yNC4zNi4xNi42NS4zOC44OS42N3MuNDIuNjMuNTQgMS4wM2MuMTIuNDEuMTguODQuMTggMS4zMiAwIC4zMi0uMDIuNTctLjA3Ljc2aC00LjM3Yy4wOC42Mi4yOSAxLjEuNjUgMS40NC4zNi4zMy44Mi41IDEuMzguNS4zIDAgLjU4LS4wNC44NC0uMTMuMjUtLjA5LjUxLS4yMS43Ni0uMzdsLjU0IDEuMDFjLS4zMi4yMS0uNjkuMzktMS4wOS41M3MtLjgyLjIxLTEuMjYuMjFjLS40NyAwLS45Mi0uMDgtMS4zMy0uMjUtLjQxLS4xNi0uNzctLjQtMS4wOC0uNy0uMy0uMzEtLjU0LS42OS0uNzItMS4xMy0uMTctLjQ0LS4yNi0uOTUtLjI2LTEuNTJ6bTQuNjEtLjYyYzAtLjU1LS4xMS0uOTgtLjM0LTEuMjgtLjIzLS4zMS0uNTgtLjQ3LTEuMDYtLjQ3LS40MSAwLS43Ny4xNS0xLjA4LjQ1LS4zMS4yOS0uNS43My0uNTcgMS4zem0zLjAxIDIuMjNjLjMxLjI0LjYxLjQzLjkyLjU3LjMuMTMuNjMuMi45OC4yLjM4IDAgLjY1LS4wOC44My0uMjNzLjI3LS4zNS4yNy0uNmMwLS4xNC0uMDUtLjI2LS4xMy0uMzctLjA4LS4xLS4yLS4yLS4zNC0uMjgtLjE0LS4wOS0uMjktLjE2LS40Ny0uMjNsLS41My0uMjJjLS4yMy0uMDktLjQ2LS4xOC0uNjktLjMtLjIzLS4xMS0uNDQtLjI0LS42Mi0uNHMtLjMzLS4zNS0uNDUtLjU1Yy0uMTItLjIxLS4xOC0uNDYtLjE4LS43NSAwLS42MS4yMy0xLjEuNjgtMS40OS40NC0uMzggMS4wNi0uNTcgMS44My0uNTcuNDggMCAuOTEuMDggMS4yOS4yNXMuNzEuMzYuOTkuNTdsLS43NC45OGMtLjI0LS4xNy0uNDktLjMyLS43My0uNDItLjI1LS4xMS0uNTEtLjE2LS43OC0uMTYtLjM1IDAtLjYuMDctLjc2LjIxLS4xNy4xNS0uMjUuMzMtLjI1LjU0IDAgLjE0LjA0LjI2LjEyLjM2cy4xOC4xOC4zMS4yNmMuMTQuMDcuMjkuMTQuNDYuMjFsLjU0LjE5Yy4yMy4wOS40Ny4xOC43LjI5cy40NC4yNC42NC40Yy4xOS4xNi4zNC4zNS40Ni41OC4xMS4yMy4xNy41LjE3LjgyIDAgLjMtLjA2LjU4LS4xNy44My0uMTIuMjYtLjI5LjQ4LS41MS42OC0uMjMuMTktLjUxLjM0LS44NC40NS0uMzQuMTEtLjcyLjE3LTEuMTUuMTctLjQ4IDAtLjk1LS4wOS0xLjQxLS4yNy0uNDYtLjE5LS44Ni0uNDEtMS4yLS42OHoiIGZpbGw9IiM1MzUzNTMiLz48L2c+PC9zdmc+" /></a></div><div class="c-bibliographic-information__column"><h3 class="c-article__sub-heading" id="citeas">Cite this article</h3><p class="c-bibliographic-information__citation">Rodríguez-Pérez, G., Robles, G., Serebrenik, A. <i>et al.</i> How bugs are born: a model to identify how bugs are introduced in software components.
                    <i>Empir Software Eng</i> <b>25, </b>1294–1340 (2020). https://doi.org/10.1007/s10664-019-09781-y</p><p class="c-bibliographic-information__download-citation u-hide-print"><a data-test="citation-link" data-track="click" data-track-action="download article citation" data-track-label="link" href="/article/10.1007/s10664-019-09781-y.ris">Download citation<svg width="16" height="16" class="u-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-download"></use></svg></a></p><ul class="c-bibliographic-information__list" data-test="publication-history"><li class="c-bibliographic-information__list-item"><p>Published<span class="u-hide">: </span><span class="c-bibliographic-information__value"><time datetime="2020-02-04">04 February 2020</time></span></p></li><li class="c-bibliographic-information__list-item"><p>Issue Date<span class="u-hide">: </span><span class="c-bibliographic-information__value"><time datetime="2020-03">March 2020</time></span></p></li><li class="c-bibliographic-information__list-item c-bibliographic-information__list-item--doi"><p><abbr title="Digital Object Identifier">DOI</abbr><span class="u-hide">: </span><span class="c-bibliographic-information__value"><a href="https://doi.org/10.1007/s10664-019-09781-y" data-track="click" data-track-action="view doi" data-track-label="link" itemprop="sameAs">https://doi.org/10.1007/s10664-019-09781-y</a></span></p></li></ul><div data-component="share-box"></div><h3 class="c-article__sub-heading">Keywords</h3><ul class="c-article-subject-list"><li class="c-article-subject-list__subject"><span itemprop="about">Bug origins</span></li><li class="c-article-subject-list__subject"><span itemprop="about">Bug-introducing changes</span></li><li class="c-article-subject-list__subject"><span itemprop="about">First-failing change</span></li><li class="c-article-subject-list__subject"><span itemprop="about">SZZ algorithm</span></li><li class="c-article-subject-list__subject"><span itemprop="about">Extrinsic bugs</span></li><li class="c-article-subject-list__subject"><span itemprop="about">Intrinsic bugs</span></li></ul><div data-component="article-info-list"></div></div></div></div></div></section>
                </div>
            </article>
        </main>

        <div class="c-article-extras u-text-sm u-hide-print" id="sidebar" data-container-type="reading-companion" data-track-component="reading companion">
            <aside>
                <div data-test="download-article-link-wrapper">
                    
    
    <div class="c-pdf-download u-clear-both">
        <a href="https://link.springer.com/content/pdf/10.1007/s10664-019-09781-y.pdf" class="c-pdf-download__link" data-article-pdf="true" data-readcube-pdf-url="true" data-test="pdf-link" data-draft-ignore="true" data-track="click" data-track-action="download pdf" data-track-label="button">
            
                <span>Download PDF</span>
                <svg aria-hidden="true" focusable="false" width="16" height="16" class="u-icon"><use xlink:href="#global-icon-download"/></svg>
            
        </a>
    </div>
    

                </div>

                <div data-test="collections">
                    
                </div>

                <div data-test="editorial-summary">
                    
                </div>

                <div class="c-reading-companion">
                    <div class="c-reading-companion__sticky" data-component="reading-companion-sticky" data-test="reading-companion-sticky">
                        

                        <div class="c-reading-companion__panel c-reading-companion__sections c-reading-companion__panel--active" id="tabpanel-sections">
                            <div class="js-ad">
    <aside class="c-ad c-ad--300x250">
        <div class="c-ad__inner">
            <p class="c-ad__label">Advertisement</p>
            <div id="div-gpt-ad-MPU1" data-gpt-unitpath="/270604982/springerlink/10664/article" data-gpt-sizes="300x250" data-gpt-targeting="pos=MPU1;articleid=9781;"></div>
        </div>
    </aside>
</div>

                        </div>
                        <div class="c-reading-companion__panel c-reading-companion__figures c-reading-companion__panel--full-width" id="tabpanel-figures"></div>
                        <div class="c-reading-companion__panel c-reading-companion__references c-reading-companion__panel--full-width" id="tabpanel-references"></div>
                    </div>
                </div>
            </aside>
        </div>
    </div>


        
    <footer class="app-footer" role="contentinfo">
        <div class="app-footer__aside-wrapper u-hide-print">
            <div class="app-footer__container">
                <p class="app-footer__strapline">Over 10 million scientific documents at your fingertips</p>
                
                    <div class="app-footer__edition" data-component="SV.EditionSwitcher">
                        <span class="u-visually-hidden" data-role="button-dropdown__title" data-btn-text="Switch between Academic & Corporate Edition">Switch Edition</span>
                        <ul class="app-footer-edition-list" data-role="button-dropdown__content" data-test="footer-edition-switcher-list">
                            <li class="selected">
                                <a data-test="footer-academic-link"
                                   href="/siteEdition/link"
                                   id="siteedition-academic-link">Academic Edition</a>
                            </li>
                            <li>
                                <a data-test="footer-corporate-link"
                                   href="/siteEdition/rd"
                                   id="siteedition-corporate-link">Corporate Edition</a>
                            </li>
                        </ul>
                    </div>
                
            </div>
        </div>
        <div class="app-footer__container">
            <ul class="app-footer__nav u-hide-print">
                <li><a href="/">Home</a></li>
                <li><a href="/impressum">Impressum</a></li>
                <li><a href="/termsandconditions">Legal information</a></li>
                <li><a href="/privacystatement">Privacy statement</a></li>
                <li><a href="https://www.springernature.com/ccpa">California Privacy Statement</a></li>
                <li><a href="/cookiepolicy">How we use cookies</a></li>
                
                <li><a class="optanon-toggle-display" href="javascript:void(0);">Manage cookies/Do not sell my data</a></li>
                
                <li><a href="/accessibility">Accessibility</a></li>
                <li><a id="contactus-footer-link" href="/contactus">Contact us</a></li>
            </ul>
            <div class="c-user-metadata">
    
        <p class="c-user-metadata__item">
            <span data-test="footer-user-login-status">Not logged in</span>
            <span data-test="footer-user-ip"> - 87.7.233.122</span>
        </p>
        <p class="c-user-metadata__item" data-test="footer-business-partners">
            Not affiliated
        </p>

        
    
</div>

            <a class="app-footer__parent-logo" target="_blank" rel="noopener" href="//www.springernature.com"  title="Go to Springer Nature">
                <span class="u-visually-hidden">Springer Nature</span>
                <svg width="125" height="12" focusable="false" aria-hidden="true">
                    <image width="125" height="12" alt="Springer Nature logo"
                           src=/oscar-static/images/springerlink/png/springernature-60a72a849b.png
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           xlink:href=/oscar-static/images/springerlink/svg/springernature-ecf01c77dd.svg>
                    </image>
                </svg>
            </a>
            <p class="app-footer__copyright">&copy; 2020 Springer Nature Switzerland AG. Part of <a target="_blank" rel="noopener" href="//www.springernature.com">Springer Nature</a>.</p>
            
        </div>
        
    <svg class="u-hide hide">
        <symbol id="global-icon-chevron-right" viewBox="0 0 16 16">
            <path d="M7.782 7L5.3 4.518c-.393-.392-.4-1.022-.02-1.403a1.001 1.001 0 011.417 0l4.176 4.177a1.001 1.001 0 010 1.416l-4.176 4.177a.991.991 0 01-1.4.016 1 1 0 01.003-1.42L7.782 9l1.013-.998z" fill-rule="evenodd"/>
        </symbol>
        <symbol id="global-icon-download" viewBox="0 0 16 16">
            <path d="M2 14c0-.556.449-1 1.002-1h9.996a.999.999 0 110 2H3.002A1.006 1.006 0 012 14zM9 2v6.8l2.482-2.482c.392-.392 1.022-.4 1.403-.02a1.001 1.001 0 010 1.417l-4.177 4.177a1.001 1.001 0 01-1.416 0L3.115 7.715a.991.991 0 01-.016-1.4 1 1 0 011.42.003L7 8.8V2c0-.55.444-.996 1-.996.552 0 1 .445 1 .996z" fill-rule="evenodd"/>
        </symbol>
        <symbol id="global-icon-email" viewBox="0 0 18 18">
            <path d="M1.995 2h14.01A2 2 0 0118 4.006v9.988A2 2 0 0116.005 16H1.995A2 2 0 010 13.994V4.006A2 2 0 011.995 2zM1 13.994A1 1 0 001.995 15h14.01A1 1 0 0017 13.994V4.006A1 1 0 0016.005 3H1.995A1 1 0 001 4.006zM9 11L2 7V5.557l7 4 7-4V7z" fill-rule="evenodd"/>
        </symbol>
        <symbol id="global-icon-institution" viewBox="0 0 18 18">
            <path d="M14 8a1 1 0 011 1v6h1.5a.5.5 0 01.5.5v.5h.5a.5.5 0 01.5.5V18H0v-1.5a.5.5 0 01.5-.5H1v-.5a.5.5 0 01.5-.5H3V9a1 1 0 112 0v6h8V9a1 1 0 011-1zM6 8l2 1v4l-2 1zm6 0v6l-2-1V9zM9.573.401l7.036 4.925A.92.92 0 0116.081 7H1.92a.92.92 0 01-.528-1.674L8.427.401a1 1 0 011.146 0zM9 2.441L5.345 5h7.31z" fill-rule="evenodd"/>
        </symbol>
        <symbol id="global-icon-search" viewBox="0 0 22 22">
            <path fill-rule="evenodd" d="M21.697 20.261a1.028 1.028 0 01.01 1.448 1.034 1.034 0 01-1.448-.01l-4.267-4.267A9.812 9.811 0 010 9.812a9.812 9.811 0 1117.43 6.182zM9.812 18.222A8.41 8.41 0 109.81 1.403a8.41 8.41 0 000 16.82z"/>
        </symbol>
    </svg>

    </footer>



    </div>
    
    
</body>
</html>

